var IS = Object.defineProperty;
var BS = (n, e, t) => e in n ? IS(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t;
var Ae = (n, e, t) => (BS(n, typeof e != "symbol" ? e + "" : e, t), t);
(function () {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s);
    new MutationObserver(s => {
        for (const r of s)
            if (r.type === "childList")
                for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function t(s) {
        const r = {};
        return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r
    }

    function i(s) {
        if (s.ep) return;
        s.ep = !0;
        const r = t(s);
        fetch(s.href, r)
    }
})();
/**
 * @vue/shared v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function hA(n, e) {
    const t = new Set(n.split(","));
    return e ? i => t.has(i.toLowerCase()) : i => t.has(i)
}
const Vt = {},
    xl = [],
    ss = () => { },
    RS = () => !1,
    xf = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97),
    fA = n => n.startsWith("onUpdate:"),
    Di = Object.assign,
    pA = (n, e) => {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1)
    },
    PS = Object.prototype.hasOwnProperty,
    _t = (n, e) => PS.call(n, e),
    Ze = Array.isArray,
    yl = n => yf(n) === "[object Map]",
    Qx = n => yf(n) === "[object Set]",
    at = n => typeof n == "function",
    mi = n => typeof n == "string",
    Ia = n => typeof n == "symbol",
    Ut = n => n !== null && typeof n == "object",
    zx = n => (Ut(n) || at(n)) && at(n.then) && at(n.catch),
    Gx = Object.prototype.toString,
    yf = n => Gx.call(n),
    DS = n => yf(n).slice(8, -1),
    Hx = n => yf(n) === "[object Object]",
    mA = n => mi(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n,
    Qc = hA(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    Ef = n => {
        const e = Object.create(null);
        return t => e[t] || (e[t] = n(t))
    },
    LS = /-(\w)/g,
    Ws = Ef(n => n.replace(LS, (e, t) => t ? t.toUpperCase() : "")),
    kS = /\B([A-Z])/g,
    ec = Ef(n => n.replace(kS, "-$1").toLowerCase()),
    wf = Ef(n => n.charAt(0).toUpperCase() + n.slice(1)),
    ep = Ef(n => n ? `on${wf(n)}` : ""),
    _o = (n, e) => !Object.is(n, e),
    tp = (n, e) => {
        for (let t = 0; t < n.length; t++) n[t](e)
    },
    Vx = (n, e, t) => {
        Object.defineProperty(n, e, {
            configurable: !0,
            enumerable: !1,
            value: t
        })
    },
    FS = n => {
        const e = parseFloat(n);
        return isNaN(e) ? n : e
    },
    NS = n => {
        const e = mi(n) ? Number(n) : NaN;
        return isNaN(e) ? n : e
    };
let N0;
const Wx = () => N0 || (N0 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function Cf(n) {
    if (Ze(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
            const i = n[t],
                s = mi(i) ? zS(i) : Cf(i);
            if (s)
                for (const r in s) e[r] = s[r]
        }
        return e
    } else if (mi(n) || Ut(n)) return n
}
const OS = /;(?![^(]*\))/g,
    US = /:([^]+)/,
    QS = /\/\*[^]*?\*\//g;

function zS(n) {
    const e = {};
    return n.replace(QS, "").split(OS).forEach(t => {
        if (t) {
            const i = t.split(US);
            i.length > 1 && (e[i[0].trim()] = i[1].trim())
        }
    }), e
}

function xr(n) {
    let e = "";
    if (mi(n)) e = n;
    else if (Ze(n))
        for (let t = 0; t < n.length; t++) {
            const i = xr(n[t]);
            i && (e += i + " ")
        } else if (Ut(n))
        for (const t in n) n[t] && (e += t + " ");
    return e.trim()
}
const GS = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    HS = hA(GS);

function qx(n) {
    return !!n || n === ""
}
const Pi = n => mi(n) ? n : n == null ? "" : Ze(n) || Ut(n) && (n.toString === Gx || !at(n.toString)) ? JSON.stringify(n, $x, 2) : String(n),
    $x = (n, e) => e && e.__v_isRef ? $x(n, e.value) : yl(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((t, [i, s], r) => (t[ip(i, r) + " =>"] = s, t), {})
    } : Qx(e) ? {
        [`Set(${e.size})`]: [...e.values()].map(t => ip(t))
    } : Ia(e) ? ip(e) : Ut(e) && !Ze(e) && !Hx(e) ? String(e) : e,
    ip = (n, e = "") => {
        var t;
        return Ia(n) ? `Symbol(${(t = n.description) != null ? t : e})` : n
    };
/**
 * @vue/reactivity v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let Ln;
class jx {
    constructor(e = !1) {
        this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Ln, !e && Ln && (this.index = (Ln.scopes || (Ln.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const t = Ln;
            try {
                return Ln = this, e()
            } finally {
                Ln = t
            }
        }
    }
    on() {
        Ln = this
    }
    off() {
        Ln = this.parent
    }
    stop(e) {
        if (this._active) {
            let t, i;
            for (t = 0, i = this.effects.length; t < i; t++) this.effects[t].stop();
            for (t = 0, i = this.cleanups.length; t < i; t++) this.cleanups[t]();
            if (this.scopes)
                for (t = 0, i = this.scopes.length; t < i; t++) this.scopes[t].stop(!0);
            if (!this.detached && this.parent && !e) {
                const s = this.parent.scopes.pop();
                s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function Yx(n) {
    return new jx(n)
}

function VS(n, e = Ln) {
    e && e.active && e.effects.push(n)
}

function Xx() {
    return Ln
}

function WS(n) {
    Ln && Ln.cleanups.push(n)
}
let aa;
class gA {
    constructor(e, t, i, s) {
        this.fn = e, this.trigger = t, this.scheduler = i, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, VS(this, s)
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1, So();
            for (let e = 0; e < this._depsLength; e++) {
                const t = this.deps[e];
                if (t.computed && (qS(t.computed), this._dirtyLevel >= 4)) break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0), Mo()
        }
        return this._dirtyLevel >= 4
    }
    set dirty(e) {
        this._dirtyLevel = e ? 4 : 0
    }
    run() {
        if (this._dirtyLevel = 0, !this.active) return this.fn();
        let e = ho,
            t = aa;
        try {
            return ho = !0, aa = this, this._runnings++, O0(this), this.fn()
        } finally {
            U0(this), this._runnings--, aa = t, ho = e
        }
    }
    stop() {
        var e;
        this.active && (O0(this), U0(this), (e = this.onStop) == null || e.call(this), this.active = !1)
    }
}

function qS(n) {
    return n.value
}

function O0(n) {
    n._trackId++, n._depsLength = 0
}

function U0(n) {
    if (n.deps.length > n._depsLength) {
        for (let e = n._depsLength; e < n.deps.length; e++) Kx(n.deps[e], n);
        n.deps.length = n._depsLength
    }
}

function Kx(n, e) {
    const t = n.get(e);
    t !== void 0 && e._trackId !== t && (n.delete(e), n.size === 0 && n.cleanup())
}
let ho = !0,
    Fm = 0;
const Jx = [];

function So() {
    Jx.push(ho), ho = !1
}

function Mo() {
    const n = Jx.pop();
    ho = n === void 0 ? !0 : n
}

function AA() {
    Fm++
}

function _A() {
    for (Fm--; !Fm && Nm.length;) Nm.shift()()
}

function Zx(n, e, t) {
    if (e.get(n) !== n._trackId) {
        e.set(n, n._trackId);
        const i = n.deps[n._depsLength];
        i !== e ? (i && Kx(i, n), n.deps[n._depsLength++] = e) : n._depsLength++
    }
}
const Nm = [];

function ey(dataMap, dirtyLevel, threshold) {
    AA();

    for (const key of dataMap.keys()) {
        let isTracked;

        // Check if the dirty level is below the threshold
        if (key._dirtyLevel < dirtyLevel) {
            isTracked = dataMap.get(key) === key._trackId;
            key._shouldSchedule = key._shouldSchedule || (key._dirtyLevel === 0);
            key._dirtyLevel = dirtyLevel;
        }

        // Trigger if should schedule
        if (key._shouldSchedule) {
            isTracked = dataMap.get(key) === key._trackId;
            key.trigger();
            if ((!key._runnings || key.allowRecurse) && key._dirtyLevel !== 2) {
                key._shouldSchedule = false;
                if (key.scheduler) {
                    Nm.push(key.scheduler);
                }
            }
        }
    }

    _A();
}
const ty = (n, e) => {
    const t = new Map;
    return t.cleanup = n, t.computed = e, t
},
    Oh = new WeakMap,
    la = Symbol(""),
    Om = Symbol("");

function Bn(n, e, t) {
    if (ho && aa) {
        let i = Oh.get(n);
        i || Oh.set(n, i = new Map);
        let s = i.get(t);
        s || i.set(t, s = ty(() => i.delete(t))), Zx(aa, s)
    }
}

function Ar(n, e, t, i, s, r) {
    const o = Oh.get(n);
    if (!o) return;
    let a = [];
    if (e === "clear") a = [...o.values()];
    else if (t === "length" && Ze(n)) {
        const l = Number(i);
        o.forEach((c, u) => {
            (u === "length" || !Ia(u) && u >= l) && a.push(c)
        })
    } else switch (t !== void 0 && a.push(o.get(t)), e) {
        case "add":
            Ze(n) ? mA(t) && a.push(o.get("length")) : (a.push(o.get(la)), yl(n) && a.push(o.get(Om)));
            break;
        case "delete":
            Ze(n) || (a.push(o.get(la)), yl(n) && a.push(o.get(Om)));
            break;
        case "set":
            yl(n) && a.push(o.get(la));
            break
    }
    AA();
    for (const l of a) l && ey(l, 4);
    _A()
}

function $S(n, e) {
    var t;
    return (t = Oh.get(n)) == null ? void 0 : t.get(e)
}
const jS = hA("__proto__,__v_isRef,__isVue"),
    iy = new Set(Object.getOwnPropertyNames(Symbol).filter(n => n !== "arguments" && n !== "caller").map(n => Symbol[n]).filter(Ia)),
    Q0 = YS();

function YS() {
    const n = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        n[e] = function (...t) {
            const i = At(this);
            for (let r = 0, o = this.length; r < o; r++) Bn(i, "get", r + "");
            const s = i[e](...t);
            return s === -1 || s === !1 ? i[e](...t.map(At)) : s
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        n[e] = function (...t) {
            So(), AA();
            const i = At(this)[e].apply(this, t);
            return _A(), Mo(), i
        }
    }), n
}

function XS(n) {
    Ia(n) || (n = String(n));
    const e = At(this);
    return Bn(e, "has", n), e.hasOwnProperty(n)
}
class ny {
    constructor(e = !1, t = !1) {
        this._isReadonly = e, this._isShallow = t
    }
    get(e, t, i) {
        const s = this._isReadonly,
            r = this._isShallow;
        if (t === "__v_isReactive") return !s;
        if (t === "__v_isReadonly") return s;
        if (t === "__v_isShallow") return r;
        if (t === "__v_raw") return i === (s ? r ? cM : ay : r ? oy : ry).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
        const o = Ze(e);
        if (!s) {
            if (o && _t(Q0, t)) return Reflect.get(Q0, t, i);
            if (t === "hasOwnProperty") return XS
        }
        const a = Reflect.get(e, t, i);
        return (Ia(t) ? iy.has(t) : jS(t)) || (s || Bn(e, "get", t), r) ? a : Ei(a) ? o && mA(t) ? a : a.value : Ut(a) ? s ? ly(a) : Mf(a) : a
    }
}
class sy extends ny {
    constructor(e = !1) {
        super(!1, e)
    }
    set(e, t, i, s) {
        let r = e[t];
        if (!this._isShallow) {
            const l = hu(r);
            if (!Uh(i) && !hu(i) && (r = At(r), i = At(i)), !Ze(e) && Ei(r) && !Ei(i)) return l ? !1 : (r.value = i, !0)
        }
        const o = Ze(e) && mA(t) ? Number(t) < e.length : _t(e, t),
            a = Reflect.set(e, t, i, s);
        return e === At(s) && (o ? _o(i, r) && Ar(e, "set", t, i) : Ar(e, "add", t, i)), a
    }
    deleteProperty(e, t) {
        const i = _t(e, t);
        e[t];
        const s = Reflect.deleteProperty(e, t);
        return s && i && Ar(e, "delete", t, void 0), s
    }
    has(e, t) {
        const i = Reflect.has(e, t);
        return (!Ia(t) || !iy.has(t)) && Bn(e, "has", t), i
    }
    ownKeys(e) {
        return Bn(e, "iterate", Ze(e) ? "length" : la), Reflect.ownKeys(e)
    }
}
class KS extends ny {
    constructor(e = !1) {
        super(!0, e)
    }
    set(e, t) {
        return !0
    }
    deleteProperty(e, t) {
        return !0
    }
}
const JS = new sy,
    ZS = new KS,
    eM = new sy(!0),
    vA = n => n,
    Sf = n => Reflect.getPrototypeOf(n);

function ed(n, e, t = !1, i = !1) {
    n = n.__v_raw;
    const s = At(n),
        r = At(e);
    t || (_o(e, r) && Bn(s, "get", e), Bn(s, "get", r));
    const {
        has: o
    } = Sf(s), a = i ? vA : t ? EA : fu;
    if (o.call(s, e)) return a(n.get(e));
    if (o.call(s, r)) return a(n.get(r));
    n !== s && n.get(e)
}

function td(n, e = !1) {
    const t = this.__v_raw,
        i = At(t),
        s = At(n);
    return e || (_o(n, s) && Bn(i, "has", n), Bn(i, "has", s)), n === s ? t.has(n) : t.has(n) || t.has(s)
}

function id(n, e = !1) {
    return n = n.__v_raw, !e && Bn(At(n), "iterate", la), Reflect.get(n, "size", n)
}

function z0(n) {
    n = At(n);
    const e = At(this);
    return Sf(e).has.call(e, n) || (e.add(n), Ar(e, "add", n, n)), this
}

function G0(n, e) {
    e = At(e);
    const t = At(this),
        {
            has: i,
            get: s
        } = Sf(t);
    let r = i.call(t, n);
    r || (n = At(n), r = i.call(t, n));
    const o = s.call(t, n);
    return t.set(n, e), r ? _o(e, o) && Ar(t, "set", n, e) : Ar(t, "add", n, e), this
}

function H0(n) {
    const e = At(this),
        {
            has: t,
            get: i
        } = Sf(e);
    let s = t.call(e, n);
    s || (n = At(n), s = t.call(e, n)), i && i.call(e, n);
    const r = e.delete(n);
    return s && Ar(e, "delete", n, void 0), r
}

function V0() {
    const n = At(this),
        e = n.size !== 0,
        t = n.clear();
    return e && Ar(n, "clear", void 0, void 0), t
}

function nd(n, e) {
    return function (i, s) {
        const r = this,
            o = r.__v_raw,
            a = At(o),
            l = e ? vA : n ? EA : fu;
        return !n && Bn(a, "iterate", la), o.forEach((c, u) => i.call(s, l(c), l(u), r))
    }
}

function sd(n, e, t) {
    return function (...i) {
        const s = this.__v_raw,
            r = At(s),
            o = yl(r),
            a = n === "entries" || n === Symbol.iterator && o,
            l = n === "keys" && o,
            c = s[n](...i),
            u = t ? vA : e ? EA : fu;
        return !e && Bn(r, "iterate", l ? Om : la), {
            next() {
                const {
                    value: d,
                    done: h
                } = c.next();
                return h ? {
                    value: d,
                    done: h
                } : {
                    value: a ? [u(d[0]), u(d[1])] : u(d),
                    done: h
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function Br(n) {
    return function (...e) {
        return n === "delete" ? !1 : n === "clear" ? void 0 : this
    }
}

function tM() {
    const n = {
        get(r) {
            return ed(this, r)
        },
        get size() {
            return id(this)
        },
        has: td,
        add: z0,
        set: G0,
        delete: H0,
        clear: V0,
        forEach: nd(!1, !1)
    },
        e = {
            get(r) {
                return ed(this, r, !1, !0)
            },
            get size() {
                return id(this)
            },
            has: td,
            add: z0,
            set: G0,
            delete: H0,
            clear: V0,
            forEach: nd(!1, !0)
        },
        t = {
            get(r) {
                return ed(this, r, !0)
            },
            get size() {
                return id(this, !0)
            },
            has(r) {
                return td.call(this, r, !0)
            },
            add: Br("add"),
            set: Br("set"),
            delete: Br("delete"),
            clear: Br("clear"),
            forEach: nd(!0, !1)
        },
        i = {
            get(r) {
                return ed(this, r, !0, !0)
            },
            get size() {
                return id(this, !0)
            },
            has(r) {
                return td.call(this, r, !0)
            },
            add: Br("add"),
            set: Br("set"),
            delete: Br("delete"),
            clear: Br("clear"),
            forEach: nd(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(r => {
        n[r] = sd(r, !1, !1), t[r] = sd(r, !0, !1), e[r] = sd(r, !1, !0), i[r] = sd(r, !0, !0)
    }), [n, t, e, i]
}
const [iM, nM, sM, rM] = tM();

function bA(n, e) {
    const t = e ? n ? rM : sM : n ? nM : iM;
    return (i, s, r) => s === "__v_isReactive" ? !n : s === "__v_isReadonly" ? n : s === "__v_raw" ? i : Reflect.get(_t(t, s) && s in i ? t : i, s, r)
}
const oM = {
    get: bA(!1, !1)
},
    aM = {
        get: bA(!1, !0)
    },
    lM = {
        get: bA(!0, !1)
    },
    ry = new WeakMap,
    oy = new WeakMap,
    ay = new WeakMap,
    cM = new WeakMap;

function uM(n) {
    switch (n) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function dM(n) {
    return n.__v_skip || !Object.isExtensible(n) ? 0 : uM(DS(n))
}

function Mf(n) {
    return hu(n) ? n : xA(n, !1, JS, oM, ry)
}

function hM(n) {
    return xA(n, !1, eM, aM, oy)
}

function ly(n) {
    return xA(n, !0, ZS, lM, ay)
}

function xA(n, e, t, i, s) {
    if (!Ut(n) || n.__v_raw && !(e && n.__v_isReactive)) return n;
    const r = s.get(n);
    if (r) return r;
    const o = dM(n);
    if (o === 0) return n;
    const a = new Proxy(n, o === 2 ? i : t);
    return s.set(n, a), a
}

function ca(n) {
    return hu(n) ? ca(n.__v_raw) : !!(n && n.__v_isReactive)
}

function hu(n) {
    return !!(n && n.__v_isReadonly)
}

function Uh(n) {
    return !!(n && n.__v_isShallow)
}

function cy(n) {
    return n ? !!n.__v_raw : !1
}

function At(n) {
    const e = n && n.__v_raw;
    return e ? At(e) : n
}

function yA(n) {
    return Object.isExtensible(n) && Vx(n, "__v_skip", !0), n
}
const fu = n => Ut(n) ? Mf(n) : n,
    EA = n => Ut(n) ? ly(n) : n;
class uy {
    constructor(e, t, i, s) {
        this.getter = e, this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new gA(() => e(this._value), () => dh(this, this.effect._dirtyLevel === 2 ? 2 : 3)), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = i
    }
    get value() {
        const e = At(this);
        return (!e._cacheable || e.effect.dirty) && _o(e._value, e._value = e.effect.run()) && dh(e, 4), dy(e), e.effect._dirtyLevel >= 2 && dh(e, 2), e._value
    }
    set value(e) {
        this._setter(e)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(e) {
        this.effect.dirty = e
    }
}

function fM(n, e, t = !1) {
    let i, s;
    const r = at(n);
    return r ? (i = n, s = ss) : (i = n.get, s = n.set), new uy(i, s, r || !s, t)
}

function dy(n) {
    var e;
    ho && aa && (n = At(n), Zx(aa, (e = n.dep) != null ? e : n.dep = ty(() => n.dep = void 0, n instanceof uy ? n : void 0)))
}

function dh(n, e = 4, t) {
    n = At(n);
    const i = n.dep;
    i && ey(i, e)
}

function Ei(n) {
    return !!(n && n.__v_isRef === !0)
}

function hy(n) {
    return pM(n, !1)
}

function pM(n, e) {
    return Ei(n) ? n : new mM(n, e)
}
class mM {
    constructor(e, t) {
        this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : At(e), this._value = t ? e : fu(e)
    }
    get value() {
        return dy(this), this._value
    }
    set value(e) {
        const t = this.__v_isShallow || Uh(e) || hu(e);
        e = t ? e : At(e), _o(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : fu(e), dh(this, 4))
    }
}

function gM(n) {
    return Ei(n) ? n.value : n
}
const AM = {
    get: (n, e, t) => gM(Reflect.get(n, e, t)),
    set: (n, e, t, i) => {
        const s = n[e];
        return Ei(s) && !Ei(t) ? (s.value = t, !0) : Reflect.set(n, e, t, i)
    }
};

function fy(n) {
    return ca(n) ? n : new Proxy(n, AM)
}

function _M(n) {
    const e = Ze(n) ? new Array(n.length) : {};
    for (const t in n) e[t] = bM(n, t);
    return e
}
class vM {
    constructor(e, t, i) {
        this._object = e, this._key = t, this._defaultValue = i, this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return $S(At(this._object), this._key)
    }
}

function bM(n, e, t) {
    const i = n[e];
    return Ei(i) ? i : new vM(n, e, t)
}
/**
 * @vue/runtime-core v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function fo(n, e, t, i) {
    try {
        return i ? n(...i) : n()
    } catch (s) {
        Tf(s, e, t)
    }
}

function ls(n, e, t, i) {
    if (at(n)) {
        const s = fo(n, e, t, i);
        return s && zx(s) && s.catch(r => {
            Tf(r, e, t)
        }), s
    }
    if (Ze(n)) {
        const s = [];
        for (let r = 0; r < n.length; r++) s.push(ls(n[r], e, t, i));
        return s
    }
}

function Tf(n, e, t, i = !0) {
    const s = e ? e.vnode : null;
    if (e) {
        let r = e.parent;
        const o = e.proxy,
            a = `https://vuejs.org/error-reference/#runtime-${t}`;
        for (; r;) {
            const c = r.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](n, o, a) === !1) return
            }
            r = r.parent
        }
        const l = e.appContext.config.errorHandler;
        if (l) {
            So(), fo(l, null, 10, [n, o, a]), Mo();
            return
        }
    }
    xM(n, t, s, i)
}

function xM(n, e, t, i = !0) {
    console.error(n)
}
let pu = !1,
    Um = !1;
const Yi = [];
let Ls = 0;
const El = [];
let Hr = null,
    Zo = 0;
const py = Promise.resolve();
let wA = null;

function my(n) {
    const e = wA || py;
    return n ? e.then(this ? n.bind(this) : n) : e
}

function yM(n) {
    let e = Ls + 1,
        t = Yi.length;
    for (; e < t;) {
        const i = e + t >>> 1,
            s = Yi[i],
            r = mu(s);
        r < n || r === n && s.pre ? e = i + 1 : t = i
    }
    return e
}

function CA(n) {
    (!Yi.length || !Yi.includes(n, pu && n.allowRecurse ? Ls + 1 : Ls)) && (n.id == null ? Yi.push(n) : Yi.splice(yM(n.id), 0, n), gy())
}

function gy() {
    !pu && !Um && (Um = !0, wA = py.then(_y))
}

function EM(n) {
    const e = Yi.indexOf(n);
    e > Ls && Yi.splice(e, 1)
}

function wM(n) {
    Ze(n) ? El.push(...n) : (!Hr || !Hr.includes(n, n.allowRecurse ? Zo + 1 : Zo)) && El.push(n), gy()
}

function W0(n, e, t = pu ? Ls + 1 : 0) {
    for (; t < Yi.length; t++) {
        const i = Yi[t];
        if (i && i.pre) {
            if (n && i.id !== n.uid) continue;
            Yi.splice(t, 1), t--, i()
        }
    }
}

function Ay(n) {
    if (El.length) {
        const e = [...new Set(El)].sort((t, i) => mu(t) - mu(i));
        if (El.length = 0, Hr) {
            Hr.push(...e);
            return
        }
        for (Hr = e, Zo = 0; Zo < Hr.length; Zo++) Hr[Zo]();
        Hr = null, Zo = 0
    }
}
const mu = n => n.id == null ? 1 / 0 : n.id,
    CM = (n, e) => {
        const t = mu(n) - mu(e);
        if (t === 0) {
            if (n.pre && !e.pre) return -1;
            if (e.pre && !n.pre) return 1
        }
        return t
    };

function _y(n) {
    Um = !1, pu = !0, Yi.sort(CM);
    try {
        for (Ls = 0; Ls < Yi.length; Ls++) {
            const e = Yi[Ls];
            e && e.active !== !1 && fo(e, null, 14)
        }
    } finally {
        Ls = 0, Yi.length = 0, Ay(), pu = !1, wA = null, (Yi.length || El.length) && _y()
    }
}

function SM(n, e, ...t) {
    if (n.isUnmounted) return;
    const i = n.vnode.props || Vt;
    let s = t;
    const r = e.startsWith("update:"),
        o = r && e.slice(7);
    if (o && o in i) {
        const u = `${o === "modelValue" ? "model" : o}Modifiers`,
            {
                number: d,
                trim: h
            } = i[u] || Vt;
        h && (s = t.map(f => mi(f) ? f.trim() : f)), d && (s = t.map(FS))
    }
    let a, l = i[a = ep(e)] || i[a = ep(Ws(e))];
    !l && r && (l = i[a = ep(ec(e))]), l && ls(l, n, 6, s);
    const c = i[a + "Once"];
    if (c) {
        if (!n.emitted) n.emitted = {};
        else if (n.emitted[a]) return;
        n.emitted[a] = !0, ls(c, n, 6, s)
    }
}

function vy(n, e, t = !1) {
    const i = e.emitsCache,
        s = i.get(n);
    if (s !== void 0) return s;
    const r = n.emits;
    let o = {},
        a = !1;
    if (!at(n)) {
        const l = c => {
            const u = vy(c, e, !0);
            u && (a = !0, Di(o, u))
        };
        !t && e.mixins.length && e.mixins.forEach(l), n.extends && l(n.extends), n.mixins && n.mixins.forEach(l)
    }
    return !r && !a ? (Ut(n) && i.set(n, null), null) : (Ze(r) ? r.forEach(l => o[l] = null) : Di(o, r), Ut(n) && i.set(n, o), o)
}

function If(n, e) {
    return !n || !xf(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), _t(n, e[0].toLowerCase() + e.slice(1)) || _t(n, ec(e)) || _t(n, e))
}
let Oi = null,
    by = null;

function Qh(n) {
    const e = Oi;
    return Oi = n, by = n && n.type.__scopeId || null, e
}

function Ts(n, e = Oi, t) {
    if (!e || n._n) return n;
    const i = (...s) => {
        i._d && n_(-1);
        const r = Qh(e);
        let o;
        try {
            o = n(...s)
        } finally {
            Qh(r), i._d && n_(1)
        }
        return o
    };
    return i._n = !0, i._c = !0, i._d = !0, i
}

function np(n) {
    const {
        type: e,
        vnode: t,
        proxy: i,
        withProxy: s,
        props: r,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: c,
        render: u,
        renderCache: d,
        data: h,
        setupState: f,
        ctx: m,
        inheritAttrs: g
    } = n;
    let A, p;
    const v = Qh(n);
    try {
        if (t.shapeFlag & 4) {
            const b = s || i,
                w = b;
            A = Ps(u.call(w, b, d, r, f, h, m)), p = l
        } else {
            const b = e;
            A = Ps(b.length > 1 ? b(r, {
                attrs: l,
                slots: a,
                emit: c
            }) : b(r, null)), p = e.props ? l : MM(l)
        }
    } catch (b) {
        Vc.length = 0, Tf(b, n, 1), A = gt(cs)
    }
    let _ = A;
    if (p && g !== !1) {
        const b = Object.keys(p),
            {
                shapeFlag: w
            } = _;
        b.length && w & 7 && (o && b.some(fA) && (p = TM(p, o)), _ = vo(_, p))
    }
    return t.dirs && (_ = vo(_), _.dirs = _.dirs ? _.dirs.concat(t.dirs) : t.dirs), t.transition && (_.transition = t.transition), A = _, Qh(v), A
}
const MM = n => {
    let e;
    for (const t in n) (t === "class" || t === "style" || xf(t)) && ((e || (e = {}))[t] = n[t]);
    return e
},
    TM = (n, e) => {
        const t = {};
        for (const i in n) (!fA(i) || !(i.slice(9) in e)) && (t[i] = n[i]);
        return t
    };

function IM(n, e, t) {
    const {
        props: i,
        children: s,
        component: r
    } = n, {
        props: o,
        children: a,
        patchFlag: l
    } = e, c = r.emitsOptions;
    if (e.dirs || e.transition) return !0;
    if (t && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return i ? q0(i, o, c) : !!o;
        if (l & 8) {
            const u = e.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                const h = u[d];
                if (o[h] !== i[h] && !If(c, h)) return !0
            }
        }
    } else return (s || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? o ? q0(i, o, c) : !0 : !!o;
    return !1
}

function q0(n, e, t) {
    const i = Object.keys(e);
    if (i.length !== Object.keys(n).length) return !0;
    for (let s = 0; s < i.length; s++) {
        const r = i[s];
        if (e[r] !== n[r] && !If(t, r)) return !0
    }
    return !1
}

function BM({
    vnode: n,
    parent: e
}, t) {
    for (; e;) {
        const i = e.subTree;
        if (i.suspense && i.suspense.activeBranch === n && (i.el = n.el), i === n) (n = e.vnode).el = t, e = e.parent;
        else break
    }
}
const xy = "components";

function Mt(n, e) {
    return PM(xy, n, !0, e) || n
}
const RM = Symbol.for("v-ndc");

function PM(n, e, t = !0, i = !1) {
    const s = Oi || Bi;
    if (s) {
        const r = s.type;
        if (n === xy) {
            const a = RT(r, !1);
            if (a && (a === e || a === Ws(e) || a === wf(Ws(e)))) return r
        }
        const o = $0(s[n] || r[n], e) || $0(s.appContext[n], e);
        return !o && i ? r : o
    }
}

function $0(n, e) {
    return n && (n[e] || n[Ws(e)] || n[wf(Ws(e))])
}
const DM = n => n.__isSuspense;

function LM(n, e) {
    e && e.pendingBranch ? Ze(n) ? e.effects.push(...n) : e.effects.push(n) : wM(n)
}
const kM = Symbol.for("v-scx"),
    FM = () => Hc(kM),
    rd = {};

function hh(n, e, t) {
    return yy(n, e, t)
}

function yy(n, e, {
    immediate: t,
    deep: i,
    flush: s,
    once: r,
    onTrack: o,
    onTrigger: a
} = Vt) {
    if (e && r) {
        const E = e;
        e = (...C) => {
            E(...C), w()
        }
    }
    const l = Bi,
        c = E => i === !0 ? E : cl(E, i === !1 ? 1 : void 0);
    let u, d = !1,
        h = !1;
    if (Ei(n) ? (u = () => n.value, d = Uh(n)) : ca(n) ? (u = () => c(n), d = !0) : Ze(n) ? (h = !0, d = n.some(E => ca(E) || Uh(E)), u = () => n.map(E => {
        if (Ei(E)) return E.value;
        if (ca(E)) return c(E);
        if (at(E)) return fo(E, l, 2)
    })) : at(n) ? e ? u = () => fo(n, l, 2) : u = () => (f && f(), ls(n, l, 3, [m])) : u = ss, e && i) {
        const E = u;
        u = () => cl(E())
    }
    let f, m = E => {
        f = _.onStop = () => {
            fo(E, l, 4), f = _.onStop = void 0
        }
    },
        g;
    if (Df)
        if (m = ss, e ? t && ls(e, l, 3, [u(), h ? [] : void 0, m]) : u(), s === "sync") {
            const E = FM();
            g = E.__watcherHandles || (E.__watcherHandles = [])
        } else return ss;
    let A = h ? new Array(n.length).fill(rd) : rd;
    const p = () => {
        if (!(!_.active || !_.dirty))
            if (e) {
                const E = _.run();
                (i || d || (h ? E.some((C, S) => _o(C, A[S])) : _o(E, A))) && (f && f(), ls(e, l, 3, [E, A === rd ? void 0 : h && A[0] === rd ? [] : A, m]), A = E)
            } else _.run()
    };
    p.allowRecurse = !!e;
    let v;
    s === "sync" ? v = p : s === "post" ? v = () => _n(p, l && l.suspense) : (p.pre = !0, l && (p.id = l.uid), v = () => CA(p));
    const _ = new gA(u, ss, v),
        b = Xx(),
        w = () => {
            _.stop(), b && pA(b.effects, _)
        };
    return e ? t ? p() : A = _.run() : s === "post" ? _n(_.run.bind(_), l && l.suspense) : _.run(), g && g.push(w), w
}

function NM(n, e, t) {
    const i = this.proxy,
        s = mi(n) ? n.includes(".") ? Ey(i, n) : () => i[n] : n.bind(i, i);
    let r;
    at(e) ? r = e : (r = e.handler, t = e);
    const o = zu(this),
        a = yy(s, r.bind(i), t);
    return o(), a
}

function Ey(n, e) {
    const t = e.split(".");
    return () => {
        let i = n;
        for (let s = 0; s < t.length && i; s++) i = i[t[s]];
        return i
    }
}

function cl(n, e, t = 0, i) {
    if (!Ut(n) || n.__v_skip) return n;
    if (e && e > 0) {
        if (t >= e) return n;
        t++
    }
    if (i = i || new Set, i.has(n)) return n;
    if (i.add(n), Ei(n)) cl(n.value, e, t, i);
    else if (Ze(n))
        for (let s = 0; s < n.length; s++) cl(n[s], e, t, i);
    else if (Qx(n) || yl(n)) n.forEach(s => {
        cl(s, e, t, i)
    });
    else if (Hx(n))
        for (const s in n) cl(n[s], e, t, i);
    return n
}

function Lo(n, e, t, i) {
    const s = n.dirs,
        r = e && e.dirs;
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        r && (a.oldValue = r[o].value);
        let l = a.dir[i];
        l && (So(), ls(l, t, 8, [n.el, a, n, e]), Mo())
    }
}
const Vr = Symbol("_leaveCb"),
    od = Symbol("_enterCb");

function OM() {
    const n = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ty(() => {
        n.isMounted = !0
    }), Iy(() => {
        n.isUnmounting = !0
    }), n
}
const Yn = [Function, Array],
    wy = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: Yn,
        onEnter: Yn,
        onAfterEnter: Yn,
        onEnterCancelled: Yn,
        onBeforeLeave: Yn,
        onLeave: Yn,
        onAfterLeave: Yn,
        onLeaveCancelled: Yn,
        onBeforeAppear: Yn,
        onAppear: Yn,
        onAfterAppear: Yn,
        onAppearCancelled: Yn
    },
    UM = {
        name: "BaseTransition",
        props: wy,
        setup(n, {
            slots: e
        }) {
            const t = ST(),
                i = OM();
            return () => {
                const s = e.default && Sy(e.default(), !0);
                if (!s || !s.length) return;
                let r = s[0];
                if (s.length > 1) {
                    for (const h of s)
                        if (h.type !== cs) {
                            r = h;
                            break
                        }
                }
                const o = At(n),
                    {
                        mode: a
                    } = o;
                if (i.isLeaving) return sp(r);
                const l = j0(r);
                if (!l) return sp(r);
                const c = Qm(l, o, i, t);
                zm(l, c);
                const u = t.subTree,
                    d = u && j0(u);
                if (d && d.type !== cs && !ea(l, d)) {
                    const h = Qm(d, o, i, t);
                    if (zm(d, h), a === "out-in") return i.isLeaving = !0, h.afterLeave = () => {
                        i.isLeaving = !1, t.update.active !== !1 && (t.effect.dirty = !0, t.update())
                    }, sp(r);
                    a === "in-out" && l.type !== cs && (h.delayLeave = (f, m, g) => {
                        const A = Cy(i, d);
                        A[String(d.key)] = d, f[Vr] = () => {
                            m(), f[Vr] = void 0, delete c.delayedLeave
                        }, c.delayedLeave = g
                    })
                }
                return r
            }
        }
    },
    QM = UM;

function Cy(n, e) {
    const {
        leavingVNodes: t
    } = n;
    let i = t.get(e.type);
    return i || (i = Object.create(null), t.set(e.type, i)), i
}

function Qm(n, e, t, i) {
    const {
        appear: s,
        mode: r,
        persisted: o = !1,
        onBeforeEnter: a,
        onEnter: l,
        onAfterEnter: c,
        onEnterCancelled: u,
        onBeforeLeave: d,
        onLeave: h,
        onAfterLeave: f,
        onLeaveCancelled: m,
        onBeforeAppear: g,
        onAppear: A,
        onAfterAppear: p,
        onAppearCancelled: v
    } = e, _ = String(n.key), b = Cy(t, n), w = (S, x) => {
        S && ls(S, i, 9, x)
    }, E = (S, x) => {
        const y = x[1];
        w(S, x), Ze(S) ? S.every(P => P.length <= 1) && y() : S.length <= 1 && y()
    }, C = {
        mode: r,
        persisted: o,
        beforeEnter(S) {
            let x = a;
            if (!t.isMounted)
                if (s) x = g || a;
                else return;
            S[Vr] && S[Vr](!0);
            const y = b[_];
            y && ea(n, y) && y.el[Vr] && y.el[Vr](), w(x, [S])
        },
        enter(S) {
            let x = l,
                y = c,
                P = u;
            if (!t.isMounted)
                if (s) x = A || l, y = p || c, P = v || u;
                else return;
            let T = !1;
            const R = S[od] = D => {
                T || (T = !0, D ? w(P, [S]) : w(y, [S]), C.delayedLeave && C.delayedLeave(), S[od] = void 0)
            };
            x ? E(x, [S, R]) : R()
        },
        leave(S, x) {
            const y = String(n.key);
            if (S[od] && S[od](!0), t.isUnmounting) return x();
            w(d, [S]);
            let P = !1;
            const T = S[Vr] = R => {
                P || (P = !0, x(), R ? w(m, [S]) : w(f, [S]), S[Vr] = void 0, b[y] === n && delete b[y])
            };
            b[y] = n, h ? E(h, [S, T]) : T()
        },
        clone(S) {
            return Qm(S, e, t, i)
        }
    };
    return C
}

function sp(n) {
    if (Bf(n)) return n = vo(n), n.children = null, n
}

function j0(n) {
    return Bf(n) ? n.children ? n.children[0] : void 0 : n
}

function zm(n, e) {
    n.shapeFlag & 6 && n.component ? zm(n.component.subTree, e) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent), n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e
}

function Sy(n, e = !1, t) {
    let i = [],
        s = 0;
    for (let r = 0; r < n.length; r++) {
        let o = n[r];
        const a = t == null ? o.key : String(t) + String(o.key != null ? o.key : r);
        o.type === Bt ? (o.patchFlag & 128 && s++, i = i.concat(Sy(o.children, e, a))) : (e || o.type !== cs) && i.push(a != null ? vo(o, {
            key: a
        }) : o)
    }
    if (s > 1)
        for (let r = 0; r < i.length; r++) i[r].patchFlag = -2;
    return i
}
const zc = n => !!n.type.__asyncLoader,
    Bf = n => n.type.__isKeepAlive;

function zM(n, e) {
    My(n, "a", e)
}

function GM(n, e) {
    My(n, "da", e)
}

function My(n, e, t = Bi) {
    const i = n.__wdc || (n.__wdc = () => {
        let s = t;
        for (; s;) {
            if (s.isDeactivated) return;
            s = s.parent
        }
        return n()
    });
    if (Rf(e, i, t), t) {
        let s = t.parent;
        for (; s && s.parent;) Bf(s.parent.vnode) && HM(i, e, t, s), s = s.parent
    }
}

function HM(n, e, t, i) {
    const s = Rf(e, n, i, !0);
    By(() => {
        pA(i[e], s)
    }, t)
}

function Rf(n, e, t = Bi, i = !1) {
    if (t) {
        const s = t[n] || (t[n] = []),
            r = e.__weh || (e.__weh = (...o) => {
                if (t.isUnmounted) return;
                So();
                const a = zu(t),
                    l = ls(e, t, n, o);
                return a(), Mo(), l
            });
        return i ? s.unshift(r) : s.push(r), r
    }
}
const Cr = n => (e, t = Bi) => (!Df || n === "sp") && Rf(n, (...i) => e(...i), t),
    VM = Cr("bm"),
    Ty = Cr("m"),
    WM = Cr("bu"),
    qM = Cr("u"),
    Iy = Cr("bum"),
    By = Cr("um"),
    $M = Cr("sp"),
    jM = Cr("rtg"),
    YM = Cr("rtc");

function XM(n, e = Bi) {
    Rf("ec", n, e)
}

function xn(n, e, t, i) {
    let s;
    const r = t && t[i];
    if (Ze(n) || mi(n)) {
        s = new Array(n.length);
        for (let o = 0, a = n.length; o < a; o++) s[o] = e(n[o], o, void 0, r && r[o])
    } else if (typeof n == "number") {
        s = new Array(n);
        for (let o = 0; o < n; o++) s[o] = e(o + 1, o, void 0, r && r[o])
    } else if (Ut(n))
        if (n[Symbol.iterator]) s = Array.from(n, (o, a) => e(o, a, void 0, r && r[a]));
        else {
            const o = Object.keys(n);
            s = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                s[a] = e(n[c], c, a, r && r[a])
            }
        }
    else s = [];
    return t && (t[i] = s), s
}

function KM(n, e, t = {}, i, s) {
    if (Oi.isCE || Oi.parent && zc(Oi.parent) && Oi.parent.isCE) return e !== "default" && (t.name = e), gt("slot", t, i && i());
    let r = n[e];
    r && r._c && (r._d = !1), Ge();
    const o = r && Ry(r(t)),
        a = yn(Bt, {
            key: t.key || o && o.key || `_${e}`
        }, o || (i ? i() : []), o && n._ === 1 ? 64 : -2);
    return !s && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), r && r._c && (r._d = !0), a
}

function Ry(n) {
    return n.some(e => Gh(e) ? !(e.type === cs || e.type === Bt && !Ry(e.children)) : !0) ? n : null
}
const Gm = n => n ? Wy(n) ? IA(n) || n.proxy : Gm(n.parent) : null,
    Gc = Di(Object.create(null), {
        $: n => n,
        $el: n => n.vnode.el,
        $data: n => n.data,
        $props: n => n.props,
        $attrs: n => n.attrs,
        $slots: n => n.slots,
        $refs: n => n.refs,
        $parent: n => Gm(n.parent),
        $root: n => Gm(n.root),
        $emit: n => n.emit,
        $options: n => SA(n),
        $forceUpdate: n => n.f || (n.f = () => {
            n.effect.dirty = !0, CA(n.update)
        }),
        $nextTick: n => n.n || (n.n = my.bind(n.proxy)),
        $watch: n => NM.bind(n)
    }),
    rp = (n, e) => n !== Vt && !n.__isScriptSetup && _t(n, e),
    JM = {
        get({
            _: n
        }, e) {
            if (e === "__v_skip") return !0;
            const {
                ctx: t,
                setupState: i,
                data: s,
                props: r,
                accessCache: o,
                type: a,
                appContext: l
            } = n;
            let c;
            if (e[0] !== "$") {
                const f = o[e];
                if (f !== void 0) switch (f) {
                    case 1:
                        return i[e];
                    case 2:
                        return s[e];
                    case 4:
                        return t[e];
                    case 3:
                        return r[e]
                } else {
                    if (rp(i, e)) return o[e] = 1, i[e];
                    if (s !== Vt && _t(s, e)) return o[e] = 2, s[e];
                    if ((c = n.propsOptions[0]) && _t(c, e)) return o[e] = 3, r[e];
                    if (t !== Vt && _t(t, e)) return o[e] = 4, t[e];
                    Hm && (o[e] = 0)
                }
            }
            const u = Gc[e];
            let d, h;
            if (u) return e === "$attrs" && Bn(n.attrs, "get", ""), u(n);
            if ((d = a.__cssModules) && (d = d[e])) return d;
            if (t !== Vt && _t(t, e)) return o[e] = 4, t[e];
            if (h = l.config.globalProperties, _t(h, e)) return h[e]
        },
        set({
            _: n
        }, e, t) {
            const {
                data: i,
                setupState: s,
                ctx: r
            } = n;
            return rp(s, e) ? (s[e] = t, !0) : i !== Vt && _t(i, e) ? (i[e] = t, !0) : _t(n.props, e) || e[0] === "$" && e.slice(1) in n ? !1 : (r[e] = t, !0)
        },
        has({
            _: {
                data: n,
                setupState: e,
                accessCache: t,
                ctx: i,
                appContext: s,
                propsOptions: r
            }
        }, o) {
            let a;
            return !!t[o] || n !== Vt && _t(n, o) || rp(e, o) || (a = r[0]) && _t(a, o) || _t(i, o) || _t(Gc, o) || _t(s.config.globalProperties, o)
        },
        defineProperty(n, e, t) {
            return t.get != null ? n._.accessCache[e] = 0 : _t(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t)
        }
    };

function Y0(n) {
    return Ze(n) ? n.reduce((e, t) => (e[t] = null, e), {}) : n
}
let Hm = !0;

function ZM(n) {
    const e = SA(n),
        t = n.proxy,
        i = n.ctx;
    Hm = !1, e.beforeCreate && X0(e.beforeCreate, n, "bc");
    const {
        data: s,
        computed: r,
        methods: o,
        watch: a,
        provide: l,
        inject: c,
        created: u,
        beforeMount: d,
        mounted: h,
        beforeUpdate: f,
        updated: m,
        activated: g,
        deactivated: A,
        beforeDestroy: p,
        beforeUnmount: v,
        destroyed: _,
        unmounted: b,
        render: w,
        renderTracked: E,
        renderTriggered: C,
        errorCaptured: S,
        serverPrefetch: x,
        expose: y,
        inheritAttrs: P,
        components: T,
        directives: R,
        filters: D
    } = e;
    if (c && eT(c, i, null), o)
        for (const F in o) {
            const L = o[F];
            at(L) && (i[F] = L.bind(t))
        }
    if (s) {
        const F = s.call(t, t);
        Ut(F) && (n.data = Mf(F))
    }
    if (Hm = !0, r)
        for (const F in r) {
            const L = r[F],
                W = at(L) ? L.bind(t, t) : at(L.get) ? L.get.bind(t, t) : ss,
                k = !at(L) && at(L.set) ? L.set.bind(t) : ss,
                $ = $y({
                    get: W,
                    set: k
                });
            Object.defineProperty(i, F, {
                enumerable: !0,
                configurable: !0,
                get: () => $.value,
                set: X => $.value = X
            })
        }
    if (a)
        for (const F in a) Py(a[F], i, t, F);
    if (l) {
        const F = at(l) ? l.call(t) : l;
        Reflect.ownKeys(F).forEach(L => {
            oT(L, F[L])
        })
    }
    u && X0(u, n, "c");

    function Q(F, L) {
        Ze(L) ? L.forEach(W => F(W.bind(t))) : L && F(L.bind(t))
    }
    if (Q(VM, d), Q(Ty, h), Q(WM, f), Q(qM, m), Q(zM, g), Q(GM, A), Q(XM, S), Q(YM, E), Q(jM, C), Q(Iy, v), Q(By, b), Q($M, x), Ze(y))
        if (y.length) {
            const F = n.exposed || (n.exposed = {});
            y.forEach(L => {
                Object.defineProperty(F, L, {
                    get: () => t[L],
                    set: W => t[L] = W
                })
            })
        } else n.exposed || (n.exposed = {});
    w && n.render === ss && (n.render = w), P != null && (n.inheritAttrs = P), T && (n.components = T), R && (n.directives = R)
}

function eT(n, e, t = ss) {
    Ze(n) && (n = Vm(n));
    for (const i in n) {
        const s = n[i];
        let r;
        Ut(s) ? "default" in s ? r = Hc(s.from || i, s.default, !0) : r = Hc(s.from || i) : r = Hc(s), Ei(r) ? Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => r.value,
            set: o => r.value = o
        }) : e[i] = r
    }
}

function X0(n, e, t) {
    ls(Ze(n) ? n.map(i => i.bind(e.proxy)) : n.bind(e.proxy), e, t)
}

function Py(n, e, t, i) {
    const s = i.includes(".") ? Ey(t, i) : () => t[i];
    if (mi(n)) {
        const r = e[n];
        at(r) && hh(s, r)
    } else if (at(n)) hh(s, n.bind(t));
    else if (Ut(n))
        if (Ze(n)) n.forEach(r => Py(r, e, t, i));
        else {
            const r = at(n.handler) ? n.handler.bind(t) : e[n.handler];
            at(r) && hh(s, r, n)
        }
}

function SA(n) {
    const e = n.type,
        {
            mixins: t,
            extends: i
        } = e,
        {
            mixins: s,
            optionsCache: r,
            config: {
                optionMergeStrategies: o
            }
        } = n.appContext,
        a = r.get(e);
    let l;
    return a ? l = a : !s.length && !t && !i ? l = e : (l = {}, s.length && s.forEach(c => zh(l, c, o, !0)), zh(l, e, o)), Ut(e) && r.set(e, l), l
}

function zh(n, e, t, i = !1) {
    const {
        mixins: s,
        extends: r
    } = e;
    r && zh(n, r, t, !0), s && s.forEach(o => zh(n, o, t, !0));
    for (const o in e)
        if (!(i && o === "expose")) {
            const a = tT[o] || t && t[o];
            n[o] = a ? a(n[o], e[o]) : e[o]
        }
    return n
}
const tT = {
    data: K0,
    props: J0,
    emits: J0,
    methods: Cc,
    computed: Cc,
    beforeCreate: nn,
    created: nn,
    beforeMount: nn,
    mounted: nn,
    beforeUpdate: nn,
    updated: nn,
    beforeDestroy: nn,
    beforeUnmount: nn,
    destroyed: nn,
    unmounted: nn,
    activated: nn,
    deactivated: nn,
    errorCaptured: nn,
    serverPrefetch: nn,
    components: Cc,
    directives: Cc,
    watch: nT,
    provide: K0,
    inject: iT
};

function K0(n, e) {
    return e ? n ? function () {
        return Di(at(n) ? n.call(this, this) : n, at(e) ? e.call(this, this) : e)
    } : e : n
}

function iT(n, e) {
    return Cc(Vm(n), Vm(e))
}

function Vm(n) {
    if (Ze(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++) e[n[t]] = n[t];
        return e
    }
    return n
}

function nn(n, e) {
    return n ? [...new Set([].concat(n, e))] : e
}

function Cc(n, e) {
    return n ? Di(Object.create(null), n, e) : e
}

function J0(arr1, arr2) {
    if (arr1) {
        if (Ze(arr1) && Ze(arr2)) {
            return [...new Set([...arr1, ...arr2])];
        } else {
            return Di(Object.create(null), Y0(arr1), Y0(arr2 ?? {}));
        }
    }
    return arr2;
}

function nT(n, e) {
    if (!n) return e;
    if (!e) return n;
    const t = Di(Object.create(null), n);
    for (const i in e) t[i] = nn(n[i], e[i]);
    return t
}

function Dy() {
    return {
        app: null,
        config: {
            isNativeTag: RS,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let sT = 0;

function rT(n, e) {
    return function (i, s = null) {
        at(i) || (i = Di({}, i)), s != null && !Ut(s) && (s = null);
        const r = Dy(),
            o = new WeakSet;
        let a = !1;
        const l = r.app = {
            _uid: sT++,
            _component: i,
            _props: s,
            _container: null,
            _context: r,
            _instance: null,
            version: LT,
            get config() {
                return r.config
            },
            set config(c) { },
            use(c, ...u) {
                return o.has(c) || (c && at(c.install) ? (o.add(c), c.install(l, ...u)) : at(c) && (o.add(c), c(l, ...u))), l
            },
            mixin(c) {
                return r.mixins.includes(c) || r.mixins.push(c), l
            },
            component(c, u) {
                return u ? (r.components[c] = u, l) : r.components[c]
            },
            directive(c, u) {
                return u ? (r.directives[c] = u, l) : r.directives[c]
            },
            mount(c, u, d) {
                if (!a) {
                    const h = gt(i, s);
                    return h.appContext = r, d === !0 ? d = "svg" : d === !1 && (d = void 0), u && e ? e(h, c) : n(h, c, d), a = !0, l._container = c, c.__vue_app__ = l, IA(h.component) || h.component.proxy
                }
            },
            unmount() {
                a && (n(null, l._container), delete l._container.__vue_app__)
            },
            provide(c, u) {
                return r.provides[c] = u, l
            },
            runWithContext(c) {
                const u = wl;
                wl = l;
                try {
                    return c()
                } finally {
                    wl = u
                }
            }
        };
        return l
    }
}
let wl = null;

function oT(n, e) {
    if (Bi) {
        let t = Bi.provides;
        const i = Bi.parent && Bi.parent.provides;
        i === t && (t = Bi.provides = Object.create(i)), t[n] = e
    }
}

function Hc(n, e, t = !1) {
    const i = Bi || Oi;
    if (i || wl) {
        const s = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : wl._context.provides;
        if (s && n in s) return s[n];
        if (arguments.length > 1) return t && at(e) ? e.call(i && i.proxy) : e
    }
}

function aT() {
    return !!(Bi || Oi || wl)
}
const Ly = Object.create(null),
    Wm = () => Object.create(Ly),
    ky = n => Object.getPrototypeOf(n) === Ly;

function lT(n, e, t, i = !1) {
    const s = {},
        r = Wm();
    n.propsDefaults = Object.create(null), Fy(n, e, s, r);
    for (const o in n.propsOptions[0]) o in s || (s[o] = void 0);
    t ? n.props = i ? s : hM(s) : n.type.props ? n.props = s : n.props = r, n.attrs = r
}

function cT(n, e, t, i) {
    const {
        props: s,
        attrs: r,
        vnode: {
            patchFlag: o
        }
    } = n, a = At(s), [l] = n.propsOptions;
    let c = !1;
    if ((i || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = n.vnode.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                let h = u[d];
                if (If(n.emitsOptions, h)) continue;
                const f = e[h];
                if (l)
                    if (_t(r, h)) f !== r[h] && (r[h] = f, c = !0);
                    else {
                        const m = Ws(h);
                        s[m] = qm(l, a, m, f, n, !1)
                    }
                else f !== r[h] && (r[h] = f, c = !0)
            }
        }
    } else {
        Fy(n, e, s, r) && (c = !0);
        let u;
        for (const d in a) (!e || !_t(e, d) && ((u = ec(d)) === d || !_t(e, u))) && (l ? t && (t[d] !== void 0 || t[u] !== void 0) && (s[d] = qm(l, a, d, void 0, n, !0)) : delete s[d]);
        if (r !== a)
            for (const d in r) (!e || !_t(e, d)) && (delete r[d], c = !0)
    }
    c && Ar(n.attrs, "set", "")
}

function Fy(n, e, t, i) {
    const [s, r] = n.propsOptions;
    let o = !1,
        a;
    if (e)
        for (let l in e) {
            if (Qc(l)) continue;
            const c = e[l];
            let u;
            s && _t(s, u = Ws(l)) ? !r || !r.includes(u) ? t[u] = c : (a || (a = {}))[u] = c : If(n.emitsOptions, l) || (!(l in i) || c !== i[l]) && (i[l] = c, o = !0)
        }
    if (r) {
        const l = At(t),
            c = a || Vt;
        for (let u = 0; u < r.length; u++) {
            const d = r[u];
            t[d] = qm(s, l, d, c[d], n, !_t(c, d))
        }
    }
    return o
}

function qm(n, e, t, i, s, r) {
    const o = n[t];
    if (o != null) {
        const a = _t(o, "default");
        if (a && i === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && at(l)) {
                const {
                    propsDefaults: c
                } = s;
                if (t in c) i = c[t];
                else {
                    const u = zu(s);
                    i = c[t] = l.call(null, e), u()
                }
            } else i = l
        }
        o[0] && (r && !a ? i = !1 : o[1] && (i === "" || i === ec(t)) && (i = !0))
    }
    return i
}

function Ny(n, e, t = !1) {
    const i = e.propsCache,
        s = i.get(n);
    if (s) return s;
    const r = n.props,
        o = {},
        a = [];
    let l = !1;
    if (!at(n)) {
        const u = d => {
            l = !0;
            const [h, f] = Ny(d, e, !0);
            Di(o, h), f && a.push(...f)
        };
        !t && e.mixins.length && e.mixins.forEach(u), n.extends && u(n.extends), n.mixins && n.mixins.forEach(u)
    }
    if (!r && !l) return Ut(n) && i.set(n, xl), xl;
    if (Ze(r))
        for (let u = 0; u < r.length; u++) {
            const d = Ws(r[u]);
            Z0(d) && (o[d] = Vt)
        } else if (r)
        for (const u in r) {
            const d = Ws(u);
            if (Z0(d)) {
                const h = r[u],
                    f = o[d] = Ze(h) || at(h) ? {
                        type: h
                    } : Di({}, h);
                if (f) {
                    const m = i_(Boolean, f.type),
                        g = i_(String, f.type);
                    f[0] = m > -1, f[1] = g < 0 || m < g, (m > -1 || _t(f, "default")) && a.push(d)
                }
            }
        }
    const c = [o, a];
    return Ut(n) && i.set(n, c), c
}

function Z0(n) {
    return n[0] !== "$" && !Qc(n)
}

function e_(n) {
    return n === null ? "null" : typeof n == "function" ? n.name || "" : typeof n == "object" && n.constructor && n.constructor.name || ""
}

function t_(n, e) {
    return e_(n) === e_(e)
}

function i_(n, e) {
    return Ze(e) ? e.findIndex(t => t_(t, n)) : at(e) && t_(e, n) ? 0 : -1
}
const Oy = n => n[0] === "_" || n === "$stable",
    MA = n => Ze(n) ? n.map(Ps) : [Ps(n)],
    uT = (n, e, t) => {
        if (e._n) return e;
        const i = Ts((...s) => MA(e(...s)), t);
        return i._c = !1, i
    },
    Uy = (n, e, t) => {
        const i = n._ctx;
        for (const s in n) {
            if (Oy(s)) continue;
            const r = n[s];
            if (at(r)) e[s] = uT(s, r, i);
            else if (r != null) {
                const o = MA(r);
                e[s] = () => o
            }
        }
    },
    Qy = (n, e) => {
        const t = MA(e);
        n.slots.default = () => t
    },
    dT = (n, e) => {
        if (n.vnode.shapeFlag & 32) {
            const t = e._;
            t ? (n.slots = At(e), Vx(n.slots, "_", t)) : Uy(e, n.slots = Wm())
        } else n.slots = Wm(), e && Qy(n, e)
    },
    hT = (n, e, t) => {
        const {
            vnode: i,
            slots: s
        } = n;
        let r = !0,
            o = Vt;
        if (i.shapeFlag & 32) {
            const a = e._;
            a ? t && a === 1 ? r = !1 : (Di(s, e), !t && a === 1 && delete s._) : (r = !e.$stable, Uy(e, s)), o = e
        } else e && (Qy(n, e), o = {
            default: 1
        });
        if (r)
            for (const a in s) !Oy(a) && o[a] == null && delete s[a]
    };

function $m(n, e, t, i, s = !1) {
    if (Ze(n)) {
        n.forEach((h, f) => $m(h, e && (Ze(e) ? e[f] : e), t, i, s));
        return
    }
    if (zc(i) && !s) return;
    const r = i.shapeFlag & 4 ? IA(i.component) || i.component.proxy : i.el,
        o = s ? null : r,
        {
            i: a,
            r: l
        } = n,
        c = e && e.r,
        u = a.refs === Vt ? a.refs = {} : a.refs,
        d = a.setupState;
    if (c != null && c !== l && (mi(c) ? (u[c] = null, _t(d, c) && (d[c] = null)) : Ei(c) && (c.value = null)), at(l)) fo(l, a, 12, [o, u]);
    else {
        const h = mi(l),
            f = Ei(l);
        if (h || f) {
            const m = () => {
                if (n.f) {
                    const g = h ? _t(d, l) ? d[l] : u[l] : l.value;
                    s ? Ze(g) && pA(g, r) : Ze(g) ? g.includes(r) || g.push(r) : h ? (u[l] = [r], _t(d, l) && (d[l] = u[l])) : (l.value = [r], n.k && (u[n.k] = l.value))
                } else h ? (u[l] = o, _t(d, l) && (d[l] = o)) : f && (l.value = o, n.k && (u[n.k] = o))
            };
            o ? (m.id = -1, _n(m, t)) : m()
        }
    }
}
const _n = LM;

function fT(n) {
    return pT(n)
}

function pT(n, e) {
    const t = Wx();
    t.__VUE__ = !0;
    const {
        insert: i,
        remove: s,
        patchProp: r,
        createElement: o,
        createText: a,
        createComment: l,
        setText: c,
        setElementText: u,
        parentNode: d,
        nextSibling: h,
        setScopeId: f = ss,
        insertStaticContent: m
    } = n, g = (N, G, Y, se = null, M = null, I = null, H = void 0, V = null, j = !!G.dynamicChildren) => {
        if (N === G) return;
        N && !ea(N, G) && (se = fe(N), X(N, M, I, !0), N = null), G.patchFlag === -2 && (j = !1, G.dynamicChildren = null);
        const {
            type: q,
            ref: he,
            shapeFlag: re
        } = G;
        switch (q) {
            case Pf:
                A(N, G, Y, se);
                break;
            case cs:
                p(N, G, Y, se);
                break;
            case fh:
                N == null && v(G, Y, se, H);
                break;
            case Bt:
                T(N, G, Y, se, M, I, H, V, j);
                break;
            default:
                re & 1 ? w(N, G, Y, se, M, I, H, V, j) : re & 6 ? R(N, G, Y, se, M, I, H, V, j) : (re & 64 || re & 128) && q.process(N, G, Y, se, M, I, H, V, j, Ce)
        }
        he != null && M && $m(he, N && N.ref, I, G || N, !G)
    }, A = (N, G, Y, se) => {
        if (N == null) i(G.el = a(G.children), Y, se);
        else {
            const M = G.el = N.el;
            G.children !== N.children && c(M, G.children)
        }
    }, p = (N, G, Y, se) => {
        N == null ? i(G.el = l(G.children || ""), Y, se) : G.el = N.el
    }, v = (N, G, Y, se) => {
        [N.el, N.anchor] = m(N.children, G, Y, se, N.el, N.anchor)
    }, _ = ({
        el: N,
        anchor: G
    }, Y, se) => {
        let M;
        for (; N && N !== G;) M = h(N), i(N, Y, se), N = M;
        i(G, Y, se)
    }, b = ({
        el: N,
        anchor: G
    }) => {
        let Y;
        for (; N && N !== G;) Y = h(N), s(N), N = Y;
        s(G)
    }, w = (N, G, Y, se, M, I, H, V, j) => {
        G.type === "svg" ? H = "svg" : G.type === "math" && (H = "mathml"), N == null ? E(G, Y, se, M, I, H, V, j) : x(N, G, M, I, H, V, j)
    }, E = (N, G, Y, se, M, I, H, V) => {
        let j, q;
        const {
            props: he,
            shapeFlag: re,
            transition: de,
            dirs: ge
        } = N;
        if (j = N.el = o(N.type, I, he && he.is, he), re & 8 ? u(j, N.children) : re & 16 && S(N.children, j, null, se, M, op(N, I), H, V), ge && Lo(N, null, se, "created"), C(j, N, N.scopeId, H, se), he) {
            for (const me in he) me !== "value" && !Qc(me) && r(j, me, null, he[me], I, N.children, se, M, ue);
            "value" in he && r(j, "value", null, he.value, I), (q = he.onVnodeBeforeMount) && Is(q, se, N)
        }
        ge && Lo(N, null, se, "beforeMount");
        const ce = mT(M, de);
        ce && de.beforeEnter(j), i(j, G, Y), ((q = he && he.onVnodeMounted) || ce || ge) && _n(() => {
            q && Is(q, se, N), ce && de.enter(j), ge && Lo(N, null, se, "mounted")
        }, M)
    }, C = (N, G, Y, se, M) => {
        if (Y && f(N, Y), se)
            for (let I = 0; I < se.length; I++) f(N, se[I]);
        if (M) {
            let I = M.subTree;
            if (G === I) {
                const H = M.vnode;
                C(N, H, H.scopeId, H.slotScopeIds, M.parent)
            }
        }
    }, S = (N, G, Y, se, M, I, H, V, j = 0) => {
        for (let q = j; q < N.length; q++) {
            const he = N[q] = V ? Wr(N[q]) : Ps(N[q]);
            g(null, he, G, Y, se, M, I, H, V)
        }
    }, x = (N, G, Y, se, M, I, H) => {
        const V = G.el = N.el;
        let {
            patchFlag: j,
            dynamicChildren: q,
            dirs: he
        } = G;
        j |= N.patchFlag & 16;
        const re = N.props || Vt,
            de = G.props || Vt;
        let ge;
        if (Y && ko(Y, !1), (ge = de.onVnodeBeforeUpdate) && Is(ge, Y, G, N), he && Lo(G, N, Y, "beforeUpdate"), Y && ko(Y, !0), q ? y(N.dynamicChildren, q, V, Y, se, op(G, M), I) : H || L(N, G, V, null, Y, se, op(G, M), I, !1), j > 0) {
            if (j & 16) P(V, G, re, de, Y, se, M);
            else if (j & 2 && re.class !== de.class && r(V, "class", null, de.class, M), j & 4 && r(V, "style", re.style, de.style, M), j & 8) {
                const ce = G.dynamicProps;
                for (let me = 0; me < ce.length; me++) {
                    const xe = ce[me],
                        ve = re[xe],
                        we = de[xe];
                    (we !== ve || xe === "value") && r(V, xe, ve, we, M, N.children, Y, se, ue)
                }
            }
            j & 1 && N.children !== G.children && u(V, G.children)
        } else !H && q == null && P(V, G, re, de, Y, se, M);
        ((ge = de.onVnodeUpdated) || he) && _n(() => {
            ge && Is(ge, Y, G, N), he && Lo(G, N, Y, "updated")
        }, se)
    }, y = (N, G, Y, se, M, I, H) => {
        for (let V = 0; V < G.length; V++) {
            const j = N[V],
                q = G[V],
                he = j.el && (j.type === Bt || !ea(j, q) || j.shapeFlag & 70) ? d(j.el) : Y;
            g(j, q, he, null, se, M, I, H, !0)
        }
    }, P = (N, G, Y, se, M, I, H) => {
        if (Y !== se) {
            if (Y !== Vt)
                for (const V in Y) !Qc(V) && !(V in se) && r(N, V, Y[V], null, H, G.children, M, I, ue);
            for (const V in se) {
                if (Qc(V)) continue;
                const j = se[V],
                    q = Y[V];
                j !== q && V !== "value" && r(N, V, q, j, H, G.children, M, I, ue)
            }
            "value" in se && r(N, "value", Y.value, se.value, H)
        }
    }, T = (N, G, Y, se, M, I, H, V, j) => {
        const q = G.el = N ? N.el : a(""),
            he = G.anchor = N ? N.anchor : a("");
        let {
            patchFlag: re,
            dynamicChildren: de,
            slotScopeIds: ge
        } = G;
        ge && (V = V ? V.concat(ge) : ge), N == null ? (i(q, Y, se), i(he, Y, se), S(G.children || [], Y, he, M, I, H, V, j)) : re > 0 && re & 64 && de && N.dynamicChildren ? (y(N.dynamicChildren, de, Y, M, I, H, V), (G.key != null || M && G === M.subTree) && zy(N, G, !0)) : L(N, G, Y, he, M, I, H, V, j)
    }, R = (N, G, Y, se, M, I, H, V, j) => {
        G.slotScopeIds = V, N == null ? G.shapeFlag & 512 ? M.ctx.activate(G, Y, se, H, j) : D(G, Y, se, M, I, H, j) : U(N, G, j)
    }, D = (N, G, Y, se, M, I, H) => {
        const V = N.component = CT(N, se, M);
        if (Bf(N) && (V.ctx.renderer = Ce), MT(V), V.asyncDep) {
            if (M && M.registerDep(V, Q), !N.el) {
                const j = V.subTree = gt(cs);
                p(null, j, G, Y)
            }
        } else Q(V, N, G, Y, M, I, H)
    }, U = (N, G, Y) => {
        const se = G.component = N.component;
        if (IM(N, G, Y))
            if (se.asyncDep && !se.asyncResolved) {
                F(se, G, Y);
                return
            } else se.next = G, EM(se.update), se.effect.dirty = !0, se.update();
        else G.el = N.el, se.vnode = G
    }, Q = (N, G, Y, se, M, I, H) => {
        const V = () => {
            if (N.isMounted) {
                let {
                    next: he,
                    bu: re,
                    u: de,
                    parent: ge,
                    vnode: ce
                } = N; {
                    const Pe = Gy(N);
                    if (Pe) {
                        he && (he.el = ce.el, F(N, he, H)), Pe.asyncDep.then(() => {
                            N.isUnmounted || V()
                        });
                        return
                    }
                }
                let me = he,
                    xe;
                ko(N, !1), he ? (he.el = ce.el, F(N, he, H)) : he = ce, re && tp(re), (xe = he.props && he.props.onVnodeBeforeUpdate) && Is(xe, ge, he, ce), ko(N, !0);
                const ve = np(N),
                    we = N.subTree;
                N.subTree = ve, g(we, ve, d(we.el), fe(we), N, M, I), he.el = ve.el, me === null && BM(N, ve.el), de && _n(de, M), (xe = he.props && he.props.onVnodeUpdated) && _n(() => Is(xe, ge, he, ce), M)
            } else {
                let he;
                const {
                    el: re,
                    props: de
                } = G, {
                    bm: ge,
                    m: ce,
                    parent: me
                } = N, xe = zc(G);
                if (ko(N, !1), ge && tp(ge), !xe && (he = de && de.onVnodeBeforeMount) && Is(he, me, G), ko(N, !0), re && ke) {
                    const ve = () => {
                        N.subTree = np(N), ke(re, N.subTree, N, M, null)
                    };
                    xe ? G.type.__asyncLoader().then(() => !N.isUnmounted && ve()) : ve()
                } else {
                    const ve = N.subTree = np(N);
                    g(null, ve, Y, se, N, M, I), G.el = ve.el
                }
                if (ce && _n(ce, M), !xe && (he = de && de.onVnodeMounted)) {
                    const ve = G;
                    _n(() => Is(he, me, ve), M)
                } (G.shapeFlag & 256 || me && zc(me.vnode) && me.vnode.shapeFlag & 256) && N.a && _n(N.a, M), N.isMounted = !0, G = Y = se = null
            }
        },
            j = N.effect = new gA(V, ss, () => CA(q), N.scope),
            q = N.update = () => {
                j.dirty && j.run()
            };
        q.id = N.uid, ko(N, !0), q()
    }, F = (N, G, Y) => {
        G.component = N;
        const se = N.vnode.props;
        N.vnode = G, N.next = null, cT(N, G.props, se, Y), hT(N, G.children, Y), So(), W0(N), Mo()
    }, L = (N, G, Y, se, M, I, H, V, j = !1) => {
        const q = N && N.children,
            he = N ? N.shapeFlag : 0,
            re = G.children,
            {
                patchFlag: de,
                shapeFlag: ge
            } = G;
        if (de > 0) {
            if (de & 128) {
                k(q, re, Y, se, M, I, H, V, j);
                return
            } else if (de & 256) {
                W(q, re, Y, se, M, I, H, V, j);
                return
            }
        }
        ge & 8 ? (he & 16 && ue(q, M, I), re !== q && u(Y, re)) : he & 16 ? ge & 16 ? k(q, re, Y, se, M, I, H, V, j) : ue(q, M, I, !0) : (he & 8 && u(Y, ""), ge & 16 && S(re, Y, se, M, I, H, V, j))
    }, W = (N, G, Y, se, M, I, H, V, j) => {
        N = N || xl, G = G || xl;
        const q = N.length,
            he = G.length,
            re = Math.min(q, he);
        let de;
        for (de = 0; de < re; de++) {
            const ge = G[de] = j ? Wr(G[de]) : Ps(G[de]);
            g(N[de], ge, Y, null, M, I, H, V, j)
        }
        q > he ? ue(N, M, I, !0, !1, re) : S(G, Y, se, M, I, H, V, j, re)
    }, k = (N, G, Y, se, M, I, H, V, j) => {
        let q = 0;
        const he = G.length;
        let re = N.length - 1,
            de = he - 1;
        for (; q <= re && q <= de;) {
            const ge = N[q],
                ce = G[q] = j ? Wr(G[q]) : Ps(G[q]);
            if (ea(ge, ce)) g(ge, ce, Y, null, M, I, H, V, j);
            else break;
            q++
        }
        for (; q <= re && q <= de;) {
            const ge = N[re],
                ce = G[de] = j ? Wr(G[de]) : Ps(G[de]);
            if (ea(ge, ce)) g(ge, ce, Y, null, M, I, H, V, j);
            else break;
            re--, de--
        }
        if (q > re) {
            if (q <= de) {
                const ge = de + 1,
                    ce = ge < he ? G[ge].el : se;
                for (; q <= de;) g(null, G[q] = j ? Wr(G[q]) : Ps(G[q]), Y, ce, M, I, H, V, j), q++
            }
        } else if (q > de)
            for (; q <= re;) X(N[q], M, I, !0), q++;
        else {
            const ge = q,
                ce = q,
                me = new Map;
            for (q = ce; q <= de; q++) {
                const We = G[q] = j ? Wr(G[q]) : Ps(G[q]);
                We.key != null && me.set(We.key, q)
            }
            let xe, ve = 0;
            const we = de - ce + 1;
            let Pe = !1,
                Ke = 0;
            const Ve = new Array(we);
            for (q = 0; q < we; q++) Ve[q] = 0;
            for (q = ge; q <= re; q++) {
                const We = N[q];
                if (ve >= we) {
                    X(We, M, I, !0);
                    continue
                }
                let Te;
                if (We.key != null) Te = me.get(We.key);
                else
                    for (xe = ce; xe <= de; xe++)
                        if (Ve[xe - ce] === 0 && ea(We, G[xe])) {
                            Te = xe;
                            break
                        }
                Te === void 0 ? X(We, M, I, !0) : (Ve[Te - ce] = q + 1, Te >= Ke ? Ke = Te : Pe = !0, g(We, G[Te], Y, null, M, I, H, V, j), ve++)
            }
            const Le = Pe ? gT(Ve) : xl;
            for (xe = Le.length - 1, q = we - 1; q >= 0; q--) {
                const We = ce + q,
                    Te = G[We],
                    B = We + 1 < he ? G[We + 1].el : se;
                Ve[q] === 0 ? g(null, Te, Y, B, M, I, H, V, j) : Pe && (xe < 0 || q !== Le[xe] ? $(Te, Y, B, 2) : xe--)
            }
        }
    }, $ = (N, G, Y, se, M = null) => {
        const {
            el: I,
            type: H,
            transition: V,
            children: j,
            shapeFlag: q
        } = N;
        if (q & 6) {
            $(N.component.subTree, G, Y, se);
            return
        }
        if (q & 128) {
            N.suspense.move(G, Y, se);
            return
        }
        if (q & 64) {
            H.move(N, G, Y, Ce);
            return
        }
        if (H === Bt) {
            i(I, G, Y);
            for (let re = 0; re < j.length; re++) $(j[re], G, Y, se);
            i(N.anchor, G, Y);
            return
        }
        if (H === fh) {
            _(N, G, Y);
            return
        }
        if (se !== 2 && q & 1 && V)
            if (se === 0) V.beforeEnter(I), i(I, G, Y), _n(() => V.enter(I), M);
            else {
                const {
                    leave: re,
                    delayLeave: de,
                    afterLeave: ge
                } = V, ce = () => i(I, G, Y), me = () => {
                    re(I, () => {
                        ce(), ge && ge()
                    })
                };
                de ? de(I, ce, me) : me()
            }
        else i(I, G, Y)
    }, X = (N, G, Y, se = !1, M = !1) => {
        const {
            type: I,
            props: H,
            ref: V,
            children: j,
            dynamicChildren: q,
            shapeFlag: he,
            patchFlag: re,
            dirs: de
        } = N;
        if (V != null && $m(V, null, Y, N, !0), he & 256) {
            G.ctx.deactivate(N);
            return
        }
        const ge = he & 1 && de,
            ce = !zc(N);
        let me;
        if (ce && (me = H && H.onVnodeBeforeUnmount) && Is(me, G, N), he & 6) te(N.component, Y, se);
        else {
            if (he & 128) {
                N.suspense.unmount(Y, se);
                return
            }
            ge && Lo(N, null, G, "beforeUnmount"), he & 64 ? N.type.remove(N, G, Y, M, Ce, se) : q && (I !== Bt || re > 0 && re & 64) ? ue(q, G, Y, !1, !0) : (I === Bt && re & 384 || !M && he & 16) && ue(j, G, Y), se && le(N)
        } (ce && (me = H && H.onVnodeUnmounted) || ge) && _n(() => {
            me && Is(me, G, N), ge && Lo(N, null, G, "unmounted")
        }, Y)
    }, le = N => {
        const {
            type: G,
            el: Y,
            anchor: se,
            transition: M
        } = N;
        if (G === Bt) {
            K(Y, se);
            return
        }
        if (G === fh) {
            b(N);
            return
        }
        const I = () => {
            s(Y), M && !M.persisted && M.afterLeave && M.afterLeave()
        };
        if (N.shapeFlag & 1 && M && !M.persisted) {
            const {
                leave: H,
                delayLeave: V
            } = M, j = () => H(Y, I);
            V ? V(N.el, I, j) : j()
        } else I()
    }, K = (N, G) => {
        let Y;
        for (; N !== G;) Y = h(N), s(N), N = Y;
        s(G)
    }, te = (N, G, Y) => {
        const {
            bum: se,
            scope: M,
            update: I,
            subTree: H,
            um: V
        } = N;
        se && tp(se), M.stop(), I && (I.active = !1, X(H, N, G, Y)), V && _n(V, G), _n(() => {
            N.isUnmounted = !0
        }, G), G && G.pendingBranch && !G.isUnmounted && N.asyncDep && !N.asyncResolved && N.suspenseId === G.pendingId && (G.deps--, G.deps === 0 && G.resolve())
    }, ue = (N, G, Y, se = !1, M = !1, I = 0) => {
        for (let H = I; H < N.length; H++) X(N[H], G, Y, se, M)
    }, fe = N => N.shapeFlag & 6 ? fe(N.component.subTree) : N.shapeFlag & 128 ? N.suspense.next() : h(N.anchor || N.el);
    let Me = !1;
    const Be = (N, G, Y) => {
        N == null ? G._vnode && X(G._vnode, null, null, !0) : g(G._vnode || null, N, G, null, null, null, Y), Me || (Me = !0, W0(), Ay(), Me = !1), G._vnode = N
    },
        Ce = {
            p: g,
            um: X,
            m: $,
            r: le,
            mt: D,
            mc: S,
            pc: L,
            pbc: y,
            n: fe,
            o: n
        };
    let Z, ke;
    return e && ([Z, ke] = e(Ce)), {
        render: Be,
        hydrate: Z,
        createApp: rT(Be, Z)
    }
}

function op({
    type: n,
    props: e
}, t) {
    return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t
}

function ko({
    effect: n,
    update: e
}, t) {
    n.allowRecurse = e.allowRecurse = t
}

function mT(n, e) {
    return (!n || n && !n.pendingBranch) && e && !e.persisted
}

function zy(n, e, t = !1) {
    const i = n.children,
        s = e.children;
    if (Ze(i) && Ze(s))
        for (let r = 0; r < i.length; r++) {
            const o = i[r];
            let a = s[r];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[r] = Wr(s[r]), a.el = o.el), t || zy(o, a)), a.type === Pf && (a.el = o.el)
        }
}

function gT(n) {
    const e = n.slice(),
        t = [0];
    let i, s, r, o, a;
    const l = n.length;
    for (i = 0; i < l; i++) {
        const c = n[i];
        if (c !== 0) {
            if (s = t[t.length - 1], n[s] < c) {
                e[i] = s, t.push(i);
                continue
            }
            for (r = 0, o = t.length - 1; r < o;) a = r + o >> 1, n[t[a]] < c ? r = a + 1 : o = a;
            c < n[t[r]] && (r > 0 && (e[i] = t[r - 1]), t[r] = i)
        }
    }
    for (r = t.length, o = t[r - 1]; r-- > 0;) t[r] = o, o = e[o];
    return t
}

function Gy(n) {
    const e = n.subTree.component;
    if (e) return e.asyncDep && !e.asyncResolved ? e : Gy(e)
}
const AT = n => n.__isTeleport,
    Bt = Symbol.for("v-fgt"),
    Pf = Symbol.for("v-txt"),
    cs = Symbol.for("v-cmt"),
    fh = Symbol.for("v-stc"),
    Vc = [];
let xs = null;

function Ge(n = !1) {
    Vc.push(xs = n ? null : [])
}

function _T() {
    Vc.pop(), xs = Vc[Vc.length - 1] || null
}
let gu = 1;

function n_(n) {
    gu += n
}

function Hy(n) {
    return n.dynamicChildren = gu > 0 ? xs || xl : null, _T(), gu > 0 && xs && xs.push(n), n
}

function st(n, e, t, i, s, r) {
    return Hy(ie(n, e, t, i, s, r, !0))
}

function yn(n, e, t, i, s) {
    return Hy(gt(n, e, t, i, s, !0))
}

function Gh(n) {
    return n ? n.__v_isVNode === !0 : !1
}

function ea(n, e) {
    return n.type === e.type && n.key === e.key
}
const Vy = ({ key }) => key || null;

const ph = ({ ref, ref_key, ref_for }) => {
    if (typeof ref === "number") {
        ref = String(ref);
    }

    // Check if ref is valid
    if (ref != null) {
        if (mi(ref) || Ei(ref) || at(ref)) {
            return {
                i: Oi,
                r: ref,
                k: ref_key,
                f: !!ref_for
            };
        }
        return ref;
    }

    return null;
};

function ie(n, e = null, t = null, i = 0, s = null, r = n === Bt ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n,
        props: e,
        key: e && Vy(e),
        ref: e && ph(e),
        scopeId: by,
        slotScopeIds: null,
        children: t,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: r,
        patchFlag: i,
        dynamicProps: s,
        dynamicChildren: null,
        appContext: null,
        ctx: Oi
    };
    return a ? (TA(l, t), r & 128 && n.normalize(l)) : t && (l.shapeFlag |= mi(t) ? 8 : 16), gu > 0 && !o && xs && (l.patchFlag > 0 || r & 6) && l.patchFlag !== 32 && xs.push(l), l
}
const gt = vT;

function vT(n, e = null, t = null, i = 0, s = null, r = !1) {
    if ((!n || n === RM) && (n = cs), Gh(n)) {
        const a = vo(n, e, !0);
        return t && TA(a, t), gu > 0 && !r && xs && (a.shapeFlag & 6 ? xs[xs.indexOf(n)] = a : xs.push(a)), a.patchFlag |= -2, a
    }
    if (PT(n) && (n = n.__vccOpts), e) {
        e = bT(e);
        let {
            class: a,
            style: l
        } = e;
        a && !mi(a) && (e.class = xr(a)), Ut(l) && (cy(l) && !Ze(l) && (l = Di({}, l)), e.style = Cf(l))
    }
    const o = mi(n) ? 1 : DM(n) ? 128 : AT(n) ? 64 : Ut(n) ? 4 : at(n) ? 2 : 0;
    return ie(n, e, t, i, s, o, r, !0)
}

function bT(n) {
    return n ? cy(n) || ky(n) ? Di({}, n) : n : null
}

function vo(n, e, t = !1) {
    const {
        props: i,
        ref: s,
        patchFlag: r,
        children: o
    } = n, a = e ? yT(i || {}, e) : i;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n.type,
        props: a,
        key: a && Vy(a),
        ref: e && e.ref ? t && s ? Ze(s) ? s.concat(ph(e)) : [s, ph(e)] : ph(e) : s,
        scopeId: n.scopeId,
        slotScopeIds: n.slotScopeIds,
        children: o,
        target: n.target,
        targetAnchor: n.targetAnchor,
        staticCount: n.staticCount,
        shapeFlag: n.shapeFlag,
        patchFlag: e && n.type !== Bt ? r === -1 ? 16 : r | 16 : r,
        dynamicProps: n.dynamicProps,
        dynamicChildren: n.dynamicChildren,
        appContext: n.appContext,
        dirs: n.dirs,
        transition: n.transition,
        component: n.component,
        suspense: n.suspense,
        ssContent: n.ssContent && vo(n.ssContent),
        ssFallback: n.ssFallback && vo(n.ssFallback),
        el: n.el,
        anchor: n.anchor,
        ctx: n.ctx,
        ce: n.ce
    }
}

function bo(n = " ", e = 0) {
    return gt(Pf, null, n, e)
}

function xT(n, e) {
    const t = gt(fh, null, n);
    return t.staticCount = e, t
}

function Sc(n = "", e = !1) {
    return e ? (Ge(), yn(cs, null, n)) : gt(cs, null, n)
}

function Ps(n) {
    return n == null || typeof n == "boolean" ? gt(cs) : Ze(n) ? gt(Bt, null, n.slice()) : typeof n == "object" ? Wr(n) : gt(Pf, null, String(n))
}

function Wr(n) {
    return n.el === null && n.patchFlag !== -1 || n.memo ? n : vo(n)
}

function TA(n, e) {
    let t = 0;
    const {
        shapeFlag: i
    } = n;
    if (e == null) e = null;
    else if (Ze(e)) t = 16;
    else if (typeof e == "object")
        if (i & 65) {
            const s = e.default;
            s && (s._c && (s._d = !1), TA(n, s()), s._c && (s._d = !0));
            return
        } else {
            t = 32;
            const s = e._;
            !s && !ky(e) ? e._ctx = Oi : s === 3 && Oi && (Oi.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024))
        }
    else at(e) ? (e = {
        default: e,
        _ctx: Oi
    }, t = 32) : (e = String(e), i & 64 ? (t = 16, e = [bo(e)]) : t = 8);
    n.children = e, n.shapeFlag |= t
}

function yT(...n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = n[t];
        for (const s in i)
            if (s === "class") e.class !== i.class && (e.class = xr([e.class, i.class]));
            else if (s === "style") e.style = Cf([e.style, i.style]);
            else if (xf(s)) {
                const r = e[s],
                    o = i[s];
                o && r !== o && !(Ze(r) && r.includes(o)) && (e[s] = r ? [].concat(r, o) : o)
            } else s !== "" && (e[s] = i[s])
    }
    return e
}

function Is(n, e, t, i = null) {
    ls(n, e, 7, [t, i])
}
const ET = Dy();
let wT = 0;

function CT(n, e, t) {
    const i = n.type,
        s = (e ? e.appContext : n.appContext) || ET,
        r = {
            uid: wT++,
            vnode: n,
            type: i,
            parent: e,
            appContext: s,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new jx(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(s.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: Ny(i, s),
            emitsOptions: vy(i, s),
            emit: null,
            emitted: null,
            propsDefaults: Vt,
            inheritAttrs: i.inheritAttrs,
            ctx: Vt,
            data: Vt,
            props: Vt,
            attrs: Vt,
            slots: Vt,
            refs: Vt,
            setupState: Vt,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: t,
            suspenseId: t ? t.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return r.ctx = {
        _: r
    }, r.root = e ? e.root : r, r.emit = SM.bind(null, r), n.ce && n.ce(r), r
}
let Bi = null;
const ST = () => Bi || Oi;
let Hh, jm; {
    const n = Wx(),
        e = (t, i) => {
            let s;
            return (s = n[t]) || (s = n[t] = []), s.push(i), r => {
                s.length > 1 ? s.forEach(o => o(r)) : s[0](r)
            }
        };
    Hh = e("__VUE_INSTANCE_SETTERS__", t => Bi = t), jm = e("__VUE_SSR_SETTERS__", t => Df = t)
}
const zu = n => {
    const e = Bi;
    return Hh(n), n.scope.on(), () => {
        n.scope.off(), Hh(e)
    }
},
    s_ = () => {
        Bi && Bi.scope.off(), Hh(null)
    };

function Wy(n) {
    return n.vnode.shapeFlag & 4
}
let Df = !1;

function MT(n, e = !1) {
    e && jm(e);
    const {
        props: t,
        children: i
    } = n.vnode, s = Wy(n);
    lT(n, t, s, e), dT(n, i);
    const r = s ? TT(n, e) : void 0;
    return e && jm(!1), r
}

function TT(n, e) {
    const t = n.type;
    n.accessCache = Object.create(null), n.proxy = new Proxy(n.ctx, JM);
    const {
        setup: i
    } = t;
    if (i) {
        const s = n.setupContext = i.length > 1 ? BT(n) : null,
            r = zu(n);
        So();
        const o = fo(i, n, 0, [n.props, s]);
        if (Mo(), r(), zx(o)) {
            if (o.then(s_, s_), e) return o.then(a => {
                r_(n, a, e)
            }).catch(a => {
                Tf(a, n, 0)
            });
            n.asyncDep = o
        } else r_(n, o, e)
    } else qy(n, e)
}

function r_(n, e, t) {
    at(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : Ut(e) && (n.setupState = fy(e)), qy(n, t)
}
let o_;

function qy(n, e, t) {
    const i = n.type;
    if (!n.render) {
        if (!e && o_ && !i.render) {
            const s = i.template || SA(n).template;
            if (s) {
                const {
                    isCustomElement: r,
                    compilerOptions: o
                } = n.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = i, c = Di(Di({
                    isCustomElement: r,
                    delimiters: a
                }, o), l);
                i.render = o_(s, c)
            }
        }
        n.render = i.render || ss
    } {
        const s = zu(n);
        So();
        try {
            ZM(n)
        } finally {
            Mo(), s()
        }
    }
}
const IT = {
    get(n, e) {
        return Bn(n, "get", ""), n[e]
    }
};

function BT(n) {
    const e = t => {
        n.exposed = t || {}
    };
    return {
        attrs: new Proxy(n.attrs, IT),
        slots: n.slots,
        emit: n.emit,
        expose: e
    }
}

function IA(n) {
    if (n.exposed) return n.exposeProxy || (n.exposeProxy = new Proxy(fy(yA(n.exposed)), {
        get(e, t) {
            if (t in e) return e[t];
            if (t in Gc) return Gc[t](n)
        },
        has(e, t) {
            return t in e || t in Gc
        }
    }))
}

function RT(n, e = !0) {
    return at(n) ? n.displayName || n.name : n.name || e && n.__name
}

function PT(n) {
    return at(n) && "__vccOpts" in n
}
const $y = (n, e) => fM(n, e, Df);

function DT(n, e, t) {
    const i = arguments.length;
    return i === 2 ? Ut(e) && !Ze(e) ? Gh(e) ? gt(n, null, [e]) : gt(n, e) : gt(n, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && Gh(t) && (t = [t]), gt(n, e, t))
}
const LT = "3.4.23";
/**
 * @vue/runtime-dom v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const kT = "http://www.w3.org/2000/svg",
    FT = "http://www.w3.org/1998/Math/MathML",
    qr = typeof document < "u" ? document : null,
    a_ = qr && qr.createElement("template"),
    NT = {
        insert: (n, e, t) => {
            e.insertBefore(n, t || null)
        },
        remove: n => {
            const e = n.parentNode;
            e && e.removeChild(n)
        },
        createElement: (n, e, t, i) => {
            const s = e === "svg" ? qr.createElementNS(kT, n) : e === "mathml" ? qr.createElementNS(FT, n) : qr.createElement(n, t ? {
                is: t
            } : void 0);
            return n === "select" && i && i.multiple != null && s.setAttribute("multiple", i.multiple), s
        },
        createText: n => qr.createTextNode(n),
        createComment: n => qr.createComment(n),
        setText: (n, e) => {
            n.nodeValue = e
        },
        setElementText: (n, e) => {
            n.textContent = e
        },
        parentNode: n => n.parentNode,
        nextSibling: n => n.nextSibling,
        querySelector: n => qr.querySelector(n),
        setScopeId(n, e) {
            n.setAttribute(e, "")
        },
        insertStaticContent(n, e, t, i, s, r) {
            const o = t ? t.previousSibling : e.lastChild;
            if (s && (s === r || s.nextSibling))
                for (; e.insertBefore(s.cloneNode(!0), t), !(s === r || !(s = s.nextSibling)););
            else {
                a_.innerHTML = i === "svg" ? `<svg>${n}</svg>` : i === "mathml" ? `<math>${n}</math>` : n;
                const a = a_.content;
                if (i === "svg" || i === "mathml") {
                    const l = a.firstChild;
                    for (; l.firstChild;) a.appendChild(l.firstChild);
                    a.removeChild(l)
                }
                e.insertBefore(a, t)
            }
            return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
        }
    },
    Rr = "transition",
    lc = "animation",
    Au = Symbol("_vtc"),
    BA = (n, {
        slots: e
    }) => DT(QM, OT(n), e);
BA.displayName = "Transition";
const jy = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
BA.props = Di({}, wy, jy);
const Fo = (n, e = []) => {
    Ze(n) ? n.forEach(t => t(...e)) : n && n(...e)
},
    l_ = n => n ? Ze(n) ? n.some(e => e.length > 1) : n.length > 1 : !1;

function OT(n) {
    const e = {};
    for (const T in n) T in jy || (e[T] = n[T]);
    if (n.css === !1) return e;
    const {
        name: t = "v",
        type: i,
        duration: s,
        enterFromClass: r = `${t}-enter-from`,
        enterActiveClass: o = `${t}-enter-active`,
        enterToClass: a = `${t}-enter-to`,
        appearFromClass: l = r,
        appearActiveClass: c = o,
        appearToClass: u = a,
        leaveFromClass: d = `${t}-leave-from`,
        leaveActiveClass: h = `${t}-leave-active`,
        leaveToClass: f = `${t}-leave-to`
    } = n, m = UT(s), g = m && m[0], A = m && m[1], {
        onBeforeEnter: p,
        onEnter: v,
        onEnterCancelled: _,
        onLeave: b,
        onLeaveCancelled: w,
        onBeforeAppear: E = p,
        onAppear: C = v,
        onAppearCancelled: S = _
    } = e, x = (T, R, D) => {
        No(T, R ? u : a), No(T, R ? c : o), D && D()
    }, y = (T, R) => {
        T._isLeaving = !1, No(T, d), No(T, f), No(T, h), R && R()
    }, P = T => (R, D) => {
        const U = T ? C : v,
            Q = () => x(R, T, D);
        Fo(U, [R, Q]), c_(() => {
            No(R, T ? l : r), Pr(R, T ? u : a), l_(U) || u_(R, i, g, Q)
        })
    };
    return Di(e, {
        onBeforeEnter(T) {
            Fo(p, [T]), Pr(T, r), Pr(T, o)
        },
        onBeforeAppear(T) {
            Fo(E, [T]), Pr(T, l), Pr(T, c)
        },
        onEnter: P(!1),
        onAppear: P(!0),
        onLeave(T, R) {
            T._isLeaving = !0;
            const D = () => y(T, R);
            Pr(T, d), GT(), Pr(T, h), c_(() => {
                T._isLeaving && (No(T, d), Pr(T, f), l_(b) || u_(T, i, A, D))
            }), Fo(b, [T, D])
        },
        onEnterCancelled(T) {
            x(T, !1), Fo(_, [T])
        },
        onAppearCancelled(T) {
            x(T, !0), Fo(S, [T])
        },
        onLeaveCancelled(T) {
            y(T), Fo(w, [T])
        }
    })
}

function UT(n) {
    if (n == null) return null;
    if (Ut(n)) return [ap(n.enter), ap(n.leave)]; {
        const e = ap(n);
        return [e, e]
    }
}

function ap(n) {
    return NS(n)
}

function Pr(n, e) {
    e.split(/\s+/).forEach(t => t && n.classList.add(t)), (n[Au] || (n[Au] = new Set)).add(e)
}

function No(n, e) {
    e.split(/\s+/).forEach(i => i && n.classList.remove(i));
    const t = n[Au];
    t && (t.delete(e), t.size || (n[Au] = void 0))
}

function c_(n) {
    requestAnimationFrame(() => {
        requestAnimationFrame(n)
    })
}
let QT = 0;

function u_(n, e, t, i) {
    const s = n._endId = ++QT,
        r = () => {
            s === n._endId && i()
        };
    if (t) return setTimeout(r, t);
    const {
        type: o,
        timeout: a,
        propCount: l
    } = zT(n, e);
    if (!o) return i();
    const c = o + "end";
    let u = 0;
    const d = () => {
        n.removeEventListener(c, h), r()
    },
        h = f => {
            f.target === n && ++u >= l && d()
        };
    setTimeout(() => {
        u < l && d()
    }, a + 1), n.addEventListener(c, h)
}

function zT(n, e) {
    const t = window.getComputedStyle(n),
        i = m => (t[m] || "").split(", "),
        s = i(`${Rr}Delay`),
        r = i(`${Rr}Duration`),
        o = d_(s, r),
        a = i(`${lc}Delay`),
        l = i(`${lc}Duration`),
        c = d_(a, l);
    let u = null,
        d = 0,
        h = 0;
    e === Rr ? o > 0 && (u = Rr, d = o, h = r.length) : e === lc ? c > 0 && (u = lc, d = c, h = l.length) : (d = Math.max(o, c), u = d > 0 ? o > c ? Rr : lc : null, h = u ? u === Rr ? r.length : l.length : 0);
    const f = u === Rr && /\b(transform|all)(,|$)/.test(i(`${Rr}Property`).toString());
    return {
        type: u,
        timeout: d,
        propCount: h,
        hasTransform: f
    }
}

function d_(n, e) {
    for (; n.length < e.length;) n = n.concat(n);
    return Math.max(...e.map((t, i) => h_(t) + h_(n[i])))
}

function h_(n) {
    return n === "auto" ? 0 : Number(n.slice(0, -1).replace(",", ".")) * 1e3
}

function GT() {
    return document.body.offsetHeight
}

function HT(n, e, t) {
    const i = n[Au];
    i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e
}
const f_ = Symbol("_vod"),
    VT = Symbol("_vsh"),
    WT = Symbol(""),
    qT = /(^|;)\s*display\s*:/;

function $T(n, e, t) {
    const i = n.style,
        s = mi(t);
    let r = !1;
    if (t && !s) {
        if (e)
            if (mi(e))
                for (const o of e.split(";")) {
                    const a = o.slice(0, o.indexOf(":")).trim();
                    t[a] == null && mh(i, a, "")
                } else
                for (const o in e) t[o] == null && mh(i, o, "");
        for (const o in t) o === "display" && (r = !0), mh(i, o, t[o])
    } else if (s) {
        if (e !== t) {
            const o = i[WT];
            o && (t += ";" + o), i.cssText = t, r = qT.test(t)
        }
    } else e && n.removeAttribute("style");
    f_ in n && (n[f_] = r ? i.display : "", n[VT] && (i.display = "none"))
}
const p_ = /\s*!important$/;

function mh(n, e, t) {
    if (Ze(t)) t.forEach(i => mh(n, e, i));
    else if (t == null && (t = ""), e.startsWith("--")) n.setProperty(e, t);
    else {
        const i = jT(n, e);
        p_.test(t) ? n.setProperty(ec(i), t.replace(p_, ""), "important") : n[i] = t
    }
}
const m_ = ["Webkit", "Moz", "ms"],
    lp = {};

function jT(n, e) {
    const t = lp[e];
    if (t) return t;
    let i = Ws(e);
    if (i !== "filter" && i in n) return lp[e] = i;
    i = wf(i);
    for (let s = 0; s < m_.length; s++) {
        const r = m_[s] + i;
        if (r in n) return lp[e] = r
    }
    return e
}
const g_ = "http://www.w3.org/1999/xlink";

function YT(n, e, t, i, s) {
    if (i && e.startsWith("xlink:")) t == null ? n.removeAttributeNS(g_, e.slice(6, e.length)) : n.setAttributeNS(g_, e, t);
    else {
        const r = HS(e);
        t == null || r && !qx(t) ? n.removeAttribute(e) : n.setAttribute(e, r ? "" : t)
    }
}

function XT(element, attribute, value, callback, arg1, arg2, options) {
    if (attribute === "innerHTML" || attribute === "textContent") {
        if (callback) callback(value, arg1, arg2);
        element[attribute] = value || "";
        return;
    }

    const tagName = element.tagName;
    if (attribute === "value" && tagName !== "PROGRESS" && !tagName.includes("-")) {
        const currentValue = tagName === "OPTION" ? element.getAttribute("value") || "" : element.value;
        const newValue = value || "";
        if (currentValue !== newValue || !("_value" in element)) {
            element.value = newValue;
        }
        if (value == null) {
            element.removeAttribute(attribute);
        }
        element._value = value;
        return;
    }

    let shouldRemoveAttribute = false;
    if (value === "" || value == null) {
        const type = typeof element[attribute];
        if (type === "boolean") {
            value = qx(value);
        } else if (value == null && type === "string") {
            value = "";
            shouldRemoveAttribute = true;
        } else if (type === "number") {
            value = 0;
            shouldRemoveAttribute = true;
        }
    }

    try {
        element[attribute] = value;
    } catch (error) {
        console.error(`Failed to set property ${attribute} on element:`, error);
    }

    if (shouldRemoveAttribute) {
        element.removeAttribute(attribute);
    }
}

function KT(n, e, t, i) {
    n.addEventListener(e, t, i)
}

function JT(n, e, t, i) {
    n.removeEventListener(e, t, i)
}
const A_ = Symbol("_vei");

function ZT(n, e, t, i, s = null) {
    const r = n[A_] || (n[A_] = {}),
        o = r[e];
    if (i && o) o.value = i;
    else {
        const [a, l] = eI(e);
        if (i) {
            const c = r[e] = nI(i, s);
            KT(n, a, c, l)
        } else o && (JT(n, a, o, l), r[e] = void 0)
    }
}
const __ = /(?:Once|Passive|Capture)$/;

function eI(n) {
    let e;
    if (__.test(n)) {
        e = {};
        let i;
        for (; i = n.match(__);) n = n.slice(0, n.length - i[0].length), e[i[0].toLowerCase()] = !0
    }
    return [n[2] === ":" ? n.slice(3) : ec(n.slice(2)), e]
}
let cp = 0;
const tI = Promise.resolve(),
    iI = () => cp || (tI.then(() => cp = 0), cp = Date.now());

function nI(n, e) {
    const t = i => {
        if (!i._vts) i._vts = Date.now();
        else if (i._vts <= t.attached) return;
        ls(sI(i, t.value), e, 5, [i])
    };
    return t.value = n, t.attached = iI(), t
}

function sI(n, e) {
    if (Ze(e)) {
        const t = n.stopImmediatePropagation;
        return n.stopImmediatePropagation = () => {
            t.call(n), n._stopped = !0
        }, e.map(i => s => !s._stopped && i && i(s))
    } else return e
}
const v_ = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123,
    rI = (n, e, t, i, s, r, o, a, l) => {
        const c = s === "svg";
        e === "class" ? HT(n, i, c) : e === "style" ? $T(n, t, i) : xf(e) ? fA(e) || ZT(n, e, t, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : oI(n, e, i, c)) ? XT(n, e, i, r, o, a, l) : (e === "true-value" ? n._trueValue = i : e === "false-value" && (n._falseValue = i), YT(n, e, i, c))
    };

function oI(n, e, t, i) {
    if (i) return !!(e === "innerHTML" || e === "textContent" || e in n && v_(e) && at(t));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA") return !1;
    if (e === "width" || e === "height") {
        const s = n.tagName;
        if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE") return !1
    }
    return v_(e) && mi(t) ? !1 : e in n
}
const aI = ["ctrl", "shift", "alt", "meta"],
    lI = {
        stop: n => n.stopPropagation(),
        prevent: n => n.preventDefault(),
        self: n => n.target !== n.currentTarget,
        ctrl: n => !n.ctrlKey,
        shift: n => !n.shiftKey,
        alt: n => !n.altKey,
        meta: n => !n.metaKey,
        left: n => "button" in n && n.button !== 0,
        middle: n => "button" in n && n.button !== 1,
        right: n => "button" in n && n.button !== 2,
        exact: (n, e) => aI.some(t => n[`${t}Key`] && !e.includes(t))
    },
    cI = (n, e) => {
        const t = n._withMods || (n._withMods = {}),
            i = e.join(".");
        return t[i] || (t[i] = (s, ...r) => {
            for (let o = 0; o < e.length; o++) {
                const a = lI[e[o]];
                if (a && a(s, e)) return
            }
            return n(s, ...r)
        })
    },
    uI = Di({
        patchProp: rI
    }, NT);
let b_;

function dI() {
    return b_ || (b_ = fT(uI))
}
const hI = (...n) => {
    const e = dI().createApp(...n),
        {
            mount: t
        } = e;
    return e.mount = i => {
        const s = pI(i);
        if (!s) return;
        const r = e._component;
        !at(r) && !r.render && !r.template && (r.template = s.innerHTML), s.innerHTML = "";
        const o = t(s, !1, fI(s));
        return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), o
    }, e
};

function fI(n) {
    if (n instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && n instanceof MathMLElement) return "mathml"
}

function pI(n) {
    return mi(n) ? document.querySelector(n) : n
}
var mI = !1;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let Yy;
const Lf = n => Yy = n,
    Xy = Symbol();

function Ym(n) {
    return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function"
}
var Wc;
(function (n) {
    n.direct = "direct", n.patchObject = "patch object", n.patchFunction = "patch function"
})(Wc || (Wc = {}));

function gI() {
    const n = Yx(!0),
        e = n.run(() => hy({}));
    let t = [],
        i = [];
    const s = yA({
        install(r) {
            Lf(s), s._a = r, r.provide(Xy, s), r.config.globalProperties.$pinia = s, i.forEach(o => t.push(o)), i = []
        },
        use(r) {
            return !this._a && !mI ? i.push(r) : t.push(r), this
        },
        _p: t,
        _a: null,
        _e: n,
        _s: new Map,
        state: e
    });
    return s
}
const Ky = () => { };

function x_(n, e, t, i = Ky) {
    n.push(e);
    const s = () => {
        const r = n.indexOf(e);
        r > -1 && (n.splice(r, 1), i())
    };
    return !t && Xx() && WS(s), s
}

function Pa(n, ...e) {
    n.slice().forEach(t => {
        t(...e)
    })
}
const AI = n => n();

function Xm(n, e) {
    n instanceof Map && e instanceof Map && e.forEach((t, i) => n.set(i, t)), n instanceof Set && e instanceof Set && e.forEach(n.add, n);
    for (const t in e) {
        if (!e.hasOwnProperty(t)) continue;
        const i = e[t],
            s = n[t];
        Ym(s) && Ym(i) && n.hasOwnProperty(t) && !Ei(i) && !ca(i) ? n[t] = Xm(s, i) : n[t] = i
    }
    return n
}
const _I = Symbol();

function vI(n) {
    return !Ym(n) || !n.hasOwnProperty(_I)
}
const {
    assign: Qr
} = Object;

function bI(n) {
    return !!(Ei(n) && n.effect)
}

function xI(n, e, t, i) {
    const {
        state: s,
        actions: r,
        getters: o
    } = e, a = t.state.value[n];
    let l;

    function c() {
        a || (t.state.value[n] = s ? s() : {});
        const u = _M(t.state.value[n]);
        return Qr(u, r, Object.keys(o || {}).reduce((d, h) => (d[h] = yA($y(() => {
            Lf(t);
            const f = t._s.get(n);
            return o[h].call(f, f)
        })), d), {}))
    }
    return l = Jy(n, c, e, t, i, !0), l
}

function Jy(n, e, t = {}, i, s, r) {
    let o;
    const a = Qr({
        actions: {}
    }, t),
        l = {
            deep: !0
        };
    let c, u, d = [],
        h = [],
        f;
    const m = i.state.value[n];
    !r && !m && (i.state.value[n] = {}), hy({});
    let g;

    function A(S) {
        let x;
        c = u = !1, typeof S == "function" ? (S(i.state.value[n]), x = {
            type: Wc.patchFunction,
            storeId: n,
            events: f
        }) : (Xm(i.state.value[n], S), x = {
            type: Wc.patchObject,
            payload: S,
            storeId: n,
            events: f
        });
        const y = g = Symbol();
        my().then(() => {
            g === y && (c = !0)
        }), u = !0, Pa(d, x, i.state.value[n])
    }
    const p = r ? function () {
        const {
            state: x
        } = t, y = x ? x() : {};
        this.$patch(P => {
            Qr(P, y)
        })
    } : Ky;

    function v() {
        o.stop(), d = [], h = [], i._s.delete(n)
    }

    function _(S, x) {
        return function () {
            Lf(i);
            const y = Array.from(arguments),
                P = [],
                T = [];

            function R(Q) {
                P.push(Q)
            }

            function D(Q) {
                T.push(Q)
            }
            Pa(h, {
                args: y,
                name: S,
                store: w,
                after: R,
                onError: D
            });
            let U;
            try {
                U = x.apply(this && this.$id === n ? this : w, y)
            } catch (Q) {
                throw Pa(T, Q), Q
            }
            return U instanceof Promise ? U.then(Q => (Pa(P, Q), Q)).catch(Q => (Pa(T, Q), Promise.reject(Q))) : (Pa(P, U), U)
        }
    }
    const b = {
        _p: i,
        $id: n,
        $onAction: x_.bind(null, h),
        $patch: A,
        $reset: p,
        $subscribe(S, x = {}) {
            const y = x_(d, S, x.detached, () => P()),
                P = o.run(() => hh(() => i.state.value[n], T => {
                    (x.flush === "sync" ? u : c) && S({
                        storeId: n,
                        type: Wc.direct,
                        events: f
                    }, T)
                }, Qr({}, l, x)));
            return y
        },
        $dispose: v
    },
        w = Mf(b);
    i._s.set(n, w);
    const C = (i._a && i._a.runWithContext || AI)(() => i._e.run(() => (o = Yx()).run(e)));
    for (const S in C) {
        const x = C[S];
        if (Ei(x) && !bI(x) || ca(x)) r || (m && vI(x) && (Ei(x) ? x.value = m[S] : Xm(x, m[S])), i.state.value[n][S] = x);
        else if (typeof x == "function") {
            const y = _(S, x);
            C[S] = y, a.actions[S] = x
        }
    }
    return Qr(w, C), Qr(At(w), C), Object.defineProperty(w, "$state", {
        get: () => i.state.value[n],
        set: S => {
            A(x => {
                Qr(x, S)
            })
        }
    }), i._p.forEach(S => {
        Qr(w, o.run(() => S({
            store: w,
            app: i._a,
            pinia: i,
            options: a
        })))
    }), m && r && t.hydrate && t.hydrate(w.$state, m), c = !0, u = !0, w
}

function yI(n, e, t) {
    let i, s;
    const r = typeof e == "function";
    typeof n == "string" ? (i = n, s = r ? t : e) : (s = n, i = n.id);

    function o(a, l) {
        const c = aT();
        return a = a || (c ? Hc(Xy, null) : null), a && Lf(a), a = Yy, a._s.has(i) || (r ? Jy(i, e, s, a) : xI(i, s, a)), a._s.get(i)
    }
    return o.$id = i, o
}

function fs(n, e) {
    return Array.isArray(e) ? e.reduce((t, i) => (t[i] = function () {
        return n(this.$pinia)[i]
    }, t), {}) : Object.keys(e).reduce((t, i) => (t[i] = function () {
        const s = n(this.$pinia),
            r = e[i];
        return typeof r == "function" ? r.call(this, s) : s[r]
    }, t), {})
}

function RA(n, e) {
    return Array.isArray(e) ? e.reduce((t, i) => (t[i] = function (...s) {
        return n(this.$pinia)[i](...s)
    }, t), {}) : Object.keys(e).reduce((t, i) => (t[i] = function (...s) {
        return n(this.$pinia)[e[i]](...s)
    }, t), {})
}
const gn = yI("app", {
    state: () => ({
        breakpoints: {},
        activeBreakpoint: "xxl",
        preloaderIsShown: !0,
        currentSectionId: ""
    }),
    actions: {
        setBreakpoint(n, e) {
            this.breakpoints[n] = e
        },
        setActiveBreakpoint(n) {
            this.activeBreakpoint = n
        },
        hidePreloader() {
            this.preloaderIsShown = !1
        },
        setCurrentSectionId(n) {
            this.currentSectionId = n
        }
    }
}),
    EI = [{
        title: "Interstellar Roadmap",
        sectionId: "roadmap"
    }, {
        title: "Chains",
        sectionId: "chains"
    }, {
        title: "Diamond Hands",
        sectionId: "diamond-hands"
    }, {
        title: "Token Specifics",
        sectionId: "token-specifics"
    }],
    wI = [{
        title: "Hero",
        sectionId: "hero"
    }, {
        title: "Why We",
        sectionId: "why-we"
    }, {
        title: "Interstellar Roadmap",
        sectionId: "roadmap"
    }, {
        title: "Chains",
        sectionId: "chains"
    }, {
        title: "Diamond Hands",
        sectionId: "diamond-hands"
    }, {
        title: "Token Specifics",
        sectionId: "token-specifics"
    }, {
        title: "Collection Gallery",
        sectionId: "collection-gallery"
    }, {
        title: "Collection",
        sectionId: "collection"
    }, {
        title: "FAQ",
        sectionId: "faq"
    }],
    y_ = {
        menu: EI,
        pagination_list: wI
    },
    Zy = [{
        title: "Twitter",
        url: "https://twitter.com/AnyInuCoin",
        icon: "/images/icons/icon-x.svg"
    }, {
        title: "Telegram",
        url: "https://t.me/anyinuportal",
        icon: "/images/icons/icon-telegram.svg"
    }, {
        title: "Discord",
        url: "https://discord.com/invite/3UtR7th3kh",
        icon: "/images/icons/icon-discord.svg"
    }, {
        title: "Coin Market Cap",
        url: "https://coinmarketcap.com/currencies/any-inu/",
        icon: "/images/icons/icon-coinmarketcap.svg"
    }, {
        title: "Coin Gecko",
        url: "https://www.coingecko.com/en/coins/any-inu",
        icon: "/images/icons/icon-coingecko.svg"
    }, {
        title: "DEX Screener",
        url: "https://dexscreener.com/watchlist/CVcE5PHryLwoIpfFZ5zT",
        icon: "/images/icons/icon-dexscreener.svg"
    }, {
        title: "Jupiter",
        url: "https://jup.ag/swap/SOL-AI_ACeWC77UeW2DBZMe7YBsuXoxLvk4dHMnPzneApau1Au6",
        icon: "/images/icons/icon-jupiter.svg"
    }];

function or(n) {
    if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return n
}

function eE(n, e) {
    n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Wn = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
},
    Nl = {
        duration: .5,
        overwrite: !1,
        delay: 0
    },
    PA, Ki, qt, rs = 1e8,
    kt = 1 / rs,
    Km = Math.PI * 2,
    CI = Km / 4,
    SI = 0,
    tE = Math.sqrt,
    MI = Math.cos,
    TI = Math.sin,
    Li = function (e) {
        return typeof e == "string"
    },
    Zt = function (e) {
        return typeof e == "function"
    },
    yr = function (e) {
        return typeof e == "number"
    },
    DA = function (e) {
        return typeof e > "u"
    },
    qs = function (e) {
        return typeof e == "object"
    },
    En = function (e) {
        return e !== !1
    },
    LA = function () {
        return typeof window < "u"
    },
    ad = function (e) {
        return Zt(e) || Li(e)
    },
    iE = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () { },
    Ji = Array.isArray,
    Jm = /(?:-?\.?\d|\.)+/gi,
    nE = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    ul = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    up = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    sE = /[+-]=-?[.\d]+/,
    rE = /[^,'"\[\]\s]+/gi,
    II = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    jt, Bs, Zm, kA, qn = {},
    Vh = {},
    oE, aE = function (e) {
        return (Vh = ba(e, qn)) && Rn
    },
    FA = function (e, t) {
        return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
    },
    _u = function (e, t) {
        return !t && console.warn(e)
    },
    lE = function (e, t) {
        return e && (qn[e] = t) && Vh && (Vh[e] = t) || qn
    },
    vu = function () {
        return 0
    },
    BI = {
        suppressEvents: !0,
        isStart: !0,
        kill: !1
    },
    gh = {
        suppressEvents: !0,
        kill: !1
    },
    RI = {
        suppressEvents: !0
    },
    NA = {},
    po = [],
    eg = {},
    cE, On = {},
    dp = {},
    E_ = 30,
    Ah = [],
    OA = "",
    UA = function (e) {
        var t = e[0],
            i, s;
        if (qs(t) || Zt(t) || (e = [e]), !(i = (t._gsap || {}).harness)) {
            for (s = Ah.length; s-- && !Ah[s].targetTest(t););
            i = Ah[s]
        }
        for (s = e.length; s--;) e[s] && (e[s]._gsap || (e[s]._gsap = new DE(e[s], i))) || e.splice(s, 1);
        return e
    },
    ua = function (e) {
        return e._gsap || UA(os(e))[0]._gsap
    },
    uE = function (e, t, i) {
        return (i = e[t]) && Zt(i) ? e[t]() : DA(i) && e.getAttribute && e.getAttribute(t) || i
    },
    wn = function (e, t) {
        return (e = e.split(",")).forEach(t) || e
    },
    si = function (e) {
        return Math.round(e * 1e5) / 1e5 || 0
    },
    Ii = function (e) {
        return Math.round(e * 1e7) / 1e7 || 0
    },
    Cl = function (e, t) {
        var i = t.charAt(0),
            s = parseFloat(t.substr(2));
        return e = parseFloat(e), i === "+" ? e + s : i === "-" ? e - s : i === "*" ? e * s : e / s
    },
    PI = function (e, t) {
        for (var i = t.length, s = 0; e.indexOf(t[s]) < 0 && ++s < i;);
        return s < i
    },
    Wh = function () {
        var e = po.length,
            t = po.slice(0),
            i, s;
        for (eg = {}, po.length = 0, i = 0; i < e; i++) s = t[i], s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0)
    },
    dE = function (e, t, i, s) {
        po.length && !Ki && Wh(), e.render(t, i, s || Ki && t < 0 && (e._initted || e._startAt)), po.length && !Ki && Wh()
    },
    hE = function (e) {
        var t = parseFloat(e);
        return (t || t === 0) && (e + "").match(rE).length < 2 ? t : Li(e) ? e.trim() : e
    },
    fE = function (e) {
        return e
    },
    hs = function (e, t) {
        for (var i in t) i in e || (e[i] = t[i]);
        return e
    },
    DI = function (e) {
        return function (t, i) {
            for (var s in i) s in t || s === "duration" && e || s === "ease" || (t[s] = i[s])
        }
    },
    ba = function (e, t) {
        for (var i in t) e[i] = t[i];
        return e
    },
    w_ = function n(e, t) {
        for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = qs(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
        return e
    },
    qh = function (e, t) {
        var i = {},
            s;
        for (s in e) s in t || (i[s] = e[s]);
        return i
    },
    qc = function (e) {
        var t = e.parent || jt,
            i = e.keyframes ? DI(Ji(e.keyframes)) : hs;
        if (En(e.inherit))
            for (; t;) i(e, t.vars.defaults), t = t.parent || t._dp;
        return e
    },
    LI = function (e, t) {
        for (var i = e.length, s = i === t.length; s && i-- && e[i] === t[i];);
        return i < 0
    },
    pE = function (e, t, i, s, r) {
        i === void 0 && (i = "_first"), s === void 0 && (s = "_last");
        var o = e[s],
            a;
        if (r)
            for (a = t[r]; o && o[r] > a;) o = o._prev;
        return o ? (t._next = o._next, o._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[s] = t, t._prev = o, t.parent = t._dp = e, t
    },
    kf = function (e, t, i, s) {
        i === void 0 && (i = "_first"), s === void 0 && (s = "_last");
        var r = t._prev,
            o = t._next;
        r ? r._next = o : e[i] === t && (e[i] = o), o ? o._prev = r : e[s] === t && (e[s] = r), t._next = t._prev = t.parent = null
    },
    xo = function (e, t) {
        e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
    },
    da = function (e, t) {
        if (e && (!t || t._end > e._dur || t._start < 0))
            for (var i = e; i;) i._dirty = 1, i = i.parent;
        return e
    },
    kI = function (e) {
        for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
        return e
    },
    tg = function (e, t, i, s) {
        return e._startAt && (Ki ? e._startAt.revert(gh) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, s))
    },
    FI = function n(e) {
        return !e || e._ts && n(e.parent)
    },
    C_ = function (e) {
        return e._repeat ? Ol(e._tTime, e = e.duration() + e._rDelay) * e : 0
    },
    Ol = function (e, t) {
        var i = Math.floor(e /= t);
        return e && i === e ? i - 1 : i
    },
    $h = function (e, t) {
        return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    },
    Ff = function (e) {
        return e._end = Ii(e._start + (e._tDur / Math.abs(e._ts || e._rts || kt) || 0))
    },
    Nf = function (e, t) {
        var i = e._dp;
        return i && i.smoothChildTiming && e._ts && (e._start = Ii(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Ff(e), i._dirty || da(i, e)), e
    },
    mE = function (e, t) {
        var i;
        if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = $h(e.rawTime(), t), (!t._dur || Gu(0, t.totalDuration(), i) - t._tTime > kt) && t.render(i, !0)), da(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
            if (e._dur < e.duration())
                for (i = e; i._dp;) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
            e._zTime = -kt
        }
    },
    ks = function (e, t, i, s) {
        return t.parent && xo(t), t._start = Ii((yr(i) ? i : i || e !== jt ? Jn(e, i, t) : e._time) + t._delay), t._end = Ii(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), pE(e, t, "_first", "_last", e._sort ? "_start" : 0), ig(t) || (e._recent = t), s || mE(e, t), e._ts < 0 && Nf(e, e._tTime), e
    },
    gE = function (e, t) {
        return (qn.ScrollTrigger || FA("scrollTrigger", t)) && qn.ScrollTrigger.create(t, e)
    },
    AE = function (e, t, i, s, r) {
        if (zA(e, t, r), !e._initted) return 1;
        if (!i && e._pt && !Ki && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && cE !== Qn.frame) return po.push(e), e._lazy = [r, s], 1
    },
    NI = function n(e) {
        var t = e.parent;
        return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t))
    },
    ig = function (e) {
        var t = e.data;
        return t === "isFromStart" || t === "isStart"
    },
    OI = function (e, t, i, s) {
        var r = e.ratio,
            o = t < 0 || !t && (!e._start && NI(e) && !(!e._initted && ig(e)) || (e._ts < 0 || e._dp._ts < 0) && !ig(e)) ? 0 : 1,
            a = e._rDelay,
            l = 0,
            c, u, d;
        if (a && e._repeat && (l = Gu(0, e._tDur, t), u = Ol(l, a), e._yoyo && u & 1 && (o = 1 - o), u !== Ol(e._tTime, a) && (r = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== r || Ki || s || e._zTime === kt || !t && e._zTime) {
            if (!e._initted && AE(e, t, s, i, l)) return;
            for (d = e._zTime, e._zTime = t || (i ? kt : 0), i || (i = t && !d), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, c = e._pt; c;) c.r(o, c.d), c = c._next;
            t < 0 && tg(e, t, i, !0), e._onUpdate && !i && Gn(e, "onUpdate"), l && e._repeat && !i && e.parent && Gn(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && xo(e, 1), !i && !Ki && (Gn(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
        } else e._zTime || (e._zTime = t)
    },
    UI = function (e, t, i) {
        var s;
        if (i > t)
            for (s = e._first; s && s._start <= i;) {
                if (s.data === "isPause" && s._start > t) return s;
                s = s._next
            } else
            for (s = e._last; s && s._start >= i;) {
                if (s.data === "isPause" && s._start < t) return s;
                s = s._prev
            }
    },
    Ul = function (e, t, i, s) {
        var r = e._repeat,
            o = Ii(t) || 0,
            a = e._tTime / e._tDur;
        return a && !s && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : Ii(o * (r + 1) + e._rDelay * r) : o, a > 0 && !s && Nf(e, e._tTime = e._tDur * a), e.parent && Ff(e), i || da(e.parent, e), e
    },
    S_ = function (e) {
        return e instanceof un ? da(e) : Ul(e, e._dur)
    },
    QI = {
        _start: 0,
        endTime: vu,
        totalDuration: vu
    },
    Jn = function n(e, t, i) {
        var s = e.labels,
            r = e._recent || QI,
            o = e.duration() >= rs ? r.endTime(!1) : e._dur,
            a, l, c;
        return Li(t) && (isNaN(t) || t in s) ? (l = t.charAt(0), c = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? r : i).totalDuration() / 100 : 1)) : a < 0 ? (t in s || (s[t] = o), s[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), c && i && (l = l / 100 * (Ji(i) ? i[0] : i).totalDuration()), a > 1 ? n(e, t.substr(0, a - 1), i) + l : o + l)) : t == null ? o : +t
    },
    $c = function (e, t, i) {
        var s = yr(t[1]),
            r = (s ? 2 : 1) + (e < 2 ? 0 : 1),
            o = t[r],
            a, l;
        if (s && (o.duration = t[1]), o.parent = i, e) {
            for (a = o, l = i; l && !("immediateRender" in a);) a = l.vars.defaults || {}, l = En(l.vars.inherit) && l.parent;
            o.immediateRender = En(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[r - 1]
        }
        return new di(t[0], o, t[r + 1])
    },
    To = function (e, t) {
        return e || e === 0 ? t(e) : t
    },
    Gu = function (e, t, i) {
        return i < e ? e : i > t ? t : i
    },
    Xi = function (e, t) {
        return !Li(e) || !(t = II.exec(e)) ? "" : t[1]
    },
    zI = function (e, t, i) {
        return To(i, function (s) {
            return Gu(e, t, s)
        })
    },
    ng = [].slice,
    _E = function (e, t) {
        return e && qs(e) && "length" in e && (!t && !e.length || e.length - 1 in e && qs(e[0])) && !e.nodeType && e !== Bs
    },
    GI = function (e, t, i) {
        return i === void 0 && (i = []), e.forEach(function (s) {
            var r;
            return Li(s) && !t || _E(s, 1) ? (r = i).push.apply(r, os(s)) : i.push(s)
        }) || i
    },
    os = function (e, t, i) {
        return qt && !t && qt.selector ? qt.selector(e) : Li(e) && !i && (Zm || !Ql()) ? ng.call((t || kA).querySelectorAll(e), 0) : Ji(e) ? GI(e, i) : _E(e) ? ng.call(e, 0) : e ? [e] : []
    },
    sg = function (e) {
        return e = os(e)[0] || _u("Invalid scope") || {},
            function (t) {
                var i = e.current || e.nativeElement || e;
                return os(t, i.querySelectorAll ? i : i === e ? _u("Invalid scope") || kA.createElement("div") : e)
            }
    },
    vE = function (e) {
        return e.sort(function () {
            return .5 - Math.random()
        })
    },
    bE = function (e) {
        if (Zt(e)) return e;
        var t = qs(e) ? e : {
            each: e
        },
            i = ha(t.ease),
            s = t.from || 0,
            r = parseFloat(t.base) || 0,
            o = {},
            a = s > 0 && s < 1,
            l = isNaN(s) || a,
            c = t.axis,
            u = s,
            d = s;
        return Li(s) ? u = d = {
            center: .5,
            edges: .5,
            end: 1
        }[s] || 0 : !a && l && (u = s[0], d = s[1]),
            function (h, f, m) {
                var g = (m || t).length,
                    A = o[g],
                    p, v, _, b, w, E, C, S, x;
                if (!A) {
                    if (x = t.grid === "auto" ? 0 : (t.grid || [1, rs])[1], !x) {
                        for (C = -rs; C < (C = m[x++].getBoundingClientRect().left) && x < g;);
                        x < g && x--
                    }
                    for (A = o[g] = [], p = l ? Math.min(x, g) * u - .5 : s % x, v = x === rs ? 0 : l ? g * d / x - .5 : s / x | 0, C = 0, S = rs, E = 0; E < g; E++) _ = E % x - p, b = v - (E / x | 0), A[E] = w = c ? Math.abs(c === "y" ? b : _) : tE(_ * _ + b * b), w > C && (C = w), w < S && (S = w);
                    s === "random" && vE(A), A.max = C - S, A.min = S, A.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (x > g ? g - 1 : c ? c === "y" ? g / x : x : Math.max(x, g / x)) || 0) * (s === "edges" ? -1 : 1), A.b = g < 0 ? r - g : r, A.u = Xi(t.amount || t.each) || 0, i = i && g < 0 ? BE(i) : i
                }
                return g = (A[h] - A.min) / A.max || 0, Ii(A.b + (i ? i(g) : g) * A.v) + A.u
            }
    },
    rg = function (e) {
        var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
        return function (i) {
            var s = Ii(Math.round(parseFloat(i) / e) * e * t);
            return (s - s % 1) / t + (yr(i) ? 0 : Xi(i))
        }
    },
    xE = function (e, t) {
        var i = Ji(e),
            s, r;
        return !i && qs(e) && (s = i = e.radius || rs, e.values ? (e = os(e.values), (r = !yr(e[0])) && (s *= s)) : e = rg(e.increment)), To(t, i ? Zt(e) ? function (o) {
            return r = e(o), Math.abs(r - o) <= s ? r : o
        } : function (o) {
            for (var a = parseFloat(r ? o.x : o), l = parseFloat(r ? o.y : 0), c = rs, u = 0, d = e.length, h, f; d--;) r ? (h = e[d].x - a, f = e[d].y - l, h = h * h + f * f) : h = Math.abs(e[d] - a), h < c && (c = h, u = d);
            return u = !s || c <= s ? e[u] : o, r || u === o || yr(o) ? u : u + Xi(o)
        } : rg(e))
    },
    yE = function (e, t, i, s) {
        return To(Ji(e) ? !t : i === !0 ? !!(i = 0) : !s, function () {
            return Ji(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (s = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * .99)) / i) * i * s) / s
        })
    },
    HI = function () {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
        return function (s) {
            return t.reduce(function (r, o) {
                return o(r)
            }, s)
        }
    },
    VI = function (e, t) {
        return function (i) {
            return e(parseFloat(i)) + (t || Xi(i))
        }
    },
    WI = function (e, t, i) {
        return wE(e, t, 0, 1, i)
    },
    EE = function (e, t, i) {
        return To(i, function (s) {
            return e[~~t(s)]
        })
    },
    qI = function n(e, t, i) {
        var s = t - e;
        return Ji(e) ? EE(e, n(0, e.length), t) : To(i, function (r) {
            return (s + (r - e) % s) % s + e
        })
    },
    $I = function n(e, t, i) {
        var s = t - e,
            r = s * 2;
        return Ji(e) ? EE(e, n(0, e.length - 1), t) : To(i, function (o) {
            return o = (r + (o - e) % r) % r || 0, e + (o > s ? r - o : o)
        })
    },
    bu = function (e) {
        for (var t = 0, i = "", s, r, o, a; ~(s = e.indexOf("random(", t));) o = e.indexOf(")", s), a = e.charAt(s + 7) === "[", r = e.substr(s + 7, o - s - 7).match(a ? rE : Jm), i += e.substr(t, s - t) + yE(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5), t = o + 1;
        return i + e.substr(t, e.length - t)
    },
    wE = function (e, t, i, s, r) {
        var o = t - e,
            a = s - i;
        return To(r, function (l) {
            return i + ((l - e) / o * a || 0)
        })
    },
    jI = function n(e, t, i, s) {
        var r = isNaN(e + t) ? 0 : function (f) {
            return (1 - f) * e + f * t
        };
        if (!r) {
            var o = Li(e),
                a = {},
                l, c, u, d, h;
            if (i === !0 && (s = 1) && (i = null), o) e = {
                p: e
            }, t = {
                p: t
            };
            else if (Ji(e) && !Ji(t)) {
                for (u = [], d = e.length, h = d - 2, c = 1; c < d; c++) u.push(n(e[c - 1], e[c]));
                d--, r = function (m) {
                    m *= d;
                    var g = Math.min(h, ~~m);
                    return u[g](m - g)
                }, i = t
            } else s || (e = ba(Ji(e) ? [] : {}, e));
            if (!u) {
                for (l in t) QA.call(a, e, l, "get", t[l]);
                r = function (m) {
                    return VA(m, a) || (o ? e.p : e)
                }
            }
        }
        return To(i, r)
    },
    M_ = function (e, t, i) {
        var s = e.labels,
            r = rs,
            o, a, l;
        for (o in s) a = s[o] - t, a < 0 == !!i && a && r > (a = Math.abs(a)) && (l = o, r = a);
        return l
    },
    Gn = function (e, t, i) {
        var s = e.vars,
            r = s[t],
            o = qt,
            a = e._ctx,
            l, c, u;
        if (r) return l = s[t + "Params"], c = s.callbackScope || e, i && po.length && Wh(), a && (qt = a), u = l ? r.apply(c, l) : r.call(c), qt = o, u
    },
    Mc = function (e) {
        return xo(e), e.scrollTrigger && e.scrollTrigger.kill(!!Ki), e.progress() < 1 && Gn(e, "onInterrupt"), e
    },
    dl, CE = [],
    SE = function (e) {
        if (e)
            if (e = !e.name && e.default || e, LA() || e.headless) {
                var t = e.name,
                    i = Zt(e),
                    s = t && !i && e.init ? function () {
                        this._props = []
                    } : e,
                    r = {
                        init: vu,
                        render: VA,
                        add: QA,
                        kill: u1,
                        modifier: c1,
                        rawVars: 0
                    },
                    o = {
                        targetTest: 0,
                        get: 0,
                        getSetter: HA,
                        aliases: {},
                        register: 0
                    };
                if (Ql(), e !== s) {
                    if (On[t]) return;
                    hs(s, hs(qh(e, r), o)), ba(s.prototype, ba(r, qh(e, o))), On[s.prop = t] = s, e.targetTest && (Ah.push(s), NA[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                }
                lE(t, s), e.register && e.register(Rn, s, Cn)
            } else CE.push(e)
    },
    It = 255,
    Tc = {
        aqua: [0, It, It],
        lime: [0, It, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, It],
        navy: [0, 0, 128],
        white: [It, It, It],
        olive: [128, 128, 0],
        yellow: [It, It, 0],
        orange: [It, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [It, 0, 0],
        pink: [It, 192, 203],
        cyan: [0, It, It],
        transparent: [It, It, It, 0]
    },
    hp = function (e, t, i) {
        return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < .5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * It + .5 | 0
    },
    ME = function (e, t, i) {
        var s = e ? yr(e) ? [e >> 16, e >> 8 & It, e & It] : 0 : Tc.black,
            r, o, a, l, c, u, d, h, f, m;
        if (!s) {
            if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Tc[e]) s = Tc[e];
            else if (e.charAt(0) === "#") {
                if (e.length < 6 && (r = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + r + r + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return s = parseInt(e.substr(1, 6), 16), [s >> 16, s >> 8 & It, s & It, parseInt(e.substr(7), 16) / 255];
                e = parseInt(e.substr(1), 16), s = [e >> 16, e >> 8 & It, e & It]
            } else if (e.substr(0, 3) === "hsl") {
                if (s = m = e.match(Jm), !t) l = +s[0] % 360 / 360, c = +s[1] / 100, u = +s[2] / 100, o = u <= .5 ? u * (c + 1) : u + c - u * c, r = u * 2 - o, s.length > 3 && (s[3] *= 1), s[0] = hp(l + 1 / 3, r, o), s[1] = hp(l, r, o), s[2] = hp(l - 1 / 3, r, o);
                else if (~e.indexOf("=")) return s = e.match(nE), i && s.length < 4 && (s[3] = 1), s
            } else s = e.match(Jm) || Tc.transparent;
            s = s.map(Number)
        }
        return t && !m && (r = s[0] / It, o = s[1] / It, a = s[2] / It, d = Math.max(r, o, a), h = Math.min(r, o, a), u = (d + h) / 2, d === h ? l = c = 0 : (f = d - h, c = u > .5 ? f / (2 - d - h) : f / (d + h), l = d === r ? (o - a) / f + (o < a ? 6 : 0) : d === o ? (a - r) / f + 2 : (r - o) / f + 4, l *= 60), s[0] = ~~(l + .5), s[1] = ~~(c * 100 + .5), s[2] = ~~(u * 100 + .5)), i && s.length < 4 && (s[3] = 1), s
    },
    TE = function (e) {
        var t = [],
            i = [],
            s = -1;
        return e.split(mo).forEach(function (r) {
            var o = r.match(ul) || [];
            t.push.apply(t, o), i.push(s += o.length + 1)
        }), t.c = i, t
    },
    T_ = function (e, t, i) {
        var s = "",
            r = (e + s).match(mo),
            o = t ? "hsla(" : "rgba(",
            a = 0,
            l, c, u, d;
        if (!r) return e;
        if (r = r.map(function (h) {
            return (h = ME(h, t, 1)) && o + (t ? h[0] + "," + h[1] + "%," + h[2] + "%," + h[3] : h.join(",")) + ")"
        }), i && (u = TE(e), l = i.c, l.join(s) !== u.c.join(s)))
            for (c = e.replace(mo, "1").split(ul), d = c.length - 1; a < d; a++) s += c[a] + (~l.indexOf(a) ? r.shift() || o + "0,0,0,0)" : (u.length ? u : r.length ? r : i).shift());
        if (!c)
            for (c = e.split(mo), d = c.length - 1; a < d; a++) s += c[a] + r[a];
        return s + c[d]
    },
    mo = function () {
        var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
            e;
        for (e in Tc) n += "|" + e + "\\b";
        return new RegExp(n + ")", "gi")
    }(),
    YI = /hsl[a]?\(/,
    IE = function (e) {
        var t = e.join(" "),
            i;
        if (mo.lastIndex = 0, mo.test(t)) return i = YI.test(t), e[1] = T_(e[1], i), e[0] = T_(e[0], i, TE(e[1])), !0
    },
    xu, Qn = function () {
        var n = Date.now,
            e = 500,
            t = 33,
            i = n(),
            s = i,
            r = 1e3 / 240,
            o = r,
            a = [],
            l, c, u, d, h, f, m = function g(A) {
                var p = n() - s,
                    v = A === !0,
                    _, b, w, E;
                if ((p > e || p < 0) && (i += p - t), s += p, w = s - i, _ = w - o, (_ > 0 || v) && (E = ++d.frame, h = w - d.time * 1e3, d.time = w = w / 1e3, o += _ + (_ >= r ? 4 : r - _), b = 1), v || (l = c(g)), b)
                    for (f = 0; f < a.length; f++) a[f](w, h, E, A)
            };
        return d = {
            time: 0,
            frame: 0,
            tick: function () {
                m(!0)
            },
            deltaRatio: function (A) {
                return h / (1e3 / (A || 60))
            },
            wake: function () {
                oE && (!Zm && LA() && (Bs = Zm = window, kA = Bs.document || {}, qn.gsap = Rn, (Bs.gsapVersions || (Bs.gsapVersions = [])).push(Rn.version), aE(Vh || Bs.GreenSockGlobals || !Bs.gsap && Bs || {}), CE.forEach(SE)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && d.sleep(), c = u || function (A) {
                    return setTimeout(A, o - d.time * 1e3 + 1 | 0)
                }, xu = 1, m(2))
            },
            sleep: function () {
                (u ? cancelAnimationFrame : clearTimeout)(l), xu = 0, c = vu
            },
            lagSmoothing: function (A, p) {
                e = A || 1 / 0, t = Math.min(p || 33, e)
            },
            fps: function (A) {
                r = 1e3 / (A || 240), o = d.time * 1e3 + r
            },
            add: function (A, p, v) {
                var _ = p ? function (b, w, E, C) {
                    A(b, w, E, C), d.remove(_)
                } : A;
                return d.remove(A), a[v ? "unshift" : "push"](_), Ql(), _
            },
            remove: function (A, p) {
                ~(p = a.indexOf(A)) && a.splice(p, 1) && f >= p && f--
            },
            _listeners: a
        }, d
    }(),
    Ql = function () {
        return !xu && Qn.wake()
    },
    pt = {},
    XI = /^[\d.\-M][\d.\-,\s]/,
    KI = /["']/g,
    JI = function (e) {
        for (var t = {}, i = e.substr(1, e.length - 3).split(":"), s = i[0], r = 1, o = i.length, a, l, c; r < o; r++) l = i[r], a = r !== o - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, a), t[s] = isNaN(c) ? c.replace(KI, "").trim() : +c, s = l.substr(a + 1).trim();
        return t
    },
    ZI = function (e) {
        var t = e.indexOf("(") + 1,
            i = e.indexOf(")"),
            s = e.indexOf("(", t);
        return e.substring(t, ~s && s < i ? e.indexOf(")", i + 1) : i)
    },
    e1 = function (e) {
        var t = (e + "").split("("),
            i = pt[t[0]];
        return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [JI(t[1])] : ZI(e).split(",").map(hE)) : pt._CE && XI.test(e) ? pt._CE("", e) : i
    },
    BE = function (e) {
        return function (t) {
            return 1 - e(1 - t)
        }
    },
    RE = function n(e, t) {
        for (var i = e._first, s; i;) i instanceof un ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (s = i._ease, i._ease = i._yEase, i._yEase = s, i._yoyo = t)), i = i._next
    },
    ha = function (e, t) {
        return e && (Zt(e) ? e : pt[e] || e1(e)) || t
    },
    Ba = function (e, t, i, s) {
        i === void 0 && (i = function (l) {
            return 1 - t(1 - l)
        }), s === void 0 && (s = function (l) {
            return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
        });
        var r = {
            easeIn: t,
            easeOut: i,
            easeInOut: s
        },
            o;
        return wn(e, function (a) {
            pt[a] = qn[a] = r, pt[o = a.toLowerCase()] = i;
            for (var l in r) pt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = pt[a + "." + l] = r[l]
        }), r
    },
    PE = function (e) {
        return function (t) {
            return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
        }
    },
    fp = function n(e, t, i) {
        var s = t >= 1 ? t : 1,
            r = (i || (e ? .3 : .45)) / (t < 1 ? t : 1),
            o = r / Km * (Math.asin(1 / s) || 0),
            a = function (u) {
                return u === 1 ? 1 : s * Math.pow(2, -10 * u) * TI((u - o) * r) + 1
            },
            l = e === "out" ? a : e === "in" ? function (c) {
                return 1 - a(1 - c)
            } : PE(a);
        return r = Km / r, l.config = function (c, u) {
            return n(e, c, u)
        }, l
    },
    pp = function n(e, t) {
        t === void 0 && (t = 1.70158);
        var i = function (o) {
            return o ? --o * o * ((t + 1) * o + t) + 1 : 0
        },
            s = e === "out" ? i : e === "in" ? function (r) {
                return 1 - i(1 - r)
            } : PE(i);
        return s.config = function (r) {
            return n(e, r)
        }, s
    };
wn("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
    var t = e < 5 ? e + 1 : e;
    Ba(n + ",Power" + (t - 1), e ? function (i) {
        return Math.pow(i, t)
    } : function (i) {
        return i
    }, function (i) {
        return 1 - Math.pow(1 - i, t)
    }, function (i) {
        return i < .5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2
    })
});
pt.Linear.easeNone = pt.none = pt.Linear.easeIn;
Ba("Elastic", fp("in"), fp("out"), fp());
(function (n, e) {
    var t = 1 / e,
        i = 2 * t,
        s = 2.5 * t,
        r = function (a) {
            return a < t ? n * a * a : a < i ? n * Math.pow(a - 1.5 / e, 2) + .75 : a < s ? n * (a -= 2.25 / e) * a + .9375 : n * Math.pow(a - 2.625 / e, 2) + .984375
        };
    Ba("Bounce", function (o) {
        return 1 - r(1 - o)
    }, r)
})(7.5625, 2.75);
Ba("Expo", function (n) {
    return n ? Math.pow(2, 10 * (n - 1)) : 0
});
Ba("Circ", function (n) {
    return -(tE(1 - n * n) - 1)
});
Ba("Sine", function (n) {
    return n === 1 ? 1 : -MI(n * CI) + 1
});
Ba("Back", pp("in"), pp("out"), pp());
pt.SteppedEase = pt.steps = qn.SteppedEase = {
    config: function (e, t) {
        e === void 0 && (e = 1);
        var i = 1 / e,
            s = e + (t ? 0 : 1),
            r = t ? 1 : 0,
            o = 1 - kt;
        return function (a) {
            return ((s * Gu(0, o, a) | 0) + r) * i
        }
    }
};
Nl.ease = pt["quad.out"];
wn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (n) {
    return OA += n + "," + n + "Params,"
});
var DE = function (e, t) {
    this.id = SI++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : uE, this.set = t ? t.getSetter : HA
},
    yu = function () {
        function n(t) {
            this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ul(this, +t.duration, 1, 1), this.data = t.data, qt && (this._ctx = qt, qt.data.push(this)), xu || Qn.wake()
        }
        var e = n.prototype;
        return e.delay = function (i) {
            return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay
        }, e.duration = function (i) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur
        }, e.totalDuration = function (i) {
            return arguments.length ? (this._dirty = 0, Ul(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, e.totalTime = function (i, s) {
            if (Ql(), !arguments.length) return this._tTime;
            var r = this._dp;
            if (r && r.smoothChildTiming && this._ts) {
                for (Nf(this, i), !r._dp || r.parent || mE(r, this); r && r.parent;) r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && ks(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== i || !this._dur && !s || this._initted && Math.abs(this._zTime) === kt || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), dE(this, i, s)), this
        }, e.time = function (i, s) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + C_(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), s) : this._time
        }, e.totalProgress = function (i, s) {
            return arguments.length ? this.totalTime(this.totalDuration() * i, s) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
        }, e.progress = function (i, s) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + C_(this), s) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
        }, e.iteration = function (i, s) {
            var r = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (i - 1) * r, s) : this._repeat ? Ol(this._tTime, r) + 1 : 1
        }, e.timeScale = function (i, s) {
            if (!arguments.length) return this._rts === -kt ? 0 : this._rts;
            if (this._rts === i) return this;
            var r = this.parent && this._ts ? $h(this.parent._time, this) : this._tTime;
            return this._rts = +i || 0, this._ts = this._ps || i === -kt ? 0 : this._rts, this.totalTime(Gu(-Math.abs(this._delay), this._tDur, r), s !== !1), Ff(this), kI(this)
        }, e.paused = function (i) {
            return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ql(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== kt && (this._tTime -= kt)))), this) : this._ps
        }, e.startTime = function (i) {
            if (arguments.length) {
                this._start = i;
                var s = this.parent || this._dp;
                return s && (s._sort || !this.parent) && ks(s, this, i - this._delay), this
            }
            return this._start
        }, e.endTime = function (i) {
            return this._start + (En(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }, e.rawTime = function (i) {
            var s = this.parent || this._dp;
            return s ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? $h(s.rawTime(i), this) : this._tTime : this._tTime
        }, e.revert = function (i) {
            i === void 0 && (i = RI);
            var s = Ki;
            return Ki = i, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i), this.totalTime(-.01, i.suppressEvents)), this.data !== "nested" && i.kill !== !1 && this.kill(), Ki = s, this
        }, e.globalTime = function (i) {
            for (var s = this, r = arguments.length ? i : s.rawTime(); s;) r = s._start + r / (Math.abs(s._ts) || 1), s = s._dp;
            return !this.parent && this._sat ? this._sat.globalTime(i) : r
        }, e.repeat = function (i) {
            return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, S_(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
        }, e.repeatDelay = function (i) {
            if (arguments.length) {
                var s = this._time;
                return this._rDelay = i, S_(this), s ? this.time(s) : this
            }
            return this._rDelay
        }, e.yoyo = function (i) {
            return arguments.length ? (this._yoyo = i, this) : this._yoyo
        }, e.seek = function (i, s) {
            return this.totalTime(Jn(this, i), En(s))
        }, e.restart = function (i, s) {
            return this.play().totalTime(i ? -this._delay : 0, En(s))
        }, e.play = function (i, s) {
            return i != null && this.seek(i, s), this.reversed(!1).paused(!1)
        }, e.reverse = function (i, s) {
            return i != null && this.seek(i || this.totalDuration(), s), this.reversed(!0).paused(!1)
        }, e.pause = function (i, s) {
            return i != null && this.seek(i, s), this.paused(!0)
        }, e.resume = function () {
            return this.paused(!1)
        }, e.reversed = function (i) {
            return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -kt : 0)), this) : this._rts < 0
        }, e.invalidate = function () {
            return this._initted = this._act = 0, this._zTime = -kt, this
        }, e.isActive = function () {
            var i = this.parent || this._dp,
                s = this._start,
                r;
            return !!(!i || this._ts && this._initted && i.isActive() && (r = i.rawTime(!0)) >= s && r < this.endTime(!0) - kt)
        }, e.eventCallback = function (i, s, r) {
            var o = this.vars;
            return arguments.length > 1 ? (s ? (o[i] = s, r && (o[i + "Params"] = r), i === "onUpdate" && (this._onUpdate = s)) : delete o[i], this) : o[i]
        }, e.then = function (i) {
            var s = this;
            return new Promise(function (r) {
                var o = Zt(i) ? i : fE,
                    a = function () {
                        var c = s.then;
                        s.then = null, Zt(o) && (o = o(s)) && (o.then || o === s) && (s.then = c), r(o), s.then = c
                    };
                s._initted && s.totalProgress() === 1 && s._ts >= 0 || !s._tTime && s._ts < 0 ? a() : s._prom = a
            })
        }, e.kill = function () {
            Mc(this)
        }, n
    }();
hs(yu.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -kt,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var un = function (n) {
    eE(e, n);

    function e(i, s) {
        var r;
        return i === void 0 && (i = {}), r = n.call(this, i) || this, r.labels = {}, r.smoothChildTiming = !!i.smoothChildTiming, r.autoRemoveChildren = !!i.autoRemoveChildren, r._sort = En(i.sortChildren), jt && ks(i.parent || jt, or(r), s), i.reversed && r.reverse(), i.paused && r.paused(!0), i.scrollTrigger && gE(or(r), i.scrollTrigger), r
    }
    var t = e.prototype;
    return t.to = function (s, r, o) {
        return $c(0, arguments, this), this
    }, t.from = function (s, r, o) {
        return $c(1, arguments, this), this
    }, t.fromTo = function (s, r, o, a) {
        return $c(2, arguments, this), this
    }, t.set = function (s, r, o) {
        return r.duration = 0, r.parent = this, qc(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new di(s, r, Jn(this, o), 1), this
    }, t.call = function (s, r, o) {
        return ks(this, di.delayedCall(0, s, r), o)
    }, t.staggerTo = function (s, r, o, a, l, c, u) {
        return o.duration = r, o.stagger = o.stagger || a, o.onComplete = c, o.onCompleteParams = u, o.parent = this, new di(s, o, Jn(this, l)), this
    }, t.staggerFrom = function (s, r, o, a, l, c, u) {
        return o.runBackwards = 1, qc(o).immediateRender = En(o.immediateRender), this.staggerTo(s, r, o, a, l, c, u)
    }, t.staggerFromTo = function (s, r, o, a, l, c, u, d) {
        return a.startAt = o, qc(a).immediateRender = En(a.immediateRender), this.staggerTo(s, r, a, l, c, u, d)
    }, t.render = function (s, r, o) {
        var a = this._time,
            l = this._dirty ? this.totalDuration() : this._tDur,
            c = this._dur,
            u = s <= 0 ? 0 : Ii(s),
            d = this._zTime < 0 != s < 0 && (this._initted || !c),
            h, f, m, g, A, p, v, _, b, w, E, C;
        if (this !== jt && u > l && s >= 0 && (u = l), u !== this._tTime || o || d) {
            if (a !== this._time && c && (u += this._time - a, s += this._time - a), h = u, b = this._start, _ = this._ts, p = !_, d && (c || (a = this._zTime), (s || !r) && (this._zTime = s)), this._repeat) {
                if (E = this._yoyo, A = c + this._rDelay, this._repeat < -1 && s < 0) return this.totalTime(A * 100 + s, r, o);
                if (h = Ii(u % A), u === l ? (g = this._repeat, h = c) : (g = ~~(u / A), g && g === u / A && (h = c, g--), h > c && (h = c)), w = Ol(this._tTime, A), !a && this._tTime && w !== g && this._tTime - w * A - this._dur <= 0 && (w = g), E && g & 1 && (h = c - h, C = 1), g !== w && !this._lock) {
                    var S = E && w & 1,
                        x = S === (E && g & 1);
                    if (g < w && (S = !S), a = S ? 0 : u % c ? c : u, this._lock = 1, this.render(a || (C ? 0 : Ii(g * A)), r, !c)._lock = 0, this._tTime = u, !r && this.parent && Gn(this, "onRepeat"), this.vars.repeatRefresh && !C && (this.invalidate()._lock = 1), a && a !== this._time || p !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                    if (c = this._dur, l = this._tDur, x && (this._lock = 2, a = S ? c : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !C && this.invalidate()), this._lock = 0, !this._ts && !p) return this;
                    RE(this, C)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (v = UI(this, Ii(a), Ii(h)), v && (u -= h - (h = v._start))), this._tTime = u, this._time = h, this._act = !_, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = s, a = 0), !a && h && !r && !g && (Gn(this, "onStart"), this._tTime !== u)) return this;
            if (h >= a && s >= 0)
                for (f = this._first; f;) {
                    if (m = f._next, (f._act || h >= f._start) && f._ts && v !== f) {
                        if (f.parent !== this) return this.render(s, r, o);
                        if (f.render(f._ts > 0 ? (h - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (h - f._start) * f._ts, r, o), h !== this._time || !this._ts && !p) {
                            v = 0, m && (u += this._zTime = -kt);
                            break
                        }
                    }
                    f = m
                } else {
                f = this._last;
                for (var y = s < 0 ? s : h; f;) {
                    if (m = f._prev, (f._act || y <= f._end) && f._ts && v !== f) {
                        if (f.parent !== this) return this.render(s, r, o);
                        if (f.render(f._ts > 0 ? (y - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (y - f._start) * f._ts, r, o || Ki && (f._initted || f._startAt)), h !== this._time || !this._ts && !p) {
                            v = 0, m && (u += this._zTime = y ? -kt : kt);
                            break
                        }
                    }
                    f = m
                }
            }
            if (v && !r && (this.pause(), v.render(h >= a ? 0 : -kt)._zTime = h >= a ? 1 : -1, this._ts)) return this._start = b, Ff(this), this.render(s, r, o);
            this._onUpdate && !r && Gn(this, "onUpdate", !0), (u === l && this._tTime >= this.totalDuration() || !u && a) && (b === this._start || Math.abs(_) !== Math.abs(this._ts)) && (this._lock || ((s || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && xo(this, 1), !r && !(s < 0 && !a) && (u || a || !l) && (Gn(this, u === l && s >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }, t.add = function (s, r) {
        var o = this;
        if (yr(r) || (r = Jn(this, r, s)), !(s instanceof yu)) {
            if (Ji(s)) return s.forEach(function (a) {
                return o.add(a, r)
            }), this;
            if (Li(s)) return this.addLabel(s, r);
            if (Zt(s)) s = di.delayedCall(0, s);
            else return this
        }
        return this !== s ? ks(this, s, r) : this
    }, t.getChildren = function (s, r, o, a) {
        s === void 0 && (s = !0), r === void 0 && (r = !0), o === void 0 && (o = !0), a === void 0 && (a = -rs);
        for (var l = [], c = this._first; c;) c._start >= a && (c instanceof di ? r && l.push(c) : (o && l.push(c), s && l.push.apply(l, c.getChildren(!0, r, o)))), c = c._next;
        return l
    }, t.getById = function (s) {
        for (var r = this.getChildren(1, 1, 1), o = r.length; o--;)
            if (r[o].vars.id === s) return r[o]
    }, t.remove = function (s) {
        return Li(s) ? this.removeLabel(s) : Zt(s) ? this.killTweensOf(s) : (kf(this, s), s === this._recent && (this._recent = this._last), da(this))
    }, t.totalTime = function (s, r) {
        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Ii(Qn.time - (this._ts > 0 ? s / this._ts : (this.totalDuration() - s) / -this._ts))), n.prototype.totalTime.call(this, s, r), this._forcing = 0, this) : this._tTime
    }, t.addLabel = function (s, r) {
        return this.labels[s] = Jn(this, r), this
    }, t.removeLabel = function (s) {
        return delete this.labels[s], this
    }, t.addPause = function (s, r, o) {
        var a = di.delayedCall(0, r || vu, o);
        return a.data = "isPause", this._hasPause = 1, ks(this, a, Jn(this, s))
    }, t.removePause = function (s) {
        var r = this._first;
        for (s = Jn(this, s); r;) r._start === s && r.data === "isPause" && xo(r), r = r._next
    }, t.killTweensOf = function (s, r, o) {
        for (var a = this.getTweensOf(s, o), l = a.length; l--;) so !== a[l] && a[l].kill(s, r);
        return this
    }, t.getTweensOf = function (s, r) {
        for (var o = [], a = os(s), l = this._first, c = yr(r), u; l;) l instanceof di ? PI(l._targets, a) && (c ? (!so || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, r)).length && o.push.apply(o, u), l = l._next;
        return o
    }, t.tweenTo = function (s, r) {
        r = r || {};
        var o = this,
            a = Jn(o, s),
            l = r,
            c = l.startAt,
            u = l.onStart,
            d = l.onStartParams,
            h = l.immediateRender,
            f, m = di.to(o, hs({
                ease: r.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: a,
                overwrite: "auto",
                duration: r.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()) || kt,
                onStart: function () {
                    if (o.pause(), !f) {
                        var A = r.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale());
                        m._dur !== A && Ul(m, A, 0, 1).render(m._time, !0, !0), f = 1
                    }
                    u && u.apply(m, d || [])
                }
            }, r));
        return h ? m.render(0) : m
    }, t.tweenFromTo = function (s, r, o) {
        return this.tweenTo(r, hs({
            startAt: {
                time: Jn(this, s)
            }
        }, o))
    }, t.recent = function () {
        return this._recent
    }, t.nextLabel = function (s) {
        return s === void 0 && (s = this._time), M_(this, Jn(this, s))
    }, t.previousLabel = function (s) {
        return s === void 0 && (s = this._time), M_(this, Jn(this, s), 1)
    }, t.currentLabel = function (s) {
        return arguments.length ? this.seek(s, !0) : this.previousLabel(this._time + kt)
    }, t.shiftChildren = function (s, r, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, c; a;) a._start >= o && (a._start += s, a._end += s), a = a._next;
        if (r)
            for (c in l) l[c] >= o && (l[c] += s);
        return da(this)
    }, t.invalidate = function (s) {
        var r = this._first;
        for (this._lock = 0; r;) r.invalidate(s), r = r._next;
        return n.prototype.invalidate.call(this, s)
    }, t.clear = function (s) {
        s === void 0 && (s = !0);
        for (var r = this._first, o; r;) o = r._next, this.remove(r), r = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0), s && (this.labels = {}), da(this)
    }, t.totalDuration = function (s) {
        var r = 0,
            o = this,
            a = o._last,
            l = rs,
            c, u, d;
        if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -s : s));
        if (o._dirty) {
            for (d = o.parent; a;) c = a._prev, a._dirty && a.totalDuration(), u = a._start, u > l && o._sort && a._ts && !o._lock ? (o._lock = 1, ks(o, a, u - a._delay, 1)._lock = 0) : l = u, u < 0 && a._ts && (r -= u, (!d && !o._dp || d && d.smoothChildTiming) && (o._start += u / o._ts, o._time -= u, o._tTime -= u), o.shiftChildren(-u, !1, -1 / 0), l = 0), a._end > r && a._ts && (r = a._end), a = c;
            Ul(o, o === jt && o._time > r ? o._time : r, 1, 1), o._dirty = 0
        }
        return o._tDur
    }, e.updateRoot = function (s) {
        if (jt._ts && (dE(jt, $h(s, jt)), cE = Qn.frame), Qn.frame >= E_) {
            E_ += Wn.autoSleep || 120;
            var r = jt._first;
            if ((!r || !r._ts) && Wn.autoSleep && Qn._listeners.length < 2) {
                for (; r && !r._ts;) r = r._next;
                r || Qn.sleep()
            }
        }
    }, e
}(yu);
hs(un.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var t1 = function (e, t, i, s, r, o, a) {
    var l = new Cn(this._pt, e, t, 0, 1, UE, null, r),
        c = 0,
        u = 0,
        d, h, f, m, g, A, p, v;
    for (l.b = i, l.e = s, i += "", s += "", (p = ~s.indexOf("random(")) && (s = bu(s)), o && (v = [i, s], o(v, e, t), i = v[0], s = v[1]), h = i.match(up) || []; d = up.exec(s);) m = d[0], g = s.substring(c, d.index), f ? f = (f + 1) % 5 : g.substr(-5) === "rgba(" && (f = 1), m !== h[u++] && (A = parseFloat(h[u - 1]) || 0, l._pt = {
        _next: l._pt,
        p: g || u === 1 ? g : ",",
        s: A,
        c: m.charAt(1) === "=" ? Cl(A, m) - A : parseFloat(m) - A,
        m: f && f < 4 ? Math.round : 0
    }, c = up.lastIndex);
    return l.c = c < s.length ? s.substring(c, s.length) : "", l.fp = a, (sE.test(s) || p) && (l.e = 0), this._pt = l, l
},
    QA = function (e, t, i, s, r, o, a, l, c, u) {
        Zt(s) && (s = s(r || 0, e, o));
        var d = e[t],
            h = i !== "get" ? i : Zt(d) ? c ? e[t.indexOf("set") || !Zt(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : d,
            f = Zt(d) ? c ? o1 : NE : GA,
            m;
        if (Li(s) && (~s.indexOf("random(") && (s = bu(s)), s.charAt(1) === "=" && (m = Cl(h, s) + (Xi(h) || 0), (m || m === 0) && (s = m))), !u || h !== s || og) return !isNaN(h * s) && s !== "" ? (m = new Cn(this._pt, e, t, +h || 0, s - (h || 0), typeof d == "boolean" ? l1 : OE, 0, f), c && (m.fp = c), a && m.modifier(a, this, e), this._pt = m) : (!d && !(t in e) && FA(t, s), t1.call(this, e, t, h, s, f, l || Wn.stringFilter, c))
    },
    i1 = function (e, t, i, s, r) {
        if (Zt(e) && (e = jc(e, r, t, i, s)), !qs(e) || e.style && e.nodeType || Ji(e) || iE(e)) return Li(e) ? jc(e, r, t, i, s) : e;
        var o = {},
            a;
        for (a in e) o[a] = jc(e[a], r, t, i, s);
        return o
    },
    LE = function (e, t, i, s, r, o) {
        var a, l, c, u;
        if (On[e] && (a = new On[e]).init(r, a.rawVars ? t[e] : i1(t[e], s, r, o, i), i, s, o) !== !1 && (i._pt = l = new Cn(i._pt, r, e, 0, 1, a.render, a, 0, a.priority), i !== dl))
            for (c = i._ptLookup[i._targets.indexOf(r)], u = a._props.length; u--;) c[a._props[u]] = l;
        return a
    },
    so, og, zA = function n(e, t, i) {
        var s = e.vars,
            r = s.ease,
            o = s.startAt,
            a = s.immediateRender,
            l = s.lazy,
            c = s.onUpdate,
            u = s.runBackwards,
            d = s.yoyoEase,
            h = s.keyframes,
            f = s.autoRevert,
            m = e._dur,
            g = e._startAt,
            A = e._targets,
            p = e.parent,
            v = p && p.data === "nested" ? p.vars.targets : A,
            _ = e._overwrite === "auto" && !PA,
            b = e.timeline,
            w, E, C, S, x, y, P, T, R, D, U, Q, F;
        if (b && (!h || !r) && (r = "none"), e._ease = ha(r, Nl.ease), e._yEase = d ? BE(ha(d === !0 ? r : d, Nl.ease)) : 0, d && e._yoyo && !e._repeat && (d = e._yEase, e._yEase = e._ease, e._ease = d), e._from = !b && !!s.runBackwards, !b || h && !s.stagger) {
            if (T = A[0] ? ua(A[0]).harness : 0, Q = T && s[T.prop], w = qh(s, NA), g && (g._zTime < 0 && g.progress(1), t < 0 && u && a && !f ? g.render(-1, !0) : g.revert(u && m ? gh : BI), g._lazy = 0), o) {
                if (xo(e._startAt = di.set(A, hs({
                    data: "isStart",
                    overwrite: !1,
                    parent: p,
                    immediateRender: !0,
                    lazy: !g && En(l),
                    startAt: null,
                    delay: 0,
                    onUpdate: c && function () {
                        return Gn(e, "onUpdate")
                    },
                    stagger: 0
                }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Ki || !a && !f) && e._startAt.revert(gh), a && m && t <= 0 && i <= 0) {
                    t && (e._zTime = t);
                    return
                }
            } else if (u && m && !g) {
                if (t && (a = !1), C = hs({
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: a && !g && En(l),
                    immediateRender: a,
                    stagger: 0,
                    parent: p
                }, w), Q && (C[T.prop] = Q), xo(e._startAt = di.set(A, C)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Ki ? e._startAt.revert(gh) : e._startAt.render(-1, !0)), e._zTime = t, !a) n(e._startAt, kt, kt);
                else if (!t) return
            }
            for (e._pt = e._ptCache = 0, l = m && En(l) || l && !m, E = 0; E < A.length; E++) {
                if (x = A[E], P = x._gsap || UA(A)[E]._gsap, e._ptLookup[E] = D = {}, eg[P.id] && po.length && Wh(), U = v === A ? E : v.indexOf(x), T && (R = new T).init(x, Q || w, e, U, v) !== !1 && (e._pt = S = new Cn(e._pt, x, R.name, 0, 1, R.render, R, 0, R.priority), R._props.forEach(function (L) {
                    D[L] = S
                }), R.priority && (y = 1)), !T || Q)
                    for (C in w) On[C] && (R = LE(C, w, e, U, x, v)) ? R.priority && (y = 1) : D[C] = S = QA.call(e, x, C, "get", w[C], U, v, 0, s.stringFilter);
                e._op && e._op[E] && e.kill(x, e._op[E]), _ && e._pt && (so = e, jt.killTweensOf(x, D, e.globalTime(t)), F = !e.parent, so = 0), e._pt && l && (eg[P.id] = 1)
            }
            y && QE(e), e._onInit && e._onInit(e)
        }
        e._onUpdate = c, e._initted = (!e._op || e._pt) && !F, h && t <= 0 && b.render(rs, !0, !0)
    },
    n1 = function (e, t, i, s, r, o, a, l) {
        var c = (e._pt && e._ptCache || (e._ptCache = {}))[t],
            u, d, h, f;
        if (!c)
            for (c = e._ptCache[t] = [], h = e._ptLookup, f = e._targets.length; f--;) {
                if (u = h[f][t], u && u.d && u.d._pt)
                    for (u = u.d._pt; u && u.p !== t && u.fp !== t;) u = u._next;
                if (!u) return og = 1, e.vars[t] = "+=0", zA(e, a), og = 0, l ? _u(t + " not eligible for reset") : 1;
                c.push(u)
            }
        for (f = c.length; f--;) d = c[f], u = d._pt || d, u.s = (s || s === 0) && !r ? s : u.s + (s || 0) + o * u.c, u.c = i - u.s, d.e && (d.e = si(i) + Xi(d.e)), d.b && (d.b = u.s + Xi(d.b))
    },
    s1 = function (e, t) {
        var i = e[0] ? ua(e[0]).harness : 0,
            s = i && i.aliases,
            r, o, a, l;
        if (!s) return t;
        r = ba({}, t);
        for (o in s)
            if (o in r)
                for (l = s[o].split(","), a = l.length; a--;) r[l[a]] = r[o];
        return r
    },
    r1 = function (e, t, i, s) {
        var r = t.ease || s || "power1.inOut",
            o, a;
        if (Ji(t)) a = i[e] || (i[e] = []), t.forEach(function (l, c) {
            return a.push({
                t: c / (t.length - 1) * 100,
                v: l,
                e: r
            })
        });
        else
            for (o in t) a = i[o] || (i[o] = []), o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: r
            })
    },
    jc = function (e, t, i, s, r) {
        return Zt(e) ? e.call(t, i, s, r) : Li(e) && ~e.indexOf("random(") ? bu(e) : e
    },
    kE = OA + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    FE = {};
wn(kE + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) {
    return FE[n] = 1
});
var di = function (n) {
    eE(e, n);

    function e(i, s, r, o) {
        var a;
        typeof s == "number" && (r.duration = s, s = r, r = null), a = n.call(this, o ? s : qc(s)) || this;
        var l = a.vars,
            c = l.duration,
            u = l.delay,
            d = l.immediateRender,
            h = l.stagger,
            f = l.overwrite,
            m = l.keyframes,
            g = l.defaults,
            A = l.scrollTrigger,
            p = l.yoyoEase,
            v = s.parent || jt,
            _ = (Ji(i) || iE(i) ? yr(i[0]) : "length" in s) ? [i] : os(i),
            b, w, E, C, S, x, y, P;
        if (a._targets = _.length ? UA(_) : _u("GSAP target " + i + " not found. https://gsap.com", !Wn.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = f, m || h || ad(c) || ad(u)) {
            if (s = a.vars, b = a.timeline = new un({
                data: "nested",
                defaults: g || {},
                targets: v && v.data === "nested" ? v.vars.targets : _
            }), b.kill(), b.parent = b._dp = or(a), b._start = 0, h || ad(c) || ad(u)) {
                if (C = _.length, y = h && bE(h), qs(h))
                    for (S in h) ~kE.indexOf(S) && (P || (P = {}), P[S] = h[S]);
                for (w = 0; w < C; w++) E = qh(s, FE), E.stagger = 0, p && (E.yoyoEase = p), P && ba(E, P), x = _[w], E.duration = +jc(c, or(a), w, x, _), E.delay = (+jc(u, or(a), w, x, _) || 0) - a._delay, !h && C === 1 && E.delay && (a._delay = u = E.delay, a._start += u, E.delay = 0), b.to(x, E, y ? y(w, x, _) : 0), b._ease = pt.none;
                b.duration() ? c = u = 0 : a.timeline = 0
            } else if (m) {
                qc(hs(b.vars.defaults, {
                    ease: "none"
                })), b._ease = ha(m.ease || s.ease || "none");
                var T = 0,
                    R, D, U;
                if (Ji(m)) m.forEach(function (Q) {
                    return b.to(_, Q, ">")
                }), b.duration();
                else {
                    E = {};
                    for (S in m) S === "ease" || S === "easeEach" || r1(S, m[S], E, m.easeEach);
                    for (S in E)
                        for (R = E[S].sort(function (Q, F) {
                            return Q.t - F.t
                        }), T = 0, w = 0; w < R.length; w++) D = R[w], U = {
                            ease: D.e,
                            duration: (D.t - (w ? R[w - 1].t : 0)) / 100 * c
                        }, U[S] = D.v, b.to(_, U, T), T += U.duration;
                    b.duration() < c && b.to({}, {
                        duration: c - b.duration()
                    })
                }
            }
            c || a.duration(c = b.duration())
        } else a.timeline = 0;
        return f === !0 && !PA && (so = or(a), jt.killTweensOf(_), so = 0), ks(v, or(a), r), s.reversed && a.reverse(), s.paused && a.paused(!0), (d || !c && !m && a._start === Ii(v._time) && En(d) && FI(or(a)) && v.data !== "nested") && (a._tTime = -kt, a.render(Math.max(0, -u) || 0)), A && gE(or(a), A), a
    }
    var t = e.prototype;
    return t.render = function (s, r, o) {
        var a = this._time,
            l = this._tDur,
            c = this._dur,
            u = s < 0,
            d = s > l - kt && !u ? l : s < kt ? 0 : s,
            h, f, m, g, A, p, v, _, b;
        if (!c) OI(this, s, r, o);
        else if (d !== this._tTime || !s || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
            if (h = d, _ = this.timeline, this._repeat) {
                if (g = c + this._rDelay, this._repeat < -1 && u) return this.totalTime(g * 100 + s, r, o);
                if (h = Ii(d % g), d === l ? (m = this._repeat, h = c) : (m = ~~(d / g), m && m === Ii(d / g) && (h = c, m--), h > c && (h = c)), p = this._yoyo && m & 1, p && (b = this._yEase, h = c - h), A = Ol(this._tTime, g), h === a && !o && this._initted && m === A) return this._tTime = d, this;
                m !== A && (_ && this._yEase && RE(_, p), this.vars.repeatRefresh && !p && !this._lock && this._time !== g && this._initted && (this._lock = o = 1, this.render(Ii(g * m), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (AE(this, u ? s : h, o, r, d)) return this._tTime = 0, this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && m !== A)) return this;
                if (c !== this._dur) return this.render(s, r, o)
            }
            if (this._tTime = d, this._time = h, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = v = (b || this._ease)(h / c), this._from && (this.ratio = v = 1 - v), h && !a && !r && !m && (Gn(this, "onStart"), this._tTime !== d)) return this;
            for (f = this._pt; f;) f.r(v, f.d), f = f._next;
            _ && _.render(s < 0 ? s : _._dur * _._ease(h / this._dur), r, o) || this._startAt && (this._zTime = s), this._onUpdate && !r && (u && tg(this, s, r, o), Gn(this, "onUpdate")), this._repeat && m !== A && this.vars.onRepeat && !r && this.parent && Gn(this, "onRepeat"), (d === this._tDur || !d) && this._tTime === d && (u && !this._onUpdate && tg(this, s, !0, !0), (s || !c) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && xo(this, 1), !r && !(u && !a) && (d || a || p) && (Gn(this, d === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(d < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }, t.targets = function () {
        return this._targets
    }, t.invalidate = function (s) {
        return (!s || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(s), n.prototype.invalidate.call(this, s)
    }, t.resetTo = function (s, r, o, a, l) {
        xu || Qn.wake(), this._ts || this.play();
        var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
            u;
        return this._initted || zA(this, c), u = this._ease(c / this._dur), n1(this, s, r, o, a, u, c, l) ? this.resetTo(s, r, o, a, 1) : (Nf(this, 0), this.parent || pE(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
    }, t.kill = function (s, r) {
        if (r === void 0 && (r = "all"), !s && (!r || r === "all")) return this._lazy = this._pt = 0, this.parent ? Mc(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(s, r, so && so.vars.overwrite !== !0)._first || Mc(this), this.parent && o !== this.timeline.totalDuration() && Ul(this, this._dur * this.timeline._tDur / o, 0, 1), this
        }
        var a = this._targets,
            l = s ? os(s) : a,
            c = this._ptLookup,
            u = this._pt,
            d, h, f, m, g, A, p;
        if ((!r || r === "all") && LI(a, l)) return r === "all" && (this._pt = 0), Mc(this);
        for (d = this._op = this._op || [], r !== "all" && (Li(r) && (g = {}, wn(r, function (v) {
            return g[v] = 1
        }), r = g), r = s1(a, r)), p = a.length; p--;)
            if (~l.indexOf(a[p])) {
                h = c[p], r === "all" ? (d[p] = r, m = h, f = {}) : (f = d[p] = d[p] || {}, m = r);
                for (g in m) A = h && h[g], A && ((!("kill" in A.d) || A.d.kill(g) === !0) && kf(this, A, "_pt"), delete h[g]), f !== "all" && (f[g] = 1)
            }
        return this._initted && !this._pt && u && Mc(this), this
    }, e.to = function (s, r) {
        return new e(s, r, arguments[2])
    }, e.from = function (s, r) {
        return $c(1, arguments)
    }, e.delayedCall = function (s, r, o, a) {
        return new e(r, 0, {
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: s,
            onComplete: r,
            onReverseComplete: r,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }, e.fromTo = function (s, r, o) {
        return $c(2, arguments)
    }, e.set = function (s, r) {
        return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(s, r)
    }, e.killTweensOf = function (s, r, o) {
        return jt.killTweensOf(s, r, o)
    }, e
}(yu);
hs(di.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
wn("staggerTo,staggerFrom,staggerFromTo", function (n) {
    di[n] = function () {
        var e = new un,
            t = ng.call(arguments, 0);
        return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t)
    }
});
var GA = function (e, t, i) {
    return e[t] = i
},
    NE = function (e, t, i) {
        return e[t](i)
    },
    o1 = function (e, t, i, s) {
        return e[t](s.fp, i)
    },
    a1 = function (e, t, i) {
        return e.setAttribute(t, i)
    },
    HA = function (e, t) {
        return Zt(e[t]) ? NE : DA(e[t]) && e.setAttribute ? a1 : GA
    },
    OE = function (e, t) {
        return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
    },
    l1 = function (e, t) {
        return t.set(t.t, t.p, !!(t.s + t.c * e), t)
    },
    UE = function (e, t) {
        var i = t._pt,
            s = "";
        if (!e && t.b) s = t.b;
        else if (e === 1 && t.e) s = t.e;
        else {
            for (; i;) s = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + s, i = i._next;
            s += t.c
        }
        t.set(t.t, t.p, s, t)
    },
    VA = function (e, t) {
        for (var i = t._pt; i;) i.r(e, i.d), i = i._next
    },
    c1 = function (e, t, i, s) {
        for (var r = this._pt, o; r;) o = r._next, r.p === s && r.modifier(e, t, i), r = o
    },
    u1 = function (e) {
        for (var t = this._pt, i, s; t;) s = t._next, t.p === e && !t.op || t.op === e ? kf(this, t, "_pt") : t.dep || (i = 1), t = s;
        return !i
    },
    d1 = function (e, t, i, s) {
        s.mSet(e, t, s.m.call(s.tween, i, s.mt), s)
    },
    QE = function (e) {
        for (var t = e._pt, i, s, r, o; t;) {
            for (i = t._next, s = r; s && s.pr > t.pr;) s = s._next;
            (t._prev = s ? s._prev : o) ? t._prev._next = t : r = t, (t._next = s) ? s._prev = t : o = t, t = i
        }
        e._pt = r
    },
    Cn = function () {
        function n(t, i, s, r, o, a, l, c, u) {
            this.t = i, this.s = r, this.c = o, this.p = s, this.r = a || OE, this.d = l || this, this.set = c || GA, this.pr = u || 0, this._next = t, t && (t._prev = this)
        }
        var e = n.prototype;
        return e.modifier = function (i, s, r) {
            this.mSet = this.mSet || this.set, this.set = d1, this.m = i, this.mt = r, this.tween = s
        }, n
    }();
wn(OA + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (n) {
    return NA[n] = 1
});
qn.TweenMax = qn.TweenLite = di;
qn.TimelineLite = qn.TimelineMax = un;
jt = new un({
    sortChildren: !1,
    defaults: Nl,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Wn.stringFilter = IE;
var fa = [],
    _h = {},
    h1 = [],
    I_ = 0,
    f1 = 0,
    mp = function (e) {
        return (_h[e] || h1).map(function (t) {
            return t()
        })
    },
    ag = function () {
        var e = Date.now(),
            t = [];
        e - I_ > 2 && (mp("matchMediaInit"), fa.forEach(function (i) {
            var s = i.queries,
                r = i.conditions,
                o, a, l, c;
            for (a in s) o = Bs.matchMedia(s[a]).matches, o && (l = 1), o !== r[a] && (r[a] = o, c = 1);
            c && (i.revert(), l && t.push(i))
        }), mp("matchMediaRevert"), t.forEach(function (i) {
            return i.onMatch(i, function (s) {
                return i.add(null, s)
            })
        }), I_ = e, mp("matchMedia"))
    },
    zE = function () {
        function n(t, i) {
            this.selector = i && sg(i), this.data = [], this._r = [], this.isReverted = !1, this.id = f1++, t && this.add(t)
        }
        var e = n.prototype;
        return e.add = function (i, s, r) {
            Zt(i) && (r = s, s = i, i = Zt);
            var o = this,
                a = function () {
                    var c = qt,
                        u = o.selector,
                        d;
                    return c && c !== o && c.data.push(o), r && (o.selector = sg(r)), qt = o, d = s.apply(o, arguments), Zt(d) && o._r.push(d), qt = c, o.selector = u, o.isReverted = !1, d
                };
            return o.last = a, i === Zt ? a(o, function (l) {
                return o.add(null, l)
            }) : i ? o[i] = a : a
        }, e.ignore = function (i) {
            var s = qt;
            qt = null, i(this), qt = s
        }, e.getTweens = function () {
            var i = [];
            return this.data.forEach(function (s) {
                return s instanceof n ? i.push.apply(i, s.getTweens()) : s instanceof di && !(s.parent && s.parent.data === "nested") && i.push(s)
            }), i
        }, e.clear = function () {
            this._r.length = this.data.length = 0
        }, e.kill = function (i, s) {
            var r = this;
            if (i ? function () {
                for (var a = r.getTweens(), l = r.data.length, c; l--;) c = r.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function (u) {
                    return a.splice(a.indexOf(u), 1)
                }));
                for (a.map(function (u) {
                    return {
                        g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
                        t: u
                    }
                }).sort(function (u, d) {
                    return d.g - u.g || -1 / 0
                }).forEach(function (u) {
                    return u.t.revert(i)
                }), l = r.data.length; l--;) c = r.data[l], c instanceof un ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof di) && c.revert && c.revert(i);
                r._r.forEach(function (u) {
                    return u(i, r)
                }), r.isReverted = !0
            }() : this.data.forEach(function (a) {
                return a.kill && a.kill()
            }), this.clear(), s)
                for (var o = fa.length; o--;) fa[o].id === this.id && fa.splice(o, 1)
        }, e.revert = function (i) {
            this.kill(i || {})
        }, n
    }(),
    p1 = function () {
        function n(t) {
            this.contexts = [], this.scope = t, qt && qt.data.push(this)
        }
        var e = n.prototype;
        return e.add = function (i, s, r) {
            qs(i) || (i = {
                matches: i
            });
            var o = new zE(0, r || this.scope),
                a = o.conditions = {},
                l, c, u;
            qt && !o.selector && (o.selector = qt.selector), this.contexts.push(o), s = o.add("onMatch", s), o.queries = i;
            for (c in i) c === "all" ? u = 1 : (l = Bs.matchMedia(i[c]), l && (fa.indexOf(o) < 0 && fa.push(o), (a[c] = l.matches) && (u = 1), l.addListener ? l.addListener(ag) : l.addEventListener("change", ag)));
            return u && s(o, function (d) {
                return o.add(null, d)
            }), this
        }, e.revert = function (i) {
            this.kill(i || {})
        }, e.kill = function (i) {
            this.contexts.forEach(function (s) {
                return s.kill(i, !0)
            })
        }, n
    }(),
    jh = {
        registerPlugin: function () {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
            t.forEach(function (s) {
                return SE(s)
            })
        },
        timeline: function (e) {
            return new un(e)
        },
        getTweensOf: function (e, t) {
            return jt.getTweensOf(e, t)
        },
        getProperty: function (e, t, i, s) {
            Li(e) && (e = os(e)[0]);
            var r = ua(e || {}).get,
                o = i ? fE : hE;
            return i === "native" && (i = ""), e && (t ? o((On[t] && On[t].get || r)(e, t, i, s)) : function (a, l, c) {
                return o((On[a] && On[a].get || r)(e, a, l, c))
            })
        },
        quickSetter: function (e, t, i) {
            if (e = os(e), e.length > 1) {
                var s = e.map(function (u) {
                    return Rn.quickSetter(u, t, i)
                }),
                    r = s.length;
                return function (u) {
                    for (var d = r; d--;) s[d](u)
                }
            }
            e = e[0] || {};
            var o = On[t],
                a = ua(e),
                l = a.harness && (a.harness.aliases || {})[t] || t,
                c = o ? function (u) {
                    var d = new o;
                    dl._pt = 0, d.init(e, i ? u + i : u, dl, 0, [e]), d.render(1, d), dl._pt && VA(1, dl)
                } : a.set(e, l);
            return o ? c : function (u) {
                return c(e, l, i ? u + i : u, a, 1)
            }
        },
        quickTo: function (e, t, i) {
            var s, r = Rn.to(e, ba((s = {}, s[t] = "+=0.1", s.paused = !0, s), i || {})),
                o = function (l, c, u) {
                    return r.resetTo(t, l, c, u)
                };
            return o.tween = r, o
        },
        isTweening: function (e) {
            return jt.getTweensOf(e, !0).length > 0
        },
        defaults: function (e) {
            return e && e.ease && (e.ease = ha(e.ease, Nl.ease)), w_(Nl, e || {})
        },
        config: function (e) {
            return w_(Wn, e || {})
        },
        registerEffect: function (e) {
            var t = e.name,
                i = e.effect,
                s = e.plugins,
                r = e.defaults,
                o = e.extendTimeline;
            (s || "").split(",").forEach(function (a) {
                return a && !On[a] && !qn[a] && _u(t + " effect requires " + a + " plugin.")
            }), dp[t] = function (a, l, c) {
                return i(os(a), hs(l || {}, r), c)
            }, o && (un.prototype[t] = function (a, l, c) {
                return this.add(dp[t](a, qs(l) ? l : (c = l) && {}, this), c)
            })
        },
        registerEase: function (e, t) {
            pt[e] = ha(t)
        },
        parseEase: function (e, t) {
            return arguments.length ? ha(e, t) : pt
        },
        getById: function (e) {
            return jt.getById(e)
        },
        exportRoot: function (e, t) {
            e === void 0 && (e = {});
            var i = new un(e),
                s, r;
            for (i.smoothChildTiming = En(e.smoothChildTiming), jt.remove(i), i._dp = 0, i._time = i._tTime = jt._time, s = jt._first; s;) r = s._next, (t || !(!s._dur && s instanceof di && s.vars.onComplete === s._targets[0])) && ks(i, s, s._start - s._delay), s = r;
            return ks(jt, i, 0), i
        },
        context: function (e, t) {
            return e ? new zE(e, t) : qt
        },
        matchMedia: function (e) {
            return new p1(e)
        },
        matchMediaRefresh: function () {
            return fa.forEach(function (e) {
                var t = e.conditions,
                    i, s;
                for (s in t) t[s] && (t[s] = !1, i = 1);
                i && e.revert()
            }) || ag()
        },
        addEventListener: function (e, t) {
            var i = _h[e] || (_h[e] = []);
            ~i.indexOf(t) || i.push(t)
        },
        removeEventListener: function (e, t) {
            var i = _h[e],
                s = i && i.indexOf(t);
            s >= 0 && i.splice(s, 1)
        },
        utils: {
            wrap: qI,
            wrapYoyo: $I,
            distribute: bE,
            random: yE,
            snap: xE,
            normalize: WI,
            getUnit: Xi,
            clamp: zI,
            splitColor: ME,
            toArray: os,
            selector: sg,
            mapRange: wE,
            pipe: HI,
            unitize: VI,
            interpolate: jI,
            shuffle: vE
        },
        install: aE,
        effects: dp,
        ticker: Qn,
        updateRoot: un.updateRoot,
        plugins: On,
        globalTimeline: jt,
        core: {
            PropTween: Cn,
            globals: lE,
            Tween: di,
            Timeline: un,
            Animation: yu,
            getCache: ua,
            _removeLinkedListItem: kf,
            reverting: function () {
                return Ki
            },
            context: function (e) {
                return e && qt && (qt.data.push(e), e._ctx = qt), qt
            },
            suppressOverwrites: function (e) {
                return PA = e
            }
        }
    };
wn("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
    return jh[n] = di[n]
});
Qn.add(un.updateRoot);
dl = jh.to({}, {
    duration: 0
});
var m1 = function (e, t) {
    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;) i = i._next;
    return i
},
    g1 = function (e, t) {
        var i = e._targets,
            s, r, o;
        for (s in t)
            for (r = i.length; r--;) o = e._ptLookup[r][s], o && (o = o.d) && (o._pt && (o = m1(o, s)), o && o.modifier && o.modifier(t[s], e, i[r], s))
    },
    gp = function (e, t) {
        return {
            name: e,
            rawVars: 1,
            init: function (s, r, o) {
                o._onInit = function (a) {
                    var l, c;
                    if (Li(r) && (l = {}, wn(r, function (u) {
                        return l[u] = 1
                    }), r = l), t) {
                        l = {};
                        for (c in r) l[c] = t(r[c]);
                        r = l
                    }
                    g1(a, r)
                }
            }
        }
    },
    Rn = jh.registerPlugin({
        name: "attr",
        init: function (e, t, i, s, r) {
            var o, a, l;
            this.tween = i;
            for (o in t) l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], s, r, 0, 0, o), a.op = o, a.b = l, this._props.push(o)
        },
        render: function (e, t) {
            for (var i = t._pt; i;) Ki ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next
        }
    }, {
        name: "endArray",
        init: function (e, t) {
            for (var i = t.length; i--;) this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
        }
    }, gp("roundProps", rg), gp("modifiers"), gp("snap", xE)) || jh;
di.version = un.version = Rn.version = "3.12.5";
oE = 1;
LA() && Ql();
pt.Power0;
pt.Power1;
pt.Power2;
pt.Power3;
pt.Power4;
pt.Linear;
pt.Quad;
pt.Cubic;
pt.Quart;
pt.Quint;
pt.Strong;
pt.Elastic;
pt.Back;
pt.SteppedEase;
pt.Bounce;
pt.Sine;
pt.Expo;
pt.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var B_, ro, Sl, WA, sa, R_, qA, A1 = function () {
    return typeof window < "u"
},
    Er = {},
    Yo = 180 / Math.PI,
    Ml = Math.PI / 180,
    Da = Math.atan2,
    P_ = 1e8,
    $A = /([A-Z])/g,
    _1 = /(left|right|width|margin|padding|x)/i,
    v1 = /[\s,\(]\S/,
    Os = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    },
    lg = function (e, t) {
        return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
    },
    b1 = function (e, t) {
        return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
    },
    x1 = function (e, t) {
        return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
    },
    y1 = function (e, t) {
        var i = t.s + t.c * e;
        t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
    },
    GE = function (e, t) {
        return t.set(t.t, t.p, e ? t.e : t.b, t)
    },
    HE = function (e, t) {
        return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
    },
    E1 = function (e, t, i) {
        return e.style[t] = i
    },
    w1 = function (e, t, i) {
        return e.style.setProperty(t, i)
    },
    C1 = function (e, t, i) {
        return e._gsap[t] = i
    },
    S1 = function (e, t, i) {
        return e._gsap.scaleX = e._gsap.scaleY = i
    },
    M1 = function (e, t, i, s, r) {
        var o = e._gsap;
        o.scaleX = o.scaleY = i, o.renderTransform(r, o)
    },
    T1 = function (e, t, i, s, r) {
        var o = e._gsap;
        o[t] = i, o.renderTransform(r, o)
    },
    Yt = "transform",
    Sn = Yt + "Origin",
    I1 = function n(e, t) {
        var i = this,
            s = this.target,
            r = s.style,
            o = s._gsap;
        if (e in Er && r) {
            if (this.tfm = this.tfm || {}, e !== "transform") e = Os[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function (a) {
                return i.tfm[a] = ar(s, a)
            }) : this.tfm[e] = o.x ? o[e] : ar(s, e), e === Sn && (this.tfm.zOrigin = o.zOrigin);
            else return Os.transform.split(",").forEach(function (a) {
                return n.call(i, a, t)
            });
            if (this.props.indexOf(Yt) >= 0) return;
            o.svg && (this.svgo = s.getAttribute("data-svg-origin"), this.props.push(Sn, t, "")), e = Yt
        } (r || t) && this.props.push(e, t, r[e])
    },
    VE = function (e) {
        e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
    },
    B1 = function () {
        var e = this.props,
            t = this.target,
            i = t.style,
            s = t._gsap,
            r, o;
        for (r = 0; r < e.length; r += 3) e[r + 1] ? t[e[r]] = e[r + 2] : e[r + 2] ? i[e[r]] = e[r + 2] : i.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace($A, "-$1").toLowerCase());
        if (this.tfm) {
            for (o in this.tfm) s[o] = this.tfm[o];
            s.svg && (s.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = qA(), (!r || !r.isStart) && !i[Yt] && (VE(i), s.zOrigin && i[Sn] && (i[Sn] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1)
        }
    },
    WE = function (e, t) {
        var i = {
            target: e,
            props: [],
            revert: B1,
            save: I1
        };
        return e._gsap || Rn.core.getCache(e), t && t.split(",").forEach(function (s) {
            return i.save(s)
        }), i
    },
    qE, cg = function (e, t) {
        var i = ro.createElementNS ? ro.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : ro.createElement(e);
        return i && i.style ? i : ro.createElement(e)
    },
    Gs = function n(e, t, i) {
        var s = getComputedStyle(e);
        return s[t] || s.getPropertyValue(t.replace($A, "-$1").toLowerCase()) || s.getPropertyValue(t) || !i && n(e, zl(t) || t, 1) || ""
    },
    D_ = "O,Moz,ms,Ms,Webkit".split(","),
    zl = function (e, t, i) {
        var s = t || sa,
            r = s.style,
            o = 5;
        if (e in r && !i) return e;
        for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(D_[o] + e in r););
        return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? D_[o] : "") + e
    },
    ug = function () {
        A1() && window.document && (B_ = window, ro = B_.document, Sl = ro.documentElement, sa = cg("div") || {
            style: {}
        }, cg("div"), Yt = zl(Yt), Sn = Yt + "Origin", sa.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", qE = !!zl("perspective"), qA = Rn.core.reverting, WA = 1)
    },
    Ap = function n(e) {
        var t = cg("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            i = this.parentNode,
            s = this.nextSibling,
            r = this.style.cssText,
            o;
        if (Sl.appendChild(t), t.appendChild(this), this.style.display = "block", e) try {
            o = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = n
        } catch { } else this._gsapBBox && (o = this._gsapBBox());
        return i && (s ? i.insertBefore(this, s) : i.appendChild(this)), Sl.removeChild(t), this.style.cssText = r, o
    },
    L_ = function (e, t) {
        for (var i = t.length; i--;)
            if (e.hasAttribute(t[i])) return e.getAttribute(t[i])
    },
    $E = function (e) {
        var t;
        try {
            t = e.getBBox()
        } catch {
            t = Ap.call(e, !0)
        }
        return t && (t.width || t.height) || e.getBBox === Ap || (t = Ap.call(e, !0)), t && !t.width && !t.x && !t.y ? {
            x: +L_(e, ["x", "cx", "x1"]) || 0,
            y: +L_(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        } : t
    },
    jE = function (e) {
        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && $E(e))
    },
    xa = function (e, t) {
        if (t) {
            var i = e.style,
                s;
            t in Er && t !== Sn && (t = Yt), i.removeProperty ? (s = t.substr(0, 2), (s === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(s === "--" ? t : t.replace($A, "-$1").toLowerCase())) : i.removeAttribute(t)
        }
    },
    oo = function (e, t, i, s, r, o) {
        var a = new Cn(e._pt, t, i, 0, 1, o ? HE : GE);
        return e._pt = a, a.b = s, a.e = r, e._props.push(i), a
    },
    k_ = {
        deg: 1,
        rad: 1,
        turn: 1
    },
    R1 = {
        grid: 1,
        flex: 1
    },
    yo = function n(e, t, i, s) {
        var r = parseFloat(i) || 0,
            o = (i + "").trim().substr((r + "").length) || "px",
            a = sa.style,
            l = _1.test(t),
            c = e.tagName.toLowerCase() === "svg",
            u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
            d = 100,
            h = s === "px",
            f = s === "%",
            m, g, A, p;
        if (s === o || !r || k_[s] || k_[o]) return r;
        if (o !== "px" && !h && (r = n(e, t, i, "px")), p = e.getCTM && jE(e), (f || o === "%") && (Er[t] || ~t.indexOf("adius"))) return m = p ? e.getBBox()[l ? "width" : "height"] : e[u], si(f ? r / m * d : r / 100 * m);
        if (a[l ? "width" : "height"] = d + (h ? o : s), g = ~t.indexOf("adius") || s === "em" && e.appendChild && !c ? e : e.parentNode, p && (g = (e.ownerSVGElement || {}).parentNode), (!g || g === ro || !g.appendChild) && (g = ro.body), A = g._gsap, A && f && A.width && l && A.time === Qn.time && !A.uncache) return si(r / A.width * d);
        if (f && (t === "height" || t === "width")) {
            var v = e.style[t];
            e.style[t] = d + s, m = e[u], v ? e.style[t] = v : xa(e, t)
        } else (f || o === "%") && !R1[Gs(g, "display")] && (a.position = Gs(e, "position")), g === e && (a.position = "static"), g.appendChild(sa), m = sa[u], g.removeChild(sa), a.position = "absolute";
        return l && f && (A = ua(g), A.time = Qn.time, A.width = g[u]), si(h ? m * r / d : m && r ? d / m * r : 0)
    },
    ar = function (e, t, i, s) {
        var r;
        return WA || ug(), t in Os && t !== "transform" && (t = Os[t], ~t.indexOf(",") && (t = t.split(",")[0])), Er[t] && t !== "transform" ? (r = wu(e, s), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Xh(Gs(e, Sn)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || s || ~(r + "").indexOf("calc(")) && (r = Yh[t] && Yh[t](e, t, i) || Gs(e, t) || uE(e, t) || (t === "opacity" ? 1 : 0))), i && !~(r + "").trim().indexOf(" ") ? yo(e, t, r, i) + i : r
    },
    P1 = function (e, t, i, s) {
        if (!i || i === "none") {
            var r = zl(t, e, 1),
                o = r && Gs(e, r, 1);
            o && o !== i ? (t = r, i = o) : t === "borderColor" && (i = Gs(e, "borderTopColor"))
        }
        var a = new Cn(this._pt, e.style, t, 0, 1, UE),
            l = 0,
            c = 0,
            u, d, h, f, m, g, A, p, v, _, b, w;
        if (a.b = i, a.e = s, i += "", s += "", s === "auto" && (g = e.style[t], e.style[t] = s, s = Gs(e, t) || s, g ? e.style[t] = g : xa(e, t)), u = [i, s], IE(u), i = u[0], s = u[1], h = i.match(ul) || [], w = s.match(ul) || [], w.length) {
            for (; d = ul.exec(s);) A = d[0], v = s.substring(l, d.index), m ? m = (m + 1) % 5 : (v.substr(-5) === "rgba(" || v.substr(-5) === "hsla(") && (m = 1), A !== (g = h[c++] || "") && (f = parseFloat(g) || 0, b = g.substr((f + "").length), A.charAt(1) === "=" && (A = Cl(f, A) + b), p = parseFloat(A), _ = A.substr((p + "").length), l = ul.lastIndex - _.length, _ || (_ = _ || Wn.units[t] || b, l === s.length && (s += _, a.e += _)), b !== _ && (f = yo(e, t, g, _) || 0), a._pt = {
                _next: a._pt,
                p: v || c === 1 ? v : ",",
                s: f,
                c: p - f,
                m: m && m < 4 || t === "zIndex" ? Math.round : 0
            });
            a.c = l < s.length ? s.substring(l, s.length) : ""
        } else a.r = t === "display" && s === "none" ? HE : GE;
        return sE.test(s) && (a.e = 0), this._pt = a, a
    },
    F_ = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    },
    D1 = function (e) {
        var t = e.split(" "),
            i = t[0],
            s = t[1] || "50%";
        return (i === "top" || i === "bottom" || s === "left" || s === "right") && (e = i, i = s, s = e), t[0] = F_[i] || i, t[1] = F_[s] || s, t.join(" ")
    },
    L1 = function (e, t) {
        if (t.tween && t.tween._time === t.tween._dur) {
            var i = t.t,
                s = i.style,
                r = t.u,
                o = i._gsap,
                a, l, c;
            if (r === "all" || r === !0) s.cssText = "", l = 1;
            else
                for (r = r.split(","), c = r.length; --c > -1;) a = r[c], Er[a] && (l = 1, a = a === "transformOrigin" ? Sn : Yt), xa(i, a);
            l && (xa(i, Yt), o && (o.svg && i.removeAttribute("transform"), wu(i, 1), o.uncache = 1, VE(s)))
        }
    },
    Yh = {
        clearProps: function (e, t, i, s, r) {
            if (r.data !== "isFromStart") {
                var o = e._pt = new Cn(e._pt, t, i, 0, 0, L1);
                return o.u = s, o.pr = -10, o.tween = r, e._props.push(i), 1
            }
        }
    },
    Eu = [1, 0, 0, 1, 0, 0],
    YE = {},
    XE = function (e) {
        return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
    },
    N_ = function (e) {
        var t = Gs(e, Yt);
        return XE(t) ? Eu : t.substr(7).match(nE).map(si)
    },
    jA = function (e, t) {
        var i = e._gsap || ua(e),
            s = e.style,
            r = N_(e),
            o, a, l, c;
        return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, r = [l.a, l.b, l.c, l.d, l.e, l.f], r.join(",") === "1,0,0,1,0,0" ? Eu : r) : (r === Eu && !e.offsetParent && e !== Sl && !i.svg && (l = s.display, s.display = "block", o = e.parentNode, (!o || !e.offsetParent) && (c = 1, a = e.nextElementSibling, Sl.appendChild(e)), r = N_(e), l ? s.display = l : xa(e, "display"), c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Sl.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r)
    },
    dg = function (e, t, i, s, r, o) {
        var a = e._gsap,
            l = r || jA(e, !0),
            c = a.xOrigin || 0,
            u = a.yOrigin || 0,
            d = a.xOffset || 0,
            h = a.yOffset || 0,
            f = l[0],
            m = l[1],
            g = l[2],
            A = l[3],
            p = l[4],
            v = l[5],
            _ = t.split(" "),
            b = parseFloat(_[0]) || 0,
            w = parseFloat(_[1]) || 0,
            E, C, S, x;
        i ? l !== Eu && (C = f * A - m * g) && (S = b * (A / C) + w * (-g / C) + (g * v - A * p) / C, x = b * (-m / C) + w * (f / C) - (f * v - m * p) / C, b = S, w = x) : (E = $E(e), b = E.x + (~_[0].indexOf("%") ? b / 100 * E.width : b), w = E.y + (~(_[1] || _[0]).indexOf("%") ? w / 100 * E.height : w)), s || s !== !1 && a.smooth ? (p = b - c, v = w - u, a.xOffset = d + (p * f + v * g) - p, a.yOffset = h + (p * m + v * A) - v) : a.xOffset = a.yOffset = 0, a.xOrigin = b, a.yOrigin = w, a.smooth = !!s, a.origin = t, a.originIsAbsolute = !!i, e.style[Sn] = "0px 0px", o && (oo(o, a, "xOrigin", c, b), oo(o, a, "yOrigin", u, w), oo(o, a, "xOffset", d, a.xOffset), oo(o, a, "yOffset", h, a.yOffset)), e.setAttribute("data-svg-origin", b + " " + w)
    },
    wu = function (e, t) {
        var i = e._gsap || new DE(e);
        if ("x" in i && !t && !i.uncache) return i;
        var s = e.style,
            r = i.scaleX < 0,
            o = "px",
            a = "deg",
            l = getComputedStyle(e),
            c = Gs(e, Sn) || "0",
            u, d, h, f, m, g, A, p, v, _, b, w, E, C, S, x, y, P, T, R, D, U, Q, F, L, W, k, $, X, le, K, te;
        return u = d = h = g = A = p = v = _ = b = 0, f = m = 1, i.svg = !!(e.getCTM && jE(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (s[Yt] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Yt] !== "none" ? l[Yt] : "")), s.scale = s.rotate = s.translate = "none"), C = jA(e, i.svg), i.svg && (i.uncache ? (L = e.getBBox(), c = i.xOrigin - L.x + "px " + (i.yOrigin - L.y) + "px", F = "") : F = !t && e.getAttribute("data-svg-origin"), dg(e, F || c, !!F || i.originIsAbsolute, i.smooth !== !1, C)), w = i.xOrigin || 0, E = i.yOrigin || 0, C !== Eu && (P = C[0], T = C[1], R = C[2], D = C[3], u = U = C[4], d = Q = C[5], C.length === 6 ? (f = Math.sqrt(P * P + T * T), m = Math.sqrt(D * D + R * R), g = P || T ? Da(T, P) * Yo : 0, v = R || D ? Da(R, D) * Yo + g : 0, v && (m *= Math.abs(Math.cos(v * Ml))), i.svg && (u -= w - (w * P + E * R), d -= E - (w * T + E * D))) : (te = C[6], le = C[7], k = C[8], $ = C[9], X = C[10], K = C[11], u = C[12], d = C[13], h = C[14], S = Da(te, X), A = S * Yo, S && (x = Math.cos(-S), y = Math.sin(-S), F = U * x + k * y, L = Q * x + $ * y, W = te * x + X * y, k = U * -y + k * x, $ = Q * -y + $ * x, X = te * -y + X * x, K = le * -y + K * x, U = F, Q = L, te = W), S = Da(-R, X), p = S * Yo, S && (x = Math.cos(-S), y = Math.sin(-S), F = P * x - k * y, L = T * x - $ * y, W = R * x - X * y, K = D * y + K * x, P = F, T = L, R = W), S = Da(T, P), g = S * Yo, S && (x = Math.cos(S), y = Math.sin(S), F = P * x + T * y, L = U * x + Q * y, T = T * x - P * y, Q = Q * x - U * y, P = F, U = L), A && Math.abs(A) + Math.abs(g) > 359.9 && (A = g = 0, p = 180 - p), f = si(Math.sqrt(P * P + T * T + R * R)), m = si(Math.sqrt(Q * Q + te * te)), S = Da(U, Q), v = Math.abs(S) > 2e-4 ? S * Yo : 0, b = K ? 1 / (K < 0 ? -K : K) : 0), i.svg && (F = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !XE(Gs(e, Yt)), F && e.setAttribute("transform", F))), Math.abs(v) > 90 && Math.abs(v) < 270 && (r ? (f *= -1, v += g <= 0 ? 180 : -180, g += g <= 0 ? 180 : -180) : (m *= -1, v += v <= 0 ? 180 : -180)), t = t || i.uncache, i.x = u - ((i.xPercent = u && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + o, i.y = d - ((i.yPercent = d && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + o, i.z = h + o, i.scaleX = si(f), i.scaleY = si(m), i.rotation = si(g) + a, i.rotationX = si(A) + a, i.rotationY = si(p) + a, i.skewX = v + a, i.skewY = _ + a, i.transformPerspective = b + o, (i.zOrigin = parseFloat(c.split(" ")[2]) || !t && i.zOrigin || 0) && (s[Sn] = Xh(c)), i.xOffset = i.yOffset = 0, i.force3D = Wn.force3D, i.renderTransform = i.svg ? F1 : qE ? KE : k1, i.uncache = 0, i
    },
    Xh = function (e) {
        return (e = e.split(" "))[0] + " " + e[1]
    },
    _p = function (e, t, i) {
        var s = Xi(t);
        return si(parseFloat(t) + parseFloat(yo(e, "x", i + "px", s))) + s
    },
    k1 = function (e, t) {
        t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, KE(e, t)
    },
    Oo = "0deg",
    cc = "0px",
    Uo = ") ",
    KE = function (e, t) {
        var i = t || this,
            s = i.xPercent,
            r = i.yPercent,
            o = i.x,
            a = i.y,
            l = i.z,
            c = i.rotation,
            u = i.rotationY,
            d = i.rotationX,
            h = i.skewX,
            f = i.skewY,
            m = i.scaleX,
            g = i.scaleY,
            A = i.transformPerspective,
            p = i.force3D,
            v = i.target,
            _ = i.zOrigin,
            b = "",
            w = p === "auto" && e && e !== 1 || p === !0;
        if (_ && (d !== Oo || u !== Oo)) {
            var E = parseFloat(u) * Ml,
                C = Math.sin(E),
                S = Math.cos(E),
                x;
            E = parseFloat(d) * Ml, x = Math.cos(E), o = _p(v, o, C * x * -_), a = _p(v, a, -Math.sin(E) * -_), l = _p(v, l, S * x * -_ + _)
        }
        A !== cc && (b += "perspective(" + A + Uo), (s || r) && (b += "translate(" + s + "%, " + r + "%) "), (w || o !== cc || a !== cc || l !== cc) && (b += l !== cc || w ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + Uo), c !== Oo && (b += "rotate(" + c + Uo), u !== Oo && (b += "rotateY(" + u + Uo), d !== Oo && (b += "rotateX(" + d + Uo), (h !== Oo || f !== Oo) && (b += "skew(" + h + ", " + f + Uo), (m !== 1 || g !== 1) && (b += "scale(" + m + ", " + g + Uo), v.style[Yt] = b || "translate(0, 0)"
    },
    F1 = function (e, t) {
        var i = t || this,
            s = i.xPercent,
            r = i.yPercent,
            o = i.x,
            a = i.y,
            l = i.rotation,
            c = i.skewX,
            u = i.skewY,
            d = i.scaleX,
            h = i.scaleY,
            f = i.target,
            m = i.xOrigin,
            g = i.yOrigin,
            A = i.xOffset,
            p = i.yOffset,
            v = i.forceCSS,
            _ = parseFloat(o),
            b = parseFloat(a),
            w, E, C, S, x;
        l = parseFloat(l), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, l += u), l || c ? (l *= Ml, c *= Ml, w = Math.cos(l) * d, E = Math.sin(l) * d, C = Math.sin(l - c) * -h, S = Math.cos(l - c) * h, c && (u *= Ml, x = Math.tan(c - u), x = Math.sqrt(1 + x * x), C *= x, S *= x, u && (x = Math.tan(u), x = Math.sqrt(1 + x * x), w *= x, E *= x)), w = si(w), E = si(E), C = si(C), S = si(S)) : (w = d, S = h, E = C = 0), (_ && !~(o + "").indexOf("px") || b && !~(a + "").indexOf("px")) && (_ = yo(f, "x", o, "px"), b = yo(f, "y", a, "px")), (m || g || A || p) && (_ = si(_ + m - (m * w + g * C) + A), b = si(b + g - (m * E + g * S) + p)), (s || r) && (x = f.getBBox(), _ = si(_ + s / 100 * x.width), b = si(b + r / 100 * x.height)), x = "matrix(" + w + "," + E + "," + C + "," + S + "," + _ + "," + b + ")", f.setAttribute("transform", x), v && (f.style[Yt] = x)
    },
    N1 = function (e, t, i, s, r) {
        var o = 360,
            a = Li(r),
            l = parseFloat(r) * (a && ~r.indexOf("rad") ? Yo : 1),
            c = l - s,
            u = s + c + "deg",
            d, h;
        return a && (d = r.split("_")[1], d === "short" && (c %= o, c !== c % (o / 2) && (c += c < 0 ? o : -o)), d === "cw" && c < 0 ? c = (c + o * P_) % o - ~~(c / o) * o : d === "ccw" && c > 0 && (c = (c - o * P_) % o - ~~(c / o) * o)), e._pt = h = new Cn(e._pt, t, i, s, c, b1), h.e = u, h.u = "deg", e._props.push(i), h
    },
    O_ = function (e, t) {
        for (var i in t) e[i] = t[i];
        return e
    },
    O1 = function (e, t, i) {
        var s = O_({}, i._gsap),
            r = "perspective,force3D,transformOrigin,svgOrigin",
            o = i.style,
            a, l, c, u, d, h, f, m;
        s.svg ? (c = i.getAttribute("transform"), i.setAttribute("transform", ""), o[Yt] = t, a = wu(i, 1), xa(i, Yt), i.setAttribute("transform", c)) : (c = getComputedStyle(i)[Yt], o[Yt] = t, a = wu(i, 1), o[Yt] = c);
        for (l in Er) c = s[l], u = a[l], c !== u && r.indexOf(l) < 0 && (f = Xi(c), m = Xi(u), d = f !== m ? yo(i, l, c, m) : parseFloat(c), h = parseFloat(u), e._pt = new Cn(e._pt, a, l, d, h - d, lg), e._pt.u = m || 0, e._props.push(l));
        O_(a, s)
    };
wn("padding,margin,Width,Radius", function (n, e) {
    var t = "Top",
        i = "Right",
        s = "Bottom",
        r = "Left",
        o = (e < 3 ? [t, i, s, r] : [t + r, t + i, s + i, s + r]).map(function (a) {
            return e < 2 ? n + a : "border" + a + n
        });
    Yh[e > 1 ? "border" + n : n] = function (a, l, c, u, d) {
        var h, f;
        if (arguments.length < 4) return h = o.map(function (m) {
            return ar(a, m, c)
        }), f = h.join(" "), f.split(h[0]).length === 5 ? h[0] : f;
        h = (u + "").split(" "), f = {}, o.forEach(function (m, g) {
            return f[m] = h[g] = h[g] || h[(g - 1) / 2 | 0]
        }), a.init(l, f, d)
    }
});
var JE = {
    name: "css",
    register: ug,
    targetTest: function (e) {
        return e.style && e.nodeType
    },
    init: function (e, t, i, s, r) {
        var o = this._props,
            a = e.style,
            l = i.vars.startAt,
            c, u, d, h, f, m, g, A, p, v, _, b, w, E, C, S;
        WA || ug(), this.styles = this.styles || WE(e), S = this.styles.props, this.tween = i;
        for (g in t)
            if (g !== "autoRound" && (u = t[g], !(On[g] && LE(g, t, i, s, e, r)))) {
                if (f = typeof u, m = Yh[g], f === "function" && (u = u.call(i, s, e, r), f = typeof u), f === "string" && ~u.indexOf("random(") && (u = bu(u)), m) m(this, e, g, u, i) && (C = 1);
                else if (g.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(g) + "").trim(), u += "", mo.lastIndex = 0, mo.test(c) || (A = Xi(c), p = Xi(u)), p ? A !== p && (c = yo(e, g, c, p) + p) : A && (u += A), this.add(a, "setProperty", c, u, s, r, 0, 0, g), o.push(g), S.push(g, 0, a[g]);
                else if (f !== "undefined") {
                    if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(i, s, e, r) : l[g], Li(c) && ~c.indexOf("random(") && (c = bu(c)), Xi(c + "") || c === "auto" || (c += Wn.units[g] || Xi(ar(e, g)) || ""), (c + "").charAt(1) === "=" && (c = ar(e, g))) : c = ar(e, g), h = parseFloat(c), v = f === "string" && u.charAt(1) === "=" && u.substr(0, 2), v && (u = u.substr(2)), d = parseFloat(u), g in Os && (g === "autoAlpha" && (h === 1 && ar(e, "visibility") === "hidden" && d && (h = 0), S.push("visibility", 0, a.visibility), oo(this, a, "visibility", h ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), g !== "scale" && g !== "transform" && (g = Os[g], ~g.indexOf(",") && (g = g.split(",")[0]))), _ = g in Er, _) {
                        if (this.styles.save(g), b || (w = e._gsap, w.renderTransform && !t.parseTransform || wu(e, t.parseTransform), E = t.smoothOrigin !== !1 && w.smooth, b = this._pt = new Cn(this._pt, a, Yt, 0, 1, w.renderTransform, w, 0, -1), b.dep = 1), g === "scale") this._pt = new Cn(this._pt, w, "scaleY", w.scaleY, (v ? Cl(w.scaleY, v + d) : d) - w.scaleY || 0, lg), this._pt.u = 0, o.push("scaleY", g), g += "X";
                        else if (g === "transformOrigin") {
                            S.push(Sn, 0, a[Sn]), u = D1(u), w.svg ? dg(e, u, 0, E, 0, this) : (p = parseFloat(u.split(" ")[2]) || 0, p !== w.zOrigin && oo(this, w, "zOrigin", w.zOrigin, p), oo(this, a, g, Xh(c), Xh(u)));
                            continue
                        } else if (g === "svgOrigin") {
                            dg(e, u, 1, E, 0, this);
                            continue
                        } else if (g in YE) {
                            N1(this, w, g, h, v ? Cl(h, v + u) : u);
                            continue
                        } else if (g === "smoothOrigin") {
                            oo(this, w, "smooth", w.smooth, u);
                            continue
                        } else if (g === "force3D") {
                            w[g] = u;
                            continue
                        } else if (g === "transform") {
                            O1(this, u, e);
                            continue
                        }
                    } else g in a || (g = zl(g) || g);
                    if (_ || (d || d === 0) && (h || h === 0) && !v1.test(u) && g in a) A = (c + "").substr((h + "").length), d || (d = 0), p = Xi(u) || (g in Wn.units ? Wn.units[g] : A), A !== p && (h = yo(e, g, c, p)), this._pt = new Cn(this._pt, _ ? w : a, g, h, (v ? Cl(h, v + d) : d) - h, !_ && (p === "px" || g === "zIndex") && t.autoRound !== !1 ? y1 : lg), this._pt.u = p || 0, A !== p && p !== "%" && (this._pt.b = c, this._pt.r = x1);
                    else if (g in a) P1.call(this, e, g, c, v ? v + u : u);
                    else if (g in e) this.add(e, g, c || e[g], v ? v + u : u, s, r);
                    else if (g !== "parseTransform") {
                        FA(g, u);
                        continue
                    }
                    _ || (g in a ? S.push(g, 0, a[g]) : S.push(g, 1, c || e[g])), o.push(g)
                }
            }
        C && QE(this)
    },
    render: function (e, t) {
        if (t.tween._time || !qA())
            for (var i = t._pt; i;) i.r(e, i.d), i = i._next;
        else t.styles.revert()
    },
    get: ar,
    aliases: Os,
    getSetter: function (e, t, i) {
        var s = Os[t];
        return s && s.indexOf(",") < 0 && (t = s), t in Er && t !== Sn && (e._gsap.x || ar(e, "x")) ? i && R_ === i ? t === "scale" ? S1 : C1 : (R_ = i || {}) && (t === "scale" ? M1 : T1) : e.style && !DA(e.style[t]) ? E1 : ~t.indexOf("-") ? w1 : HA(e, t)
    },
    core: {
        _removeProperty: xa,
        _getMatrix: jA
    }
};
Rn.utils.checkPrefix = zl;
Rn.core.getStyleSaver = WE;
(function (n, e, t, i) {
    var s = wn(n + "," + e + "," + t, function (r) {
        Er[r] = 1
    });
    wn(e, function (r) {
        Wn.units[r] = "deg", YE[r] = 1
    }), Os[s[13]] = n + "," + e, wn(i, function (r) {
        var o = r.split(":");
        Os[o[1]] = s[o[0]]
    })
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
wn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (n) {
    Wn.units[n] = "px"
});
Rn.registerPlugin(JE);
var bt = Rn.registerPlugin(JE) || Rn;
bt.core.Tween;
const ki = (n, e) => {
    const t = n.__vccOpts || n;
    for (const [i, s] of e) t[i] = s;
    return t
},
    U1 = {
        name: "AppHeaderPaginationList",
        props: {
            paginationList: {
                type: Array,
                required: !0
            },
            currentSectionId: {
                type: String,
                required: !0
            }
        },
        emits: ["go-to-section"],
        computed: {
            ...fs(gn, ["breakpoints"])
        },
        mounted() {
            setTimeout(this.createTimeline, 0)
        },
        methods: {
            createTimeline() {
                const {
                    paginationList: n
                } = this.$refs;
                let e, t;
                bt.matchMedia().add(`(min-width: ${this.breakpoints.xl + .5}px)`, () => {
                    e = bt.timeline({
                        scrollTrigger: {
                            trigger: ".app-footer",
                            start: "top bottom",
                            end: "+=200",
                            markers: !1,
                            scrub: !0,
                            onEnter: this.onEnter,
                            onLeaveBack: this.onLeaveBack
                        }
                    }), e.to(n, {
                        autoAlpha: 0
                    })
                }), window.addEventListener("resize", () => {
                    clearTimeout(t), t = setTimeout(() => {
                        var s;
                        (s = e == null ? void 0 : e.scrollTrigger) == null || s.refresh()
                    }, 300)
                })
            }
        }
    },
    Q1 = {
        class: "app-header-pagination"
    },
    z1 = {
        class: "app-header-pagination__container container"
    },
    G1 = {
        ref: "paginationList",
        class: "app-header-pagination__list list-unstyled"
    },
    H1 = ["href", "aria-label", "onClick"];

function V1(n, e, t, i, s, r) {
    return Ge(), st("div", Q1, [ie("div", z1, [ie("ul", G1, [(Ge(!0), st(Bt, null, xn(t.paginationList, (o, a) => (Ge(), st("li", {
        key: a,
        class: xr([{
            active: o.sectionId === t.currentSectionId
        }, "app-header-pagination__item"])
    }, [ie("a", {
        href: `/#${o.sectionId}`,
        "aria-label": o.title,
        class: "app-header-pagination__item-link",
        onClick: cI(l => n.$emit("go-to-section", o.sectionId), ["prevent"])
    }, Pi(a + 1 < 10 ? `0${a + 1}` : a + 1), 9, H1)], 2))), 128))], 512)])])
}
const W1 = ki(U1, [
    ["render", V1]
]),
    q1 = "/assets/frame-BfUAVJ8O.png",
    $1 = "/assets/logo-D1_BmBrL.svg",
    j1 = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M3.66668%2010C4.24978%209.99829%204.81083%209.77692%205.23801%209.38002L9.41134%2011.7647C9.12229%2012.8942%209.70633%2014.0646%2010.7827%2014.5128C11.859%2014.961%2013.1011%2014.551%2013.6992%2013.5502C14.2972%2012.5494%2014.0698%2011.2612%2013.1652%2010.5257C12.2605%209.79018%2010.9531%209.83035%2010.0953%2010.62L5.92201%208.23536C5.96576%208.06805%205.98993%207.89624%205.99401%207.72336L10.0947%205.38002C10.9086%206.11998%2012.1296%206.18859%2013.0213%205.54447C13.913%204.90036%2014.2316%203.71965%2013.7849%202.71441C13.3382%201.70918%2012.2484%201.15429%2011.1728%201.3844C10.0971%201.6145%209.32968%202.56668%209.33334%203.66669C9.33573%203.85874%209.36193%204.04976%209.41134%204.23536L5.62201%206.40002C5.01501%205.46097%203.82716%205.08453%202.79008%205.50256C1.75301%205.92059%201.15827%207.01557%201.37219%208.11308C1.5861%209.21058%202.54852%2010.0021%203.66668%2010Z'%20fill='white'/%3e%3c/svg%3e",
    Y1 = {
        name: "AppHeader",
        components: {
            AppHeaderPagination: W1
        },
        emits: ["go-to-section"],
        data: () => ({
            isMenuOpen: !1,
            items: [],
            social: Zy,
            menu: y_.menu,
            paginationList: y_.pagination_list
        }),
        watch: {
            preloaderIsShown() {
                this.startAnimation()
            }
        },
        computed: {
            ...fs(gn, ["preloaderIsShown", "currentSectionId"])
        },
        mounted() {
            this.$nextTick(() => {
                var e;
                const n = ((e = this.$refs.menu) == null ? void 0 : e.children) || [];
                this.items = Array(...n), this.items.forEach((t, i) => {
                    bt.set(t, {
                        y: -20,
                        opacity: 0
                    })
                })
            }), window.addEventListener("resize", this.toggleMobileMenu.bind(this, !1))
        },
        methods: {
            startAnimation() {
                this.items.forEach((e, t) => {
                    bt.to(e, {
                        y: 0,
                        duration: 1,
                        opacity: 1,
                        delay: (t + 1) * .2
                    })
                })
            },
            toggleMobileMenu(n = null) {
                typeof n != "boolean" ? this.isMenuOpen = !this.isMenuOpen : this.isMenuOpen = n, this.isMenuOpen ? document.documentElement.classList.add("menu-opened") : document.documentElement.classList.remove("menu-opened")
            }
        }
    },
    X1 = {
        class: "app-header__content"
    },
    K1 = ie("div", {
        class: "app-header__frame"
    }, [ie("img", {
        class: "app-header__frame-image",
        src: q1,
        alt: "frame"
    })], -1),
    J1 = ie("div", {
        class: "app-header__logo"
    }, [ie("img", {
        class: "app-header__logo-icon",
        src: $1,
        alt: "logo"
    })], -1),
    Z1 = {
        class: "app-header__burger-text"
    },
    eB = {
        key: 0,
        class: "text"
    },
    tB = {
        key: 1,
        class: "text"
    },
    iB = ie("div", {
        class: "app-header__burger-icon"
    }, [ie("div")], -1),
    nB = {
        class: "app-header__wrap-menu",
        "data-lenis-prevent": ""
    },
    sB = {
        ref: "menu",
        class: "app-header__menu list-unstyled"
    },
    rB = ["onClick"],
    oB = ["href"],
    aB = {
        class: "app-header__follow"
    },
    lB = ie("div", {
        class: "app-header__follow-head"
    }, "Follow us", -1),
    cB = {
        class: "app-header__follow-list"
    },
    uB = ie("img", {
        class: "app-header__follow-share",
        src: j1,
        alt: "share"
    }, null, -1),
    dB = {
        class: "app-header__follow-wrap"
    },
    hB = ["href"],
    fB = ["src", "alt"];

function pB(n, e, t, i, s, r) {
    const o = Mt("app-header-pagination");
    return Ge(), st("header", {
        class: xr(["app-header", {
            "menu-opened": n.isMenuOpen
        }])
    }, [ie("div", X1, [K1, gt(o, {
        "pagination-list": n.paginationList,
        "current-section-id": n.currentSectionId,
        onGoToSection: e[0] || (e[0] = a => n.$emit("go-to-section", a))
    }, null, 8, ["pagination-list", "current-section-id"]), J1, ie("button", {
        class: "app-header__burger button",
        onClick: e[1] || (e[1] = (...a) => r.toggleMobileMenu && r.toggleMobileMenu(...a))
    }, [ie("div", Z1, [gt(BA, {
        name: "slide",
        mode: "out-in"
    }, {
        default: Ts(() => [n.isMenuOpen ? (Ge(), st("p", eB, "close")) : (Ge(), st("p", tB, "menu"))]),
        _: 1
    })]), iB]), ie("div", nB, [ie("ul", sB, [(Ge(!0), st(Bt, null, xn(n.menu, (a, l) => (Ge(), st("li", {
        key: l,
        class: "app-header__menu-item"
    }, [a.sectionId ? (Ge(), st("button", {
        key: 0,
        class: "app-header__menu-link",
        onClick: c => n.$emit("go-to-section", a.sectionId)
    }, Pi(a.title), 9, rB)) : (Ge(), st("a", {
        key: 1,
        href: a.url,
        class: "app-header__menu-link"
    }, Pi(a.title), 9, oB))]))), 128))], 512), ie("div", aB, [lB, ie("div", cB, [uB, ie("div", dB, [(Ge(!0), st(Bt, null, xn(n.social, (a, l) => (Ge(), st("a", {
        href: a.url,
        key: l,
        class: "app-header__follow-link"
    }, [ie("img", {
        src: a.icon,
        alt: a.title,
        class: "app-header__follow-img"
    }, null, 8, fB)], 8, hB))), 128))])])])])])], 2)
}
const mB = ki(Y1, [
    ["render", pB]
]),
    gB = [{
        title: "Axelar ITS",
        url: "https://axelar.network/its",
        target: "_blank"
    }, {
        title: "Audits",
        url: "https://github.com/axelarnetwork/audits",
        target: "_blank"
    }, {
        title: "Solana Bridge",
        url: "https://portalbridge.com/advanced-tools/#/transfer",
        target: "_blank"
    }, {
        title: "Github",
        url: "https://github.com/anyinu",
        target: "_blank"
    }, {
        title: "EVM Bridge",
        url: "https://interchain.axelar.dev/ethereum/0x2598c30330D5771AE9F983979209486aE26dE875",
        target: "_blank"
    }, {
        title: "Galxe",
        url: "https://galxe.com/EBJ7hNkFmGEYocHtmx66iF",
        target: "_blank"
    }, {
        title: "Bitcoin Bridge",
        url: "https://www.anyinu.xyz/#",
        target: "_blank"
    }, {
        title: "Docs",
        url: "https://docs.anyinu.xyz/",
        target: "_blank"
    }, {
        title: "Squid Router",
        url: "https://v2.app.squidrouter.com/",
        target: "_blank"
    }, {
        title: "Opensea",
        url: "https://www.anyinu.xyz/#",
        target: "_blank"
    }],
    AB = {
        menu: gB
    },
    _B = "/assets/footer-logo-BibTmnqO.png",
    vB = "/images/icons/icon-blue-mail.svg",
    bB = {
        name: "AppFooter",
        data: () => ({
            menu: AB.menu,
            social: Zy
        })
    },
    xB = {
        class: "app-footer"
    },
    yB = {
        class: "app-footer__container container"
    },
    EB = {
        class: "app-footer__content"
    },
    wB = xT('<div class="app-footer__logo"><div class="app-footer__logo-image"><img src="' + _B + '" alt="logo"></div></div><div class="app-footer__contact right"><h2 class="app-footer__contact-title">Contact Us</h2><a href="mailto:anyinucoin@gmail.com" class="app-footer__contact-item font-fira-code"><img class="icon" src="' + vB + '" alt=""> anyinucoin@gmail.com </a></div>', 2),
    CB = {
        class: "app-footer__menu"
    },
    SB = ie("h2", {
        class: "app-footer__menu-title"
    }, "Other useful links:", -1),
    MB = {
        key: 0,
        class: "app-footer__menu-list list-unstyled"
    },
    TB = ["href", "target"],
    IB = ie("h2", {
        class: "app-footer__title right"
    }, "Any Inu", -1),
    BB = {
        class: "app-footer__bottom"
    },
    RB = ie("p", {
        class: "app-footer__info"
    }, "© 2024 Any Inu - The Alpha Dog of Crypto.", -1),
    PB = {
        class: "app-footer__social-list list-unstyled"
    },
    DB = ["href", "aria-label"],
    LB = ["src", "alt"],
    kB = ie("p", {
        class: "app-footer__copyright right"
    }, " All rights reserved, but belly rubs are free! ", -1);

function FB(n, e, t, i, s, r) {
    return Ge(), st("footer", xB, [ie("div", yB, [ie("div", EB, [wB, ie("div", CB, [SB, n.menu && n.menu.length ? (Ge(), st("ul", MB, [(Ge(!0), st(Bt, null, xn(n.menu, (o, a) => (Ge(), st("li", {
        class: "app-footer__menu-item",
        key: a
    }, [ie("a", {
        href: o.url,
        target: o.target,
        class: "app-footer__menu-link uppercase"
    }, Pi(o.title), 9, TB)]))), 128))])) : Sc("", !0)]), IB]), ie("div", BB, [RB, ie("ul", PB, [(Ge(!0), st(Bt, null, xn(n.social, (o, a) => (Ge(), st("li", {
        class: "app-footer__social-item",
        key: a
    }, [ie("a", {
        href: o.url,
        class: "app-footer__social-link",
        "aria-label": o.title
    }, [ie("img", {
        src: o.icon,
        alt: o.title
    }, null, 8, LB)], 8, DB)]))), 128))]), kB])])])
}
const NB = ki(bB, [
    ["render", FB]
]),
    OB = {
        name: "AppPreloader",
        data: () => ({
            percent: 0,
            timeout: null
        }),
        computed: {
            ...fs(gn, ["preloaderIsShown"])
        },
        created() {
            this.animatePercent(Math.round(Math.random() * 98)), window.addEventListener("app:models-loaded", () => {
                clearTimeout(this.timeout), document.documentElement.classList.remove("preloader-shown"), this.animatePercent(100), setTimeout(() => {
                    this.hidePreloader()
                }, 1e3)
            }, {
                once: !0
            })
        },
        methods: {
            ...RA(gn, ["hidePreloader"]),
            lerp(n, e, t) {
                return (1 - t) * n + t * e
            },
            animatePercent(n) {
                let t = null;
                const i = s => {
                    t || (t = s);
                    const o = ((s - t) / 1e3).toFixed(3);
                    o < 1 ? (this.percent = Math.floor(this.lerp(this.percent, n, o)), requestAnimationFrame(i)) : this.percent = n
                };
                requestAnimationFrame(i)
            }
        }
    },
    UB = {
        class: "app-preloader__percent"
    },
    QB = {
        class: "app-preloader__loader",
        viewBox: "0 0 36 36"
    },
    zB = ie("path", {
        d: `M18 2.0845
                    a 15.9155 15.9155 0 0 1 0 31.831
                    a 15.9155 15.9155 0 0 1 0 -31.831`,
        fill: "none",
        stroke: "#55CAFC",
        "stroke-width": "0.2",
        "stroke-opacity": "0.4"
    }, null, -1),
    GB = ["stroke-dashoffset"];

function HB(n, e, t, i, s, r) {
    return Ge(), st("div", {
        class: xr(["app-preloader", {
            hide: !n.preloaderIsShown
        }])
    }, [ie("p", UB, Pi(n.percent) + "%", 1), (Ge(), st("svg", QB, [zB, ie("path", {
        d: `M18 2.0845
                    a 15.9155 15.9155 0 0 1 0 31.831
                    a 15.9155 15.9155 0 0 1 0 -31.831`,
        fill: "none",
        stroke: "#55CAFC",
        "stroke-opacity": "0.8",
        "stroke-width": "0.2",
        "stroke-dasharray": "100, 100",
        "stroke-dashoffset": `-${100 + n.percent}`
    }, null, 8, GB)]))], 2)
}
const VB = ki(OB, [
    ["render", HB]
]);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const YA = "163",
    La = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    ka = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    WB = 0,
    U_ = 1,
    qB = 2,
    ZE = 1,
    $B = 2,
    sr = 3,
    wr = 0,
    Mn = 1,
    Fs = 2,
    Hs = 0,
    Tl = 1,
    Kh = 2,
    Q_ = 3,
    z_ = 4,
    jB = 5,
    ta = 100,
    YB = 101,
    XB = 102,
    KB = 103,
    JB = 104,
    ZB = 200,
    eR = 201,
    tR = 202,
    iR = 203,
    hg = 204,
    fg = 205,
    nR = 206,
    sR = 207,
    rR = 208,
    oR = 209,
    aR = 210,
    lR = 211,
    cR = 212,
    uR = 213,
    dR = 214,
    hR = 0,
    fR = 1,
    pR = 2,
    Jh = 3,
    mR = 4,
    gR = 5,
    AR = 6,
    _R = 7,
    XA = 0,
    vR = 1,
    bR = 2,
    _r = 0,
    KA = 1,
    JA = 2,
    ZA = 3,
    e0 = 4,
    xR = 5,
    t0 = 6,
    Zh = 7,
    G_ = "attached",
    yR = "detached",
    ew = 300,
    ya = 301,
    Gl = 302,
    pg = 303,
    mg = 304,
    Of = 306,
    Eo = 1e3,
    pn = 1001,
    ef = 1002,
    Kt = 1003,
    tw = 1004,
    Ic = 1005,
    Pt = 1006,
    vh = 1007,
    ys = 1008,
    hi = 1009,
    ER = 1010,
    wR = 1011,
    iw = 1012,
    nw = 1013,
    Hl = 1014,
    ei = 1015,
    yi = 1016,
    sw = 1017,
    rw = 1018,
    Hu = 1020,
    CR = 35902,
    SR = 1021,
    MR = 1022,
    Jt = 1023,
    TR = 1024,
    IR = 1025,
    Il = 1026,
    Cu = 1027,
    ra = 1028,
    ow = 1029,
    hl = 1030,
    aw = 1031,
    lw = 1033,
    bh = 33776,
    vp = 33777,
    bp = 33778,
    xh = 33779,
    gg = 35840,
    H_ = 35841,
    Ag = 35842,
    V_ = 35843,
    i0 = 36196,
    _g = 37492,
    vg = 37496,
    bg = 37808,
    W_ = 37809,
    q_ = 37810,
    $_ = 37811,
    tf = 37812,
    j_ = 37813,
    Y_ = 37814,
    X_ = 37815,
    K_ = 37816,
    J_ = 37817,
    Z_ = 37818,
    ev = 37819,
    tv = 37820,
    iv = 37821,
    yh = 36492,
    nv = 36494,
    sv = 36495,
    BR = 36283,
    rv = 36284,
    ov = 36285,
    av = 36286,
    RR = 2200,
    PR = 2201,
    DR = 2202,
    Su = 2300,
    Vl = 2301,
    xp = 2302,
    fl = 2400,
    pl = 2401,
    nf = 2402,
    n0 = 2500,
    LR = 2501,
    kR = 0,
    cw = 1,
    xg = 2,
    FR = 3200,
    uw = 3201,
    s0 = 0,
    NR = 1,
    Ns = "",
    Wt = "srgb",
    gi = "srgb-linear",
    Uf = "display-p3",
    Vu = "display-p3-linear",
    sf = "linear",
    Lt = "srgb",
    rf = "rec709",
    of = "p3",
    Fa = 7680,
    lv = 519,
    OR = 512,
    UR = 513,
    QR = 514,
    dw = 515,
    zR = 516,
    GR = 517,
    HR = 518,
    VR = 519,
    yg = 35044,
    cv = "300 es",
    fr = 2e3,
    af = 2001;
class Io {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        const s = this._listeners[e];
        if (s !== void 0) {
            const r = s.indexOf(t);
            r !== -1 && s.splice(r, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const s = i.slice(0);
            for (let r = 0, o = s.length; r < o; r++) s[r].call(this, e);
            e.target = null
        }
    }
}
const Wi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let uv = 1234567;
const Yc = Math.PI / 180,
    Wl = 180 / Math.PI;

function us() {
    const n = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        t = Math.random() * 4294967295 | 0,
        i = Math.random() * 4294967295 | 0;
    return (Wi[n & 255] + Wi[n >> 8 & 255] + Wi[n >> 16 & 255] + Wi[n >> 24 & 255] + "-" + Wi[e & 255] + Wi[e >> 8 & 255] + "-" + Wi[e >> 16 & 15 | 64] + Wi[e >> 24 & 255] + "-" + Wi[t & 63 | 128] + Wi[t >> 8 & 255] + "-" + Wi[t >> 16 & 255] + Wi[t >> 24 & 255] + Wi[i & 255] + Wi[i >> 8 & 255] + Wi[i >> 16 & 255] + Wi[i >> 24 & 255]).toLowerCase()
}

function fi(n, e, t) {
    return Math.max(e, Math.min(t, n))
}

function r0(n, e) {
    return (n % e + e) % e
}

function WR(n, e, t, i, s) {
    return i + (n - e) * (s - i) / (t - e)
}

function qR(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}

function Xc(n, e, t) {
    return (1 - t) * n + t * e
}

function $R(n, e, t, i) {
    return Xc(n, e, 1 - Math.exp(-t * i))
}

function jR(n, e = 1) {
    return e - Math.abs(r0(n, e * 2) - e)
}

function YR(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n))
}

function XR(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10))
}

function KR(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}

function JR(n, e) {
    return n + Math.random() * (e - n)
}

function ZR(n) {
    return n * (.5 - Math.random())
}

function e2(n) {
    n !== void 0 && (uv = n);
    let e = uv += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function t2(n) {
    return n * Yc
}

function i2(n) {
    return n * Wl
}

function n2(n) {
    return (n & n - 1) === 0 && n !== 0
}

function s2(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}

function r2(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}

function o2(n, e, t, i, s) {
    const r = Math.cos,
        o = Math.sin,
        a = r(t / 2),
        l = o(t / 2),
        c = r((e + i) / 2),
        u = o((e + i) / 2),
        d = r((e - i) / 2),
        h = o((e - i) / 2),
        f = r((i - e) / 2),
        m = o((i - e) / 2);
    switch (s) {
        case "XYX":
            n.set(a * u, l * d, l * h, a * c);
            break;
        case "YZY":
            n.set(l * h, a * u, l * d, a * c);
            break;
        case "ZXZ":
            n.set(l * d, l * h, a * u, a * c);
            break;
        case "XZX":
            n.set(a * u, l * m, l * f, a * c);
            break;
        case "YXY":
            n.set(l * f, a * u, l * m, a * c);
            break;
        case "ZYZ":
            n.set(l * m, l * f, a * u, a * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s)
    }
}

function vs(n, e) {
    switch (e.constructor) {
        case Float32Array:
            return n;
        case Uint32Array:
            return n / 4294967295;
        case Uint16Array:
            return n / 65535;
        case Uint8Array:
            return n / 255;
        case Int32Array:
            return Math.max(n / 2147483647, -1);
        case Int16Array:
            return Math.max(n / 32767, -1);
        case Int8Array:
            return Math.max(n / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function St(n, e) {
    switch (e.constructor) {
        case Float32Array:
            return n;
        case Uint32Array:
            return Math.round(n * 4294967295);
        case Uint16Array:
            return Math.round(n * 65535);
        case Uint8Array:
            return Math.round(n * 255);
        case Int32Array:
            return Math.round(n * 2147483647);
        case Int16Array:
            return Math.round(n * 32767);
        case Int8Array:
            return Math.round(n * 127);
        default:
            throw new Error("Invalid component type.")
    }
}
const lr = {
    DEG2RAD: Yc,
    RAD2DEG: Wl,
    generateUUID: us,
    clamp: fi,
    euclideanModulo: r0,
    mapLinear: WR,
    inverseLerp: qR,
    lerp: Xc,
    damp: $R,
    pingpong: jR,
    smoothstep: YR,
    smootherstep: XR,
    randInt: KR,
    randFloat: JR,
    randFloatSpread: ZR,
    seededRandom: e2,
    degToRad: t2,
    radToDeg: i2,
    isPowerOfTwo: n2,
    ceilPowerOfTwo: s2,
    floorPowerOfTwo: r2,
    setQuaternionFromProperEuler: o2,
    normalize: St,
    denormalize: vs
};
class _e {
    constructor(e = 0, t = 0) {
        _e.prototype.isVector2 = !0, this.x = e, this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e, this.y = t, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6], this.y = s[1] * t + s[4] * i + s[7], this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(fi(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this
    }
    rotateAround(e, t) {
        const i = Math.cos(t),
            s = Math.sin(t),
            r = this.x - e.x,
            o = this.y - e.y;
        return this.x = r * i - o * s + e.x, this.y = r * s + o * i + e.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    } *[Symbol.iterator]() {
        yield this.x, yield this.y
    }
}
class ot {
    constructor(e, t, i, s, r, o, a, l, c) {
        ot.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, s, r, o, a, l, c)
    }
    set(e, t, i, s, r, o, a, l, c) {
        const u = this.elements;
        return u[0] = e, u[1] = s, u[2] = a, u[3] = t, u[4] = r, u[5] = l, u[6] = i, u[7] = o, u[8] = c, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            s = t.elements,
            r = this.elements,
            o = i[0],
            a = i[3],
            l = i[6],
            c = i[1],
            u = i[4],
            d = i[7],
            h = i[2],
            f = i[5],
            m = i[8],
            g = s[0],
            A = s[3],
            p = s[6],
            v = s[1],
            _ = s[4],
            b = s[7],
            w = s[2],
            E = s[5],
            C = s[8];
        return r[0] = o * g + a * v + l * w, r[3] = o * A + a * _ + l * E, r[6] = o * p + a * b + l * C, r[1] = c * g + u * v + d * w, r[4] = c * A + u * _ + d * E, r[7] = c * p + u * b + d * C, r[2] = h * g + f * v + m * w, r[5] = h * A + f * _ + m * E, r[8] = h * p + f * b + m * C, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            s = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8];
        return t * o * u - t * a * c - i * r * u + i * a * l + s * r * c - s * o * l
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            s = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            d = u * o - a * c,
            h = a * l - u * r,
            f = c * r - o * l,
            m = t * d + i * h + s * f;
        if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const g = 1 / m;
        return e[0] = d * g, e[1] = (s * c - u * i) * g, e[2] = (a * i - s * o) * g, e[3] = h * g, e[4] = (u * t - s * l) * g, e[5] = (s * r - a * t) * g, e[6] = f * g, e[7] = (i * l - c * t) * g, e[8] = (o * t - i * r) * g, this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
    }
    setUvTransform(e, t, i, s, r, o, a) {
        const l = Math.cos(r),
            c = Math.sin(r);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -s * c, s * l, -s * (-c * o + l * a) + a + t, 0, 0, 1), this
    }
    scale(e, t) {
        return this.premultiply(yp.makeScale(e, t)), this
    }
    rotate(e) {
        return this.premultiply(yp.makeRotation(-e)), this
    }
    translate(e, t) {
        return this.premultiply(yp.makeTranslation(e, t)), this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
    }
    makeRotation(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let s = 0; s < 9; s++)
            if (t[s] !== i[s]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const yp = new ot;

function hw(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535) return !0;
    return !1
}

function Mu(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}

function a2() {
    const n = Mu("canvas");
    return n.style.display = "block", n
}
const dv = {};

function fw(n) {
    n in dv || (dv[n] = !0, console.warn(n))
}
const hv = new ot().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
    fv = new ot().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
    ld = {
        [gi]: {
            transfer: sf,
            primaries: rf,
            toReference: n => n,
            fromReference: n => n
        },
        [Wt]: {
            transfer: Lt,
            primaries: rf,
            toReference: n => n.convertSRGBToLinear(),
            fromReference: n => n.convertLinearToSRGB()
        },
        [Vu]: {
            transfer: sf,
            primaries: of,
            toReference: n => n.applyMatrix3(fv),
            fromReference: n => n.applyMatrix3(hv)
        },
        [Uf]: {
            transfer: Lt,
            primaries: of,
            toReference: n => n.convertSRGBToLinear().applyMatrix3(fv),
            fromReference: n => n.applyMatrix3(hv).convertLinearToSRGB()
        }
    },
    l2 = new Set([gi, Vu]),
    vt = {
        enabled: !0,
        _workingColorSpace: gi,
        get workingColorSpace() {
            return this._workingColorSpace
        },
        set workingColorSpace(n) {
            if (!l2.has(n)) throw new Error(`Unsupported working color space, "${n}".`);
            this._workingColorSpace = n
        },
        convert: function (n, e, t) {
            if (this.enabled === !1 || e === t || !e || !t) return n;
            const i = ld[e].toReference,
                s = ld[t].fromReference;
            return s(i(n))
        },
        fromWorkingColorSpace: function (n, e) {
            return this.convert(n, this._workingColorSpace, e)
        },
        toWorkingColorSpace: function (n, e) {
            return this.convert(n, e, this._workingColorSpace)
        },
        getPrimaries: function (n) {
            return ld[n].primaries
        },
        getTransfer: function (n) {
            return n === Ns ? sf : ld[n].transfer
        }
    };

function Bl(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}

function Ep(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Na;
class c2 {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
            Na === void 0 && (Na = Mu("canvas")), Na.width = e.width, Na.height = e.height;
            const i = Na.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Na
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Mu("canvas");
            t.width = e.width, t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const s = i.getImageData(0, 0, e.width, e.height),
                r = s.data;
            for (let o = 0; o < r.length; o++) r[o] = Bl(r[o] / 255) * 255;
            return i.putImageData(s, 0, 0), t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Bl(t[i] / 255) * 255) : t[i] = Bl(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
    }
}
let u2 = 0;
class pw {
    constructor(e = null) {
        this.isSource = !0, Object.defineProperty(this, "id", {
            value: u2++
        }), this.uuid = us(), this.data = e, this.dataReady = !0, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        },
            s = this.data;
        if (s !== null) {
            let r;
            if (Array.isArray(s)) {
                r = [];
                for (let o = 0, a = s.length; o < a; o++) s[o].isDataTexture ? r.push(wp(s[o].image)) : r.push(wp(s[o]))
            } else r = wp(s);
            i.url = r
        }
        return t || (e.images[this.uuid] = i), i
    }
}

function wp(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? c2.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let d2 = 0;
class oi extends Io {
    constructor(e = oi.DEFAULT_IMAGE, t = oi.DEFAULT_MAPPING, i = pn, s = pn, r = Pt, o = ys, a = Jt, l = hi, c = oi.DEFAULT_ANISOTROPY, u = Ns) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: d2++
        }), this.uuid = us(), this.name = "", this.source = new pw(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = s, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new _e(0, 0), this.repeat = new _e(1, 1), this.center = new _e(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ot, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e = null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== ew) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case Eo:
                e.x = e.x - Math.floor(e.x);
                break;
            case pn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case ef:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
        }
        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case Eo:
                e.y = e.y - Math.floor(e.y);
                break;
            case pn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case ef:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
        }
        return this.flipY && (e.y = 1 - e.y), e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
oi.DEFAULT_IMAGE = null;
oi.DEFAULT_MAPPING = ew;
oi.DEFAULT_ANISOTROPY = 1;
class Rt {
    constructor(e = 0, t = 0, i = 0, s = 1) {
        Rt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = s
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, s) {
        return this.x = e, this.y = t, this.z = i, this.w = s, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setW(e) {
        return this.w = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            s = this.z,
            r = this.w,
            o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * s + o[12] * r, this.y = o[1] * t + o[5] * i + o[9] * s + o[13] * r, this.z = o[2] * t + o[6] * i + o[10] * s + o[14] * r, this.w = o[3] * t + o[7] * i + o[11] * s + o[15] * r, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, s, r;
        const l = e.elements,
            c = l[0],
            u = l[4],
            d = l[8],
            h = l[1],
            f = l[5],
            m = l[9],
            g = l[2],
            A = l[6],
            p = l[10];
        if (Math.abs(u - h) < .01 && Math.abs(d - g) < .01 && Math.abs(m - A) < .01) {
            if (Math.abs(u + h) < .1 && Math.abs(d + g) < .1 && Math.abs(m + A) < .1 && Math.abs(c + f + p - 3) < .1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const _ = (c + 1) / 2,
                b = (f + 1) / 2,
                w = (p + 1) / 2,
                E = (u + h) / 4,
                C = (d + g) / 4,
                S = (m + A) / 4;
            return _ > b && _ > w ? _ < .01 ? (i = 0, s = .707106781, r = .707106781) : (i = Math.sqrt(_), s = E / i, r = C / i) : b > w ? b < .01 ? (i = .707106781, s = 0, r = .707106781) : (s = Math.sqrt(b), i = E / s, r = S / s) : w < .01 ? (i = .707106781, s = .707106781, r = 0) : (r = Math.sqrt(w), i = C / r, s = S / r), this.set(i, s, r, t), this
        }
        let v = Math.sqrt((A - m) * (A - m) + (d - g) * (d - g) + (h - u) * (h - u));
        return Math.abs(v) < .001 && (v = 1), this.x = (A - m) / v, this.y = (d - g) / v, this.z = (h - u) / v, this.w = Math.acos((c + f + p - 1) / 2), this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    } *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}
class h2 extends Io {
    constructor(e = 1, t = 1, i = {}) {
        super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Rt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Rt(0, 0, e, t);
        const s = {
            width: e,
            height: t,
            depth: 1
        };
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Pt,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0,
            count: 1
        }, i);
        const r = new oi(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
        r.flipY = !1, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
        const o = i.count;
        for (let a = 0; a < o; a++) this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, i = 1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e, this.height = t, this.depth = i;
            for (let s = 0, r = this.textures.length; s < r; s++) this.textures[s].image.width = e, this.textures[s].image.height = t, this.textures[s].image.depth = i;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
        for (let i = 0, s = e.textures.length; i < s; i++) this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new pw(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class mn extends h2 {
    constructor(e = 1, t = 1, i = {}) {
        super(e, t, i), this.isWebGLRenderTarget = !0
    }
}
class mw extends oi {
    constructor(e = null, t = 1, i = 1, s = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: e,
            width: t,
            height: i,
            depth: s
        }, this.magFilter = Kt, this.minFilter = Kt, this.wrapR = pn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class gw extends oi {
    constructor(e = null, t = 1, i = 1, s = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: e,
            width: t,
            height: i,
            depth: s
        }, this.magFilter = Kt, this.minFilter = Kt, this.wrapR = pn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class Tn {
    constructor(e = 0, t = 0, i = 0, s = 1) {
        this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = s
    }
    static slerpFlat(e, t, i, s, r, o, a) {
        let l = i[s + 0],
            c = i[s + 1],
            u = i[s + 2],
            d = i[s + 3];
        const h = r[o + 0],
            f = r[o + 1],
            m = r[o + 2],
            g = r[o + 3];
        if (a === 0) {
            e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d;
            return
        }
        if (a === 1) {
            e[t + 0] = h, e[t + 1] = f, e[t + 2] = m, e[t + 3] = g;
            return
        }
        if (d !== g || l !== h || c !== f || u !== m) {
            let A = 1 - a;
            const p = l * h + c * f + u * m + d * g,
                v = p >= 0 ? 1 : -1,
                _ = 1 - p * p;
            if (_ > Number.EPSILON) {
                const w = Math.sqrt(_),
                    E = Math.atan2(w, p * v);
                A = Math.sin(A * E) / w, a = Math.sin(a * E) / w
            }
            const b = a * v;
            if (l = l * A + h * b, c = c * A + f * b, u = u * A + m * b, d = d * A + g * b, A === 1 - a) {
                const w = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
                l *= w, c *= w, u *= w, d *= w
            }
        }
        e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d
    }
    static multiplyQuaternionsFlat(e, t, i, s, r, o) {
        const a = i[s],
            l = i[s + 1],
            c = i[s + 2],
            u = i[s + 3],
            d = r[o],
            h = r[o + 1],
            f = r[o + 2],
            m = r[o + 3];
        return e[t] = a * m + u * d + l * f - c * h, e[t + 1] = l * m + u * h + c * d - a * f, e[t + 2] = c * m + u * f + a * h - l * d, e[t + 3] = u * m - a * d - l * h - c * f, e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e, this._onChangeCallback()
    }
    set(e, t, i, s) {
        return this._x = e, this._y = t, this._z = i, this._w = s, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
    }
    setFromEuler(e, t = !0) {
        const i = e._x,
            s = e._y,
            r = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(i / 2),
            u = a(s / 2),
            d = a(r / 2),
            h = l(i / 2),
            f = l(s / 2),
            m = l(r / 2);
        switch (o) {
            case "XYZ":
                this._x = h * u * d + c * f * m, this._y = c * f * d - h * u * m, this._z = c * u * m + h * f * d, this._w = c * u * d - h * f * m;
                break;
            case "YXZ":
                this._x = h * u * d + c * f * m, this._y = c * f * d - h * u * m, this._z = c * u * m - h * f * d, this._w = c * u * d + h * f * m;
                break;
            case "ZXY":
                this._x = h * u * d - c * f * m, this._y = c * f * d + h * u * m, this._z = c * u * m + h * f * d, this._w = c * u * d - h * f * m;
                break;
            case "ZYX":
                this._x = h * u * d - c * f * m, this._y = c * f * d + h * u * m, this._z = c * u * m - h * f * d, this._w = c * u * d + h * f * m;
                break;
            case "YZX":
                this._x = h * u * d + c * f * m, this._y = c * f * d + h * u * m, this._z = c * u * m - h * f * d, this._w = c * u * d - h * f * m;
                break;
            case "XZY":
                this._x = h * u * d - c * f * m, this._y = c * f * d - h * u * m, this._z = c * u * m + h * f * d, this._w = c * u * d + h * f * m;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(), this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2,
            s = Math.sin(i);
        return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(i), this._onChangeCallback(), this
    }
    setFromRotationMatrix(e) {
        const t = e.elements,
            i = t[0],
            s = t[4],
            r = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            u = t[6],
            d = t[10],
            h = i + a + d;
        if (h > 0) {
            const f = .5 / Math.sqrt(h + 1);
            this._w = .25 / f, this._x = (u - l) * f, this._y = (r - c) * f, this._z = (o - s) * f
        } else if (i > a && i > d) {
            const f = 2 * Math.sqrt(1 + i - a - d);
            this._w = (u - l) / f, this._x = .25 * f, this._y = (s + o) / f, this._z = (r + c) / f
        } else if (a > d) {
            const f = 2 * Math.sqrt(1 + a - i - d);
            this._w = (r - c) / f, this._x = (s + o) / f, this._y = .25 * f, this._z = (l + u) / f
        } else {
            const f = 2 * Math.sqrt(1 + d - i - a);
            this._w = (o - s) / f, this._x = (r + c) / f, this._y = (l + u) / f, this._z = .25 * f
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(fi(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0) return this;
        const s = Math.min(1, t / i);
        return this.slerp(e, s), this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x,
            s = e._y,
            r = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            u = t._w;
        return this._x = i * u + o * a + s * c - r * l, this._y = s * u + o * l + r * a - i * c, this._z = r * u + o * c + i * l - s * a, this._w = o * u - i * a - s * l - r * c, this._onChangeCallback(), this
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        const i = this._x,
            s = this._y,
            r = this._z,
            o = this._w;
        let a = o * e._w + i * e._x + s * e._y + r * e._z;
        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = s, this._z = r, this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * o + t * this._w, this._x = f * i + t * this._x, this._y = f * s + t * this._y, this._z = f * r + t * this._z, this.normalize(), this
        }
        const c = Math.sqrt(l),
            u = Math.atan2(c, a),
            d = Math.sin((1 - t) * u) / c,
            h = Math.sin(t * u) / c;
        return this._w = o * d + this._w * h, this._x = i * d + this._x * h, this._y = s * d + this._y * h, this._z = r * d + this._z * h, this._onChangeCallback(), this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            i = Math.random(),
            s = Math.sqrt(1 - i),
            r = Math.sqrt(i);
        return this.set(s * Math.sin(e), s * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t = 0) {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() { } *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}
class z {
    constructor(e = 0, t = 0, i = 0) {
        z.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
    }
    applyEuler(e) {
        return this.applyQuaternion(pv.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(pv.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            s = this.z,
            r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6] * s, this.y = r[1] * t + r[4] * i + r[7] * s, this.z = r[2] * t + r[5] * i + r[8] * s, this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            s = this.z,
            r = e.elements,
            o = 1 / (r[3] * t + r[7] * i + r[11] * s + r[15]);
        return this.x = (r[0] * t + r[4] * i + r[8] * s + r[12]) * o, this.y = (r[1] * t + r[5] * i + r[9] * s + r[13]) * o, this.z = (r[2] * t + r[6] * i + r[10] * s + r[14]) * o, this
    }
    applyQuaternion(e) {
        const t = this.x,
            i = this.y,
            s = this.z,
            r = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = 2 * (o * s - a * i),
            u = 2 * (a * t - r * s),
            d = 2 * (r * i - o * t);
        return this.x = t + l * c + o * d - a * u, this.y = i + l * u + a * c - r * d, this.z = s + l * d + r * u - o * c, this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x,
            i = this.y,
            s = this.z,
            r = e.elements;
        return this.x = r[0] * t + r[4] * i + r[8] * s, this.y = r[1] * t + r[5] * i + r[9] * s, this.z = r[2] * t + r[6] * i + r[10] * s, this.normalize()
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x,
            s = e.y,
            r = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
        return this.x = s * l - r * a, this.y = r * o - i * l, this.z = i * a - s * o, this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return Cp.copy(this).projectOnVector(e), this.sub(Cp)
    }
    reflect(e) {
        return this.sub(Cp.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(fi(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y,
            s = this.z - e.z;
        return t * t + i * i + s * s
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const s = Math.sin(t) * e;
        return this.x = s * Math.sin(i), this.y = Math.cos(t) * e, this.z = s * Math.cos(i), this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
            i = this.setFromMatrixColumn(e, 1).length(),
            s = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = i, this.z = s, this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this
    }
    setFromColor(e) {
        return this.x = e.r, this.y = e.g, this.z = e.b, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2,
            t = Math.random() * 2 - 1,
            i = Math.sqrt(1 - t * t);
        return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this
    } *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
}
const Cp = new z,
    pv = new Tn;
class Sr {
    constructor(e = new z(1 / 0, 1 / 0, 1 / 0), t = new z(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = e, this.max = t
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(ps.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(ps.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = ps.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
    }
    setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const r = i.getAttribute("position");
            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = r.count; o < a; o++) e.isMesh === !0 ? e.getVertexPosition(o, ps) : ps.fromBufferAttribute(r, o), ps.applyMatrix4(e.matrixWorld), this.expandByPoint(ps);
            else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), cd.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), cd.copy(i.boundingBox)), cd.applyMatrix4(e.matrixWorld), this.union(cd)
        }
        const s = e.children;
        for (let r = 0, o = s.length; r < o; r++) this.expandByObject(s[r], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, ps), ps.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(uc), ud.subVectors(this.max, uc), Oa.subVectors(e.a, uc), Ua.subVectors(e.b, uc), Qa.subVectors(e.c, uc), Dr.subVectors(Ua, Oa), Lr.subVectors(Qa, Ua), Qo.subVectors(Oa, Qa);
        let t = [0, -Dr.z, Dr.y, 0, -Lr.z, Lr.y, 0, -Qo.z, Qo.y, Dr.z, 0, -Dr.x, Lr.z, 0, -Lr.x, Qo.z, 0, -Qo.x, -Dr.y, Dr.x, 0, -Lr.y, Lr.x, 0, -Qo.y, Qo.x, 0];
        return !Sp(t, Oa, Ua, Qa, ud) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Sp(t, Oa, Ua, Qa, ud)) ? !1 : (dd.crossVectors(Dr, Lr), t = [dd.x, dd.y, dd.z], Sp(t, Oa, Ua, Qa, ud))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, ps).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(ps).length() * .5), e
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Js[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Js[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Js[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Js[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Js[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Js[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Js[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Js[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Js), this)
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Js = [new z, new z, new z, new z, new z, new z, new z, new z],
    ps = new z,
    cd = new Sr,
    Oa = new z,
    Ua = new z,
    Qa = new z,
    Dr = new z,
    Lr = new z,
    Qo = new z,
    uc = new z,
    ud = new z,
    dd = new z,
    zo = new z;

function Sp(n, e, t, i, s) {
    for (let r = 0, o = n.length - 3; r <= o; r += 3) {
        zo.fromArray(n, r);
        const a = s.x * Math.abs(zo.x) + s.y * Math.abs(zo.y) + s.z * Math.abs(zo.z),
            l = e.dot(zo),
            c = t.dot(zo),
            u = i.dot(zo);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1
    }
    return !0
}
const f2 = new Sr,
    dc = new z,
    Mp = new z;
class js {
    constructor(e = new z, t = -1) {
        this.isSphere = !0, this.center = e, this.radius = t
    }
    set(e, t) {
        return this.center.copy(e), this.radius = t, this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : f2.setFromPoints(e).getCenter(i);
        let s = 0;
        for (let r = 0, o = e.length; r < o; r++) s = Math.max(s, i.distanceToSquared(e[r]));
        return this.radius = Math.sqrt(s), this
    }
    copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
    }
    translate(e) {
        return this.center.add(e), this
    }
    expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
        dc.subVectors(e, this.center);
        const t = dc.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t),
                s = (i - this.radius) * .5;
            this.center.addScaledVector(dc, s / i), this.radius += s
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Mp.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(dc.copy(e.center).add(Mp)), this.expandByPoint(dc.copy(e.center).sub(Mp))), this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Zs = new z,
    Tp = new z,
    hd = new z,
    kr = new z,
    Ip = new z,
    fd = new z,
    Bp = new z;
class Wu {
    constructor(e = new z, t = new z(0, 0, -1)) {
        this.origin = e, this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this
    }
    copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Zs)), this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = Zs.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Zs.copy(this.origin).addScaledVector(this.direction, t), Zs.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, s) {
        Tp.copy(e).add(t).multiplyScalar(.5), hd.copy(t).sub(e).normalize(), kr.copy(this.origin).sub(Tp);
        const r = e.distanceTo(t) * .5,
            o = -this.direction.dot(hd),
            a = kr.dot(this.direction),
            l = -kr.dot(hd),
            c = kr.lengthSq(),
            u = Math.abs(1 - o * o);
        let d, h, f, m;
        if (u > 0)
            if (d = o * l - a, h = o * a - l, m = r * u, d >= 0)
                if (h >= -m)
                    if (h <= m) {
                        const g = 1 / u;
                        d *= g, h *= g, f = d * (d + o * h + 2 * a) + h * (o * d + h + 2 * l) + c
                    } else h = r, d = Math.max(0, -(o * h + a)), f = -d * d + h * (h + 2 * l) + c;
                else h = -r, d = Math.max(0, -(o * h + a)), f = -d * d + h * (h + 2 * l) + c;
            else h <= -m ? (d = Math.max(0, -(-o * r + a)), h = d > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -d * d + h * (h + 2 * l) + c) : h <= m ? (d = 0, h = Math.min(Math.max(-r, -l), r), f = h * (h + 2 * l) + c) : (d = Math.max(0, -(o * r + a)), h = d > 0 ? r : Math.min(Math.max(-r, -l), r), f = -d * d + h * (h + 2 * l) + c);
        else h = o > 0 ? -r : r, d = Math.max(0, -(o * h + a)), f = -d * d + h * (h + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, d), s && s.copy(Tp).addScaledVector(hd, h), f
    }
    intersectSphere(e, t) {
        Zs.subVectors(e.center, this.origin);
        const i = Zs.dot(this.direction),
            s = Zs.dot(Zs) - i * i,
            r = e.radius * e.radius;
        if (s > r) return null;
        const o = Math.sqrt(r - s),
            a = i - o,
            l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, s, r, o, a, l;
        const c = 1 / this.direction.x,
            u = 1 / this.direction.y,
            d = 1 / this.direction.z,
            h = this.origin;
        return c >= 0 ? (i = (e.min.x - h.x) * c, s = (e.max.x - h.x) * c) : (i = (e.max.x - h.x) * c, s = (e.min.x - h.x) * c), u >= 0 ? (r = (e.min.y - h.y) * u, o = (e.max.y - h.y) * u) : (r = (e.max.y - h.y) * u, o = (e.min.y - h.y) * u), i > o || r > s || ((r > i || isNaN(i)) && (i = r), (o < s || isNaN(s)) && (s = o), d >= 0 ? (a = (e.min.z - h.z) * d, l = (e.max.z - h.z) * d) : (a = (e.max.z - h.z) * d, l = (e.min.z - h.z) * d), i > l || a > s) || ((a > i || i !== i) && (i = a), (l < s || s !== s) && (s = l), s < 0) ? null : this.at(i >= 0 ? i : s, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Zs) !== null
    }
    intersectTriangle(e, t, i, s, r) {
        Ip.subVectors(t, e), fd.subVectors(i, e), Bp.crossVectors(Ip, fd);
        let o = this.direction.dot(Bp),
            a;
        if (o > 0) {
            if (s) return null;
            a = 1
        } else if (o < 0) a = -1, o = -o;
        else return null;
        kr.subVectors(this.origin, e);
        const l = a * this.direction.dot(fd.crossVectors(kr, fd));
        if (l < 0) return null;
        const c = a * this.direction.dot(Ip.cross(kr));
        if (c < 0 || l + c > o) return null;
        const u = -a * kr.dot(Bp);
        return u < 0 ? null : this.at(u / o, r)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Xe {
    constructor(e, t, i, s, r, o, a, l, c, u, d, h, f, m, g, A) {
        Xe.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, s, r, o, a, l, c, u, d, h, f, m, g, A)
    }
    set(e, t, i, s, r, o, a, l, c, u, d, h, f, m, g, A) {
        const p = this.elements;
        return p[0] = e, p[4] = t, p[8] = i, p[12] = s, p[1] = r, p[5] = o, p[9] = a, p[13] = l, p[2] = c, p[6] = u, p[10] = d, p[14] = h, p[3] = f, p[7] = m, p[11] = g, p[15] = A, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return new Xe().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
    }
    copyPosition(e) {
        const t = this.elements,
            i = e.elements;
        return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(e) {
        const t = this.elements,
            i = e.elements,
            s = 1 / za.setFromMatrixColumn(e, 0).length(),
            r = 1 / za.setFromMatrixColumn(e, 1).length(),
            o = 1 / za.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * s, t[1] = i[1] * s, t[2] = i[2] * s, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromEuler(e) {
        const t = this.elements,
            i = e.x,
            s = e.y,
            r = e.z,
            o = Math.cos(i),
            a = Math.sin(i),
            l = Math.cos(s),
            c = Math.sin(s),
            u = Math.cos(r),
            d = Math.sin(r);
        if (e.order === "XYZ") {
            const h = o * u,
                f = o * d,
                m = a * u,
                g = a * d;
            t[0] = l * u, t[4] = -l * d, t[8] = c, t[1] = f + m * c, t[5] = h - g * c, t[9] = -a * l, t[2] = g - h * c, t[6] = m + f * c, t[10] = o * l
        } else if (e.order === "YXZ") {
            const h = l * u,
                f = l * d,
                m = c * u,
                g = c * d;
            t[0] = h + g * a, t[4] = m * a - f, t[8] = o * c, t[1] = o * d, t[5] = o * u, t[9] = -a, t[2] = f * a - m, t[6] = g + h * a, t[10] = o * l
        } else if (e.order === "ZXY") {
            const h = l * u,
                f = l * d,
                m = c * u,
                g = c * d;
            t[0] = h - g * a, t[4] = -o * d, t[8] = m + f * a, t[1] = f + m * a, t[5] = o * u, t[9] = g - h * a, t[2] = -o * c, t[6] = a, t[10] = o * l
        } else if (e.order === "ZYX") {
            const h = o * u,
                f = o * d,
                m = a * u,
                g = a * d;
            t[0] = l * u, t[4] = m * c - f, t[8] = h * c + g, t[1] = l * d, t[5] = g * c + h, t[9] = f * c - m, t[2] = -c, t[6] = a * l, t[10] = o * l
        } else if (e.order === "YZX") {
            const h = o * l,
                f = o * c,
                m = a * l,
                g = a * c;
            t[0] = l * u, t[4] = g - h * d, t[8] = m * d + f, t[1] = d, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = f * d + m, t[10] = h - g * d
        } else if (e.order === "XZY") {
            const h = o * l,
                f = o * c,
                m = a * l,
                g = a * c;
            t[0] = l * u, t[4] = -d, t[8] = c * u, t[1] = h * d + g, t[5] = o * u, t[9] = f * d - m, t[2] = m * d - f, t[6] = a * u, t[10] = g * d + h
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(p2, e, m2)
    }
    lookAt(e, t, i) {
        const s = this.elements;
        return Pn.subVectors(e, t), Pn.lengthSq() === 0 && (Pn.z = 1), Pn.normalize(), Fr.crossVectors(i, Pn), Fr.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Pn.x += 1e-4 : Pn.z += 1e-4, Pn.normalize(), Fr.crossVectors(i, Pn)), Fr.normalize(), pd.crossVectors(Pn, Fr), s[0] = Fr.x, s[4] = pd.x, s[8] = Pn.x, s[1] = Fr.y, s[5] = pd.y, s[9] = Pn.y, s[2] = Fr.z, s[6] = pd.z, s[10] = Pn.z, this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            s = t.elements,
            r = this.elements,
            o = i[0],
            a = i[4],
            l = i[8],
            c = i[12],
            u = i[1],
            d = i[5],
            h = i[9],
            f = i[13],
            m = i[2],
            g = i[6],
            A = i[10],
            p = i[14],
            v = i[3],
            _ = i[7],
            b = i[11],
            w = i[15],
            E = s[0],
            C = s[4],
            S = s[8],
            x = s[12],
            y = s[1],
            P = s[5],
            T = s[9],
            R = s[13],
            D = s[2],
            U = s[6],
            Q = s[10],
            F = s[14],
            L = s[3],
            W = s[7],
            k = s[11],
            $ = s[15];
        return r[0] = o * E + a * y + l * D + c * L, r[4] = o * C + a * P + l * U + c * W, r[8] = o * S + a * T + l * Q + c * k, r[12] = o * x + a * R + l * F + c * $, r[1] = u * E + d * y + h * D + f * L, r[5] = u * C + d * P + h * U + f * W, r[9] = u * S + d * T + h * Q + f * k, r[13] = u * x + d * R + h * F + f * $, r[2] = m * E + g * y + A * D + p * L, r[6] = m * C + g * P + A * U + p * W, r[10] = m * S + g * T + A * Q + p * k, r[14] = m * x + g * R + A * F + p * $, r[3] = v * E + _ * y + b * D + w * L, r[7] = v * C + _ * P + b * U + w * W, r[11] = v * S + _ * T + b * Q + w * k, r[15] = v * x + _ * R + b * F + w * $, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[4],
            s = e[8],
            r = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            u = e[2],
            d = e[6],
            h = e[10],
            f = e[14],
            m = e[3],
            g = e[7],
            A = e[11],
            p = e[15];
        return m * (+r * l * d - s * c * d - r * a * h + i * c * h + s * a * f - i * l * f) + g * (+t * l * f - t * c * h + r * o * h - s * o * f + s * c * u - r * l * u) + A * (+t * c * d - t * a * f - r * o * d + i * o * f + r * a * u - i * c * u) + p * (-s * a * u - t * l * d + t * a * h + s * o * d - i * o * h + i * l * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
    }
    setPosition(e, t, i) {
        const s = this.elements;
        return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = t, s[14] = i), this
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            s = e[2],
            r = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            d = e[9],
            h = e[10],
            f = e[11],
            m = e[12],
            g = e[13],
            A = e[14],
            p = e[15],
            v = d * A * c - g * h * c + g * l * f - a * A * f - d * l * p + a * h * p,
            _ = m * h * c - u * A * c - m * l * f + o * A * f + u * l * p - o * h * p,
            b = u * g * c - m * d * c + m * a * f - o * g * f - u * a * p + o * d * p,
            w = m * d * l - u * g * l - m * a * h + o * g * h + u * a * A - o * d * A,
            E = t * v + i * _ + s * b + r * w;
        if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const C = 1 / E;
        return e[0] = v * C, e[1] = (g * h * r - d * A * r - g * s * f + i * A * f + d * s * p - i * h * p) * C, e[2] = (a * A * r - g * l * r + g * s * c - i * A * c - a * s * p + i * l * p) * C, e[3] = (d * l * r - a * h * r - d * s * c + i * h * c + a * s * f - i * l * f) * C, e[4] = _ * C, e[5] = (u * A * r - m * h * r + m * s * f - t * A * f - u * s * p + t * h * p) * C, e[6] = (m * l * r - o * A * r - m * s * c + t * A * c + o * s * p - t * l * p) * C, e[7] = (o * h * r - u * l * r + u * s * c - t * h * c - o * s * f + t * l * f) * C, e[8] = b * C, e[9] = (m * d * r - u * g * r - m * i * f + t * g * f + u * i * p - t * d * p) * C, e[10] = (o * g * r - m * a * r + m * i * c - t * g * c - o * i * p + t * a * p) * C, e[11] = (u * a * r - o * d * r - u * i * c + t * d * c + o * i * f - t * a * f) * C, e[12] = w * C, e[13] = (u * g * s - m * d * s + m * i * h - t * g * h - u * i * A + t * d * A) * C, e[14] = (m * a * s - o * g * s - m * i * l + t * g * l + o * i * A - t * a * A) * C, e[15] = (o * d * s - u * a * s + u * i * l - t * d * l - o * i * h + t * a * h) * C, this
    }
    scale(e) {
        const t = this.elements,
            i = e.x,
            s = e.y,
            r = e.z;
        return t[0] *= i, t[4] *= s, t[8] *= r, t[1] *= i, t[5] *= s, t[9] *= r, t[2] *= i, t[6] *= s, t[10] *= r, t[3] *= i, t[7] *= s, t[11] *= r, this
    }
    getMaxScaleOnAxis() {
        const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, s))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
    }
    makeRotationX(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
    }
    makeRotationY(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t),
            s = Math.sin(t),
            r = 1 - i,
            o = e.x,
            a = e.y,
            l = e.z,
            c = r * o,
            u = r * a;
        return this.set(c * o + i, c * a - s * l, c * l + s * a, 0, c * a + s * l, u * a + i, u * l - s * o, 0, c * l - s * a, u * l + s * o, r * l * l + i, 0, 0, 0, 0, 1), this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
    }
    makeShear(e, t, i, s, r, o) {
        return this.set(1, i, r, 0, e, 1, o, 0, t, s, 1, 0, 0, 0, 0, 1), this
    }
    compose(e, t, i) {
        const s = this.elements,
            r = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = r + r,
            u = o + o,
            d = a + a,
            h = r * c,
            f = r * u,
            m = r * d,
            g = o * u,
            A = o * d,
            p = a * d,
            v = l * c,
            _ = l * u,
            b = l * d,
            w = i.x,
            E = i.y,
            C = i.z;
        return s[0] = (1 - (g + p)) * w, s[1] = (f + b) * w, s[2] = (m - _) * w, s[3] = 0, s[4] = (f - b) * E, s[5] = (1 - (h + p)) * E, s[6] = (A + v) * E, s[7] = 0, s[8] = (m + _) * C, s[9] = (A - v) * C, s[10] = (1 - (h + g)) * C, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this
    }
    decompose(e, t, i) {
        const s = this.elements;
        let r = za.set(s[0], s[1], s[2]).length();
        const o = za.set(s[4], s[5], s[6]).length(),
            a = za.set(s[8], s[9], s[10]).length();
        this.determinant() < 0 && (r = -r), e.x = s[12], e.y = s[13], e.z = s[14], ms.copy(this);
        const c = 1 / r,
            u = 1 / o,
            d = 1 / a;
        return ms.elements[0] *= c, ms.elements[1] *= c, ms.elements[2] *= c, ms.elements[4] *= u, ms.elements[5] *= u, ms.elements[6] *= u, ms.elements[8] *= d, ms.elements[9] *= d, ms.elements[10] *= d, t.setFromRotationMatrix(ms), i.x = r, i.y = o, i.z = a, this
    }
    makePerspective(e, t, i, s, r, o, a = fr) {
        const l = this.elements,
            c = 2 * r / (t - e),
            u = 2 * r / (i - s),
            d = (t + e) / (t - e),
            h = (i + s) / (i - s);
        let f, m;
        if (a === fr) f = -(o + r) / (o - r), m = -2 * o * r / (o - r);
        else if (a === af) f = -o / (o - r), m = -o * r / (o - r);
        else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = u, l[9] = h, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
    }
    makeOrthographic(e, t, i, s, r, o, a = fr) {
        const l = this.elements,
            c = 1 / (t - e),
            u = 1 / (i - s),
            d = 1 / (o - r),
            h = (t + e) * c,
            f = (i + s) * u;
        let m, g;
        if (a === fr) m = (o + r) * d, g = -2 * d;
        else if (a === af) m = r * d, g = -1 * d;
        else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -h, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let s = 0; s < 16; s++)
            if (t[s] !== i[s]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
    }
}
const za = new z,
    ms = new Xe,
    p2 = new z(0, 0, 0),
    m2 = new z(1, 1, 1),
    Fr = new z,
    pd = new z,
    Pn = new z,
    mv = new Xe,
    gv = new Tn;
class Cs {
    constructor(e = 0, t = 0, i = 0, s = Cs.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = s
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e, this._onChangeCallback()
    }
    set(e, t, i, s = this._order) {
        return this._x = e, this._y = t, this._z = i, this._order = s, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(e, t = this._order, i = !0) {
        const s = e.elements,
            r = s[0],
            o = s[4],
            a = s[8],
            l = s[1],
            c = s[5],
            u = s[9],
            d = s[2],
            h = s[6],
            f = s[10];
        switch (t) {
            case "XYZ":
                this._y = Math.asin(fi(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(h, c), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-fi(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, r), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(fi(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
                break;
            case "ZYX":
                this._y = Math.asin(-fi(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(h, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
                break;
            case "YZX":
                this._z = Math.asin(fi(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-d, r)) : (this._x = 0, this._y = Math.atan2(a, f));
                break;
            case "XZY":
                this._z = Math.asin(-fi(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-u, f), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t, i === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(e, t, i) {
        return mv.makeRotationFromQuaternion(e), this.setFromRotationMatrix(mv, t, i)
    }
    setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return gv.setFromEuler(this), this.setFromQuaternion(gv, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() { } *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
}
Cs.DEFAULT_ORDER = "XYZ";
class o0 {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let g2 = 0;
const Av = new z,
    Ga = new Tn,
    er = new Xe,
    md = new z,
    hc = new z,
    A2 = new z,
    _2 = new Tn,
    _v = new z(1, 0, 0),
    vv = new z(0, 1, 0),
    bv = new z(0, 0, 1),
    xv = {
        type: "added"
    },
    v2 = {
        type: "removed"
    },
    Ha = {
        type: "childadded",
        child: null
    },
    Rp = {
        type: "childremoved",
        child: null
    };
class Ft extends Io {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: g2++
        }), this.uuid = us(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ft.DEFAULT_UP.clone();
        const e = new z,
            t = new Cs,
            i = new Tn,
            s = new z(1, 1, 1);

        function r() {
            i.setFromEuler(t, !1)
        }

        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(r), i._onChange(o), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: s
            },
            modelViewMatrix: {
                value: new Xe
            },
            normalMatrix: {
                value: new ot
            }
        }), this.matrix = new Xe, this.matrixWorld = new Xe, this.matrixAutoUpdate = Ft.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new o0, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }
    onBeforeShadow() { }
    onAfterShadow() { }
    onBeforeRender() { }
    onAfterRender() { }
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Ga.setFromAxisAngle(e, t), this.quaternion.multiply(Ga), this
    }
    rotateOnWorldAxis(e, t) {
        return Ga.setFromAxisAngle(e, t), this.quaternion.premultiply(Ga), this
    }
    rotateX(e) {
        return this.rotateOnAxis(_v, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(vv, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(bv, e)
    }
    translateOnAxis(e, t) {
        return Av.copy(e).applyQuaternion(this.quaternion), this.position.add(Av.multiplyScalar(t)), this
    }
    translateX(e) {
        return this.translateOnAxis(_v, e)
    }
    translateY(e) {
        return this.translateOnAxis(vv, e)
    }
    translateZ(e) {
        return this.translateOnAxis(bv, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(er.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? md.copy(e) : md.set(e, t, i);
        const s = this.parent;
        this.updateWorldMatrix(!0, !1), hc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? er.lookAt(hc, md, this.up) : er.lookAt(md, hc, this.up), this.quaternion.setFromRotationMatrix(er), s && (er.extractRotation(s.matrixWorld), Ga.setFromRotationMatrix(er), this.quaternion.premultiply(Ga.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(xv), Ha.child = e, this.dispatchEvent(Ha), Ha.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(v2), Rp.child = e, this.dispatchEvent(Rp), Rp.child = null), this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1), er.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), er.multiply(e.parent.matrixWorld)), e.applyMatrix4(er), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(xv), Ha.child = e, this.dispatchEvent(Ha), Ha.child = null, this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, s = this.children.length; i < s; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0) return o
        }
    }
    getObjectsByProperty(e, t, i = []) {
        this[e] === t && i.push(this);
        const s = this.children;
        for (let r = 0, o = s.length; r < o; r++) s[r].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hc, e, A2), e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hc, _2, e), e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() { }
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, s = t.length; i < s; i++) t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        const t = this.children;
        for (let i = 0, s = t.length; i < s; i++) t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
        const t = this.children;
        for (let i = 0, s = t.length; i < s; i++) {
            const r = t[i];
            (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
            const s = this.children;
            for (let r = 0, o = s.length; r < o; r++) {
                const a = s[r];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string",
            i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const s = {};
        s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })), s.maxGeometryCount = this._maxGeometryCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (s.boundingSphere = {
            center: s.boundingSphere.center.toArray(),
            radius: s.boundingSphere.radius
        }), this.boundingBox !== null && (s.boundingBox = {
            min: s.boundingBox.min.toArray(),
            max: s.boundingBox.max.toArray()
        }));

        function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
        }
        if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            s.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const d = l[c];
                        r(e.shapes, d)
                    } else r(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++) a.push(r(e.materials, this.material[l]));
                s.material = a
            } else s.material = r(e.materials, this.material);
        if (this.children.length > 0) {
            s.children = [];
            for (let a = 0; a < this.children.length; a++) s.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            s.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                s.animations.push(r(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries),
                l = o(e.materials),
                c = o(e.textures),
                u = o(e.images),
                d = o(e.shapes),
                h = o(e.skeletons),
                f = o(e.animations),
                m = o(e.nodes);
            a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), d.length > 0 && (i.shapes = d), h.length > 0 && (i.skeletons = h), f.length > 0 && (i.animations = f), m.length > 0 && (i.nodes = m)
        }
        return i.object = s, i;

        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata, l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t = !0) {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const s = e.children[i];
                this.add(s.clone())
            }
        return this
    }
}
Ft.DEFAULT_UP = new z(0, 1, 0);
Ft.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const gs = new z,
    tr = new z,
    Pp = new z,
    ir = new z,
    Va = new z,
    Wa = new z,
    yv = new z,
    Dp = new z,
    Lp = new z,
    kp = new z;
class bs {
    constructor(e = new z, t = new z, i = new z) {
        this.a = e, this.b = t, this.c = i
    }
    static getNormal(e, t, i, s) {
        s.subVectors(i, t), gs.subVectors(e, t), s.cross(gs);
        const r = s.lengthSq();
        return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, s, r) {
        gs.subVectors(s, t), tr.subVectors(i, t), Pp.subVectors(e, t);
        const o = gs.dot(gs),
            a = gs.dot(tr),
            l = gs.dot(Pp),
            c = tr.dot(tr),
            u = tr.dot(Pp),
            d = o * c - a * a;
        if (d === 0) return r.set(0, 0, 0), null;
        const h = 1 / d,
            f = (c * l - a * u) * h,
            m = (o * u - a * l) * h;
        return r.set(1 - f - m, m, f)
    }
    static containsPoint(e, t, i, s) {
        return this.getBarycoord(e, t, i, s, ir) === null ? !1 : ir.x >= 0 && ir.y >= 0 && ir.x + ir.y <= 1
    }
    static getInterpolation(e, t, i, s, r, o, a, l) {
        return this.getBarycoord(e, t, i, s, ir) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, ir.x), l.addScaledVector(o, ir.y), l.addScaledVector(a, ir.z), l)
    }
    static isFrontFacing(e, t, i, s) {
        return gs.subVectors(i, t), tr.subVectors(e, t), gs.cross(tr).dot(s) < 0
    }
    set(e, t, i) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
    }
    setFromPointsAndIndices(e, t, i, s) {
        return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[s]), this
    }
    setFromAttributeAndIndices(e, t, i, s) {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, s), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
    }
    getArea() {
        return gs.subVectors(this.c, this.b), tr.subVectors(this.a, this.b), gs.cross(tr).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return bs.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return bs.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, i, s, r) {
        return bs.getInterpolation(e, this.a, this.b, this.c, t, i, s, r)
    }
    containsPoint(e) {
        return bs.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return bs.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a,
            s = this.b,
            r = this.c;
        let o, a;
        Va.subVectors(s, i), Wa.subVectors(r, i), Dp.subVectors(e, i);
        const l = Va.dot(Dp),
            c = Wa.dot(Dp);
        if (l <= 0 && c <= 0) return t.copy(i);
        Lp.subVectors(e, s);
        const u = Va.dot(Lp),
            d = Wa.dot(Lp);
        if (u >= 0 && d <= u) return t.copy(s);
        const h = l * d - u * c;
        if (h <= 0 && l >= 0 && u <= 0) return o = l / (l - u), t.copy(i).addScaledVector(Va, o);
        kp.subVectors(e, r);
        const f = Va.dot(kp),
            m = Wa.dot(kp);
        if (m >= 0 && f <= m) return t.copy(r);
        const g = f * c - l * m;
        if (g <= 0 && c >= 0 && m <= 0) return a = c / (c - m), t.copy(i).addScaledVector(Wa, a);
        const A = u * m - f * d;
        if (A <= 0 && d - u >= 0 && f - m >= 0) return yv.subVectors(r, s), a = (d - u) / (d - u + (f - m)), t.copy(s).addScaledVector(yv, a);
        const p = 1 / (A + g + h);
        return o = g * p, a = h * p, t.copy(i).addScaledVector(Va, o).addScaledVector(Wa, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Aw = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
},
    Nr = {
        h: 0,
        s: 0,
        l: 0
    },
    gd = {
        h: 0,
        s: 0,
        l: 0
    };

function Fp(n, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Ue {
    constructor(e, t, i) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const s = e;
            s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s)
        } else this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this
    }
    setHex(e, t = Wt) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, vt.toWorkingColorSpace(this, t), this
    }
    setRGB(e, t, i, s = vt.workingColorSpace) {
        return this.r = e, this.g = t, this.b = i, vt.toWorkingColorSpace(this, s), this
    }
    setHSL(e, t, i, s = vt.workingColorSpace) {
        if (e = r0(e, 1), t = fi(t, 0, 1), i = fi(i, 0, 1), t === 0) this.r = this.g = this.b = i;
        else {
            const r = i <= .5 ? i * (1 + t) : i + t - i * t,
                o = 2 * i - r;
            this.r = Fp(o, r, e + 1 / 3), this.g = Fp(o, r, e), this.b = Fp(o, r, e - 1 / 3)
        }
        return vt.toWorkingColorSpace(this, s), this
    }
    setStyle(e, t = Wt) {
        function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let s;
        if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let r;
            const o = s[1],
                a = s[2];
            switch (o) {
                case "rgb":
                case "rgba":
                    if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                    if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                    break;
                case "hsl":
                case "hsla":
                    if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                    break;
                default:
                    console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = s[1],
                o = r.length;
            if (o === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (o === 6) return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0) return this.setColorName(e, t);
        return this
    }
    setColorName(e, t = Wt) {
        const i = Aw[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this
    }
    copySRGBToLinear(e) {
        return this.r = Bl(e.r), this.g = Bl(e.g), this.b = Bl(e.b), this
    }
    copyLinearToSRGB(e) {
        return this.r = Ep(e.r), this.g = Ep(e.g), this.b = Ep(e.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex(e = Wt) {
        return vt.fromWorkingColorSpace(qi.copy(this), e), Math.round(fi(qi.r * 255, 0, 255)) * 65536 + Math.round(fi(qi.g * 255, 0, 255)) * 256 + Math.round(fi(qi.b * 255, 0, 255))
    }
    getHexString(e = Wt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t = vt.workingColorSpace) {
        vt.fromWorkingColorSpace(qi.copy(this), t);
        const i = qi.r,
            s = qi.g,
            r = qi.b,
            o = Math.max(i, s, r),
            a = Math.min(i, s, r);
        let l, c;
        const u = (a + o) / 2;
        if (a === o) l = 0, c = 0;
        else {
            const d = o - a;
            switch (c = u <= .5 ? d / (o + a) : d / (2 - o - a), o) {
                case i:
                    l = (s - r) / d + (s < r ? 6 : 0);
                    break;
                case s:
                    l = (r - i) / d + 2;
                    break;
                case r:
                    l = (i - s) / d + 4;
                    break
            }
            l /= 6
        }
        return e.h = l, e.s = c, e.l = u, e
    }
    getRGB(e, t = vt.workingColorSpace) {
        return vt.fromWorkingColorSpace(qi.copy(this), t), e.r = qi.r, e.g = qi.g, e.b = qi.b, e
    }
    getStyle(e = Wt) {
        vt.fromWorkingColorSpace(qi.copy(this), e);
        const t = qi.r,
            i = qi.g,
            s = qi.b;
        return e !== Wt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(s * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Nr), this.setHSL(Nr.h + e, Nr.s + t, Nr.l + i)
    }
    add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this
    }
    addColors(e, t) {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
    }
    addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
    }
    multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
    }
    multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this
    }
    lerpHSL(e, t) {
        this.getHSL(Nr), e.getHSL(gd);
        const i = Xc(Nr.h, gd.h, t),
            s = Xc(Nr.s, gd.s, t),
            r = Xc(Nr.l, gd.l, t);
        return this.setHSL(i, s, r), this
    }
    setFromVector3(e) {
        return this.r = e.x, this.g = e.y, this.b = e.z, this
    }
    applyMatrix3(e) {
        const t = this.r,
            i = this.g,
            s = this.b,
            r = e.elements;
        return this.r = r[0] * t + r[3] * i + r[6] * s, this.g = r[1] * t + r[4] * i + r[7] * s, this.b = r[2] * t + r[5] * i + r[8] * s, this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t = 0) {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
    }
    toJSON() {
        return this.getHex()
    } *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}
const qi = new Ue;
Ue.NAMES = Aw;
let b2 = 0;
class In extends Io {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: b2++
        }), this.uuid = us(), this.name = "", this.type = "Material", this.blending = Tl, this.side = wr, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = hg, this.blendDst = fg, this.blendEquation = ta, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ue(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Jh, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = lv, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Fa, this.stencilZFail = Fa, this.stencilZPass = Fa, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
    }
    onBuild() { }
    onBeforeRender() { }
    onBeforeCompile() { }
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const s = this[t];
                if (s === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                s && s.isColor ? s.set(i) : s && s.isVector3 && i && i.isVector3 ? s.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Tl && (i.blending = this.blending), this.side !== wr && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== hg && (i.blendSrc = this.blendSrc), this.blendDst !== fg && (i.blendDst = this.blendDst), this.blendEquation !== ta && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Jh && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== lv && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Fa && (i.stencilFail = this.stencilFail), this.stencilZFail !== Fa && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Fa && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);

        function s(r) {
            const o = [];
            for (const a in r) {
                const l = r[a];
                delete l.metadata, o.push(l)
            }
            return o
        }
        if (t) {
            const r = s(e.textures),
                o = s(e.images);
            r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const s = t.length;
            i = new Array(s);
            for (let r = 0; r !== s; ++r) i[r] = t[r].clone()
        }
        return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class pr extends In {
    constructor(e) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ue(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Cs, this.combine = XA, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
const cr = x2();

function x2() {
    const n = new ArrayBuffer(4),
        e = new Float32Array(n),
        t = new Uint32Array(n),
        i = new Uint32Array(512),
        s = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (i[l] = 0, i[l | 256] = 32768, s[l] = 24, s[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14, i[l | 256] = 1024 >> -c - 14 | 32768, s[l] = -c - 1, s[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10, i[l | 256] = c + 15 << 10 | 32768, s[l] = 13, s[l | 256] = 13) : c < 128 ? (i[l] = 31744, i[l | 256] = 64512, s[l] = 24, s[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, s[l] = 13, s[l | 256] = 13)
    }
    const r = new Uint32Array(2048),
        o = new Uint32Array(64),
        a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13,
            u = 0;
        for (; !(c & 8388608);) c <<= 1, u -= 8388608;
        c &= -8388609, u += 947912704, r[l] = c | u
    }
    for (let l = 1024; l < 2048; ++l) r[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l) o[l] = l << 23;
    o[31] = 1199570944, o[32] = 2147483648;
    for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: s,
        mantissaTable: r,
        exponentTable: o,
        offsetTable: a
    }
}

function y2(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = fi(n, -65504, 65504), cr.floatView[0] = n;
    const e = cr.uint32View[0],
        t = e >> 23 & 511;
    return cr.baseTable[t] + ((e & 8388607) >> cr.shiftTable[t])
}

function E2(n) {
    const e = n >> 10;
    return cr.uint32View[0] = cr.mantissaTable[cr.offsetTable[e] + (n & 1023)] + cr.exponentTable[e], cr.floatView[0]
}
const Ad = {
    toHalfFloat: y2,
    fromHalfFloat: E2
},
    ci = new z,
    _d = new _e;
class pi {
    constructor(e, t, i = !1) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = yg, this._updateRange = {
            offset: 0,
            count: -1
        }, this.updateRanges = [], this.gpuType = ei, this.version = 0
    }
    onUploadCallback() { }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return fw("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(e) {
        return this.usage = e, this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
    }
    copyAt(e, t, i) {
        e *= this.itemSize, i *= t.itemSize;
        for (let s = 0, r = this.itemSize; s < r; s++) this.array[e + s] = t.array[i + s];
        return this
    }
    copyArray(e) {
        return this.array.set(e), this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++) _d.fromBufferAttribute(this, t), _d.applyMatrix3(e), this.setXY(t, _d.x, _d.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++) ci.fromBufferAttribute(this, t), ci.applyMatrix3(e), this.setXYZ(t, ci.x, ci.y, ci.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++) ci.fromBufferAttribute(this, t), ci.applyMatrix4(e), this.setXYZ(t, ci.x, ci.y, ci.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) ci.fromBufferAttribute(this, t), ci.applyNormalMatrix(e), this.setXYZ(t, ci.x, ci.y, ci.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) ci.fromBufferAttribute(this, t), ci.transformDirection(e), this.setXYZ(t, ci.x, ci.y, ci.z);
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = vs(i, this.array)), i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize + t] = i, this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = vs(t, this.array)), t
    }
    setX(e, t) {
        return this.normalized && (t = St(t, this.array)), this.array[e * this.itemSize] = t, this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = vs(t, this.array)), t
    }
    setY(e, t) {
        return this.normalized && (t = St(t, this.array)), this.array[e * this.itemSize + 1] = t, this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = vs(t, this.array)), t
    }
    setZ(e, t) {
        return this.normalized && (t = St(t, this.array)), this.array[e * this.itemSize + 2] = t, this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = vs(t, this.array)), t
    }
    setW(e, t) {
        return this.normalized && (t = St(t, this.array)), this.array[e * this.itemSize + 3] = t, this
    }
    setXY(e, t, i) {
        return e *= this.itemSize, this.normalized && (t = St(t, this.array), i = St(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this
    }
    setXYZ(e, t, i, s) {
        return e *= this.itemSize, this.normalized && (t = St(t, this.array), i = St(i, this.array), s = St(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = s, this
    }
    setXYZW(e, t, i, s, r) {
        return e *= this.itemSize, this.normalized && (t = St(t, this.array), i = St(i, this.array), s = St(s, this.array), r = St(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = s, this.array[e + 3] = r, this
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name), this.usage !== yg && (e.usage = this.usage), e
    }
}
class _w extends pi {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class vw extends pi {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class xi extends pi {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let w2 = 0;
const Xn = new Xe,
    Np = new Ft,
    qa = new z,
    Dn = new Sr,
    fc = new Sr,
    Si = new z;
class Gi extends Io {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: w2++
        }), this.uuid = us(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (hw(e) ? vw : _w)(e, 1) : this.index = e, this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t, this
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i = 0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e, this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const r = new ot().getNormalMatrix(e);
            i.applyNormalMatrix(r), i.needsUpdate = !0
        }
        const s = this.attributes.tangent;
        return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    applyQuaternion(e) {
        return Xn.makeRotationFromQuaternion(e), this.applyMatrix4(Xn), this
    }
    rotateX(e) {
        return Xn.makeRotationX(e), this.applyMatrix4(Xn), this
    }
    rotateY(e) {
        return Xn.makeRotationY(e), this.applyMatrix4(Xn), this
    }
    rotateZ(e) {
        return Xn.makeRotationZ(e), this.applyMatrix4(Xn), this
    }
    translate(e, t, i) {
        return Xn.makeTranslation(e, t, i), this.applyMatrix4(Xn), this
    }
    scale(e, t, i) {
        return Xn.makeScale(e, t, i), this.applyMatrix4(Xn), this
    }
    lookAt(e) {
        return Np.lookAt(e), Np.updateMatrix(), this.applyMatrix4(Np.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(qa).negate(), this.translate(qa.x, qa.y, qa.z), this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, s = e.length; i < s; i++) {
            const r = e[i];
            t.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new xi(t, 3)), this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Sr);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new z(-1 / 0, -1 / 0, -1 / 0), new z(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t)
                for (let i = 0, s = t.length; i < s; i++) {
                    const r = t[i];
                    Dn.setFromBufferAttribute(r), this.morphTargetsRelative ? (Si.addVectors(this.boundingBox.min, Dn.min), this.boundingBox.expandByPoint(Si), Si.addVectors(this.boundingBox.max, Dn.max), this.boundingBox.expandByPoint(Si)) : (this.boundingBox.expandByPoint(Dn.min), this.boundingBox.expandByPoint(Dn.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new js);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new z, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Dn.setFromBufferAttribute(e), t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r];
                    fc.setFromBufferAttribute(a), this.morphTargetsRelative ? (Si.addVectors(Dn.min, fc.min), Dn.expandByPoint(Si), Si.addVectors(Dn.max, fc.max), Dn.expandByPoint(Si)) : (Dn.expandByPoint(fc.min), Dn.expandByPoint(fc.max))
                }
            Dn.getCenter(i);
            let s = 0;
            for (let r = 0, o = e.count; r < o; r++) Si.fromBufferAttribute(e, r), s = Math.max(s, i.distanceToSquared(Si));
            if (t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r],
                        l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++) Si.fromBufferAttribute(a, c), l && (qa.fromBufferAttribute(e, c), Si.add(qa)), s = Math.max(s, i.distanceToSquared(Si))
                }
            this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index,
            t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = t.position,
            s = t.normal,
            r = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new pi(new Float32Array(4 * i.count), 4));
        const o = this.getAttribute("tangent"),
            a = [],
            l = [];
        for (let S = 0; S < i.count; S++) a[S] = new z, l[S] = new z;
        const c = new z,
            u = new z,
            d = new z,
            h = new _e,
            f = new _e,
            m = new _e,
            g = new z,
            A = new z;

        function p(S, x, y) {
            c.fromBufferAttribute(i, S), u.fromBufferAttribute(i, x), d.fromBufferAttribute(i, y), h.fromBufferAttribute(r, S), f.fromBufferAttribute(r, x), m.fromBufferAttribute(r, y), u.sub(c), d.sub(c), f.sub(h), m.sub(h);
            const P = 1 / (f.x * m.y - m.x * f.y);
            isFinite(P) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(P), A.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(P), a[S].add(g), a[x].add(g), a[y].add(g), l[S].add(A), l[x].add(A), l[y].add(A))
        }
        let v = this.groups;
        v.length === 0 && (v = [{
            start: 0,
            count: e.count
        }]);
        for (let S = 0, x = v.length; S < x; ++S) {
            const y = v[S],
                P = y.start,
                T = y.count;
            for (let R = P, D = P + T; R < D; R += 3) p(e.getX(R + 0), e.getX(R + 1), e.getX(R + 2))
        }
        const _ = new z,
            b = new z,
            w = new z,
            E = new z;

        function C(S) {
            w.fromBufferAttribute(s, S), E.copy(w);
            const x = a[S];
            _.copy(x), _.sub(w.multiplyScalar(w.dot(x))).normalize(), b.crossVectors(E, x);
            const P = b.dot(l[S]) < 0 ? -1 : 1;
            o.setXYZW(S, _.x, _.y, _.z, P)
        }
        for (let S = 0, x = v.length; S < x; ++S) {
            const y = v[S],
                P = y.start,
                T = y.count;
            for (let R = P, D = P + T; R < D; R += 3) C(e.getX(R + 0)), C(e.getX(R + 1)), C(e.getX(R + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index,
            t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new pi(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
            else
                for (let h = 0, f = i.count; h < f; h++) i.setXYZ(h, 0, 0, 0);
            const s = new z,
                r = new z,
                o = new z,
                a = new z,
                l = new z,
                c = new z,
                u = new z,
                d = new z;
            if (e)
                for (let h = 0, f = e.count; h < f; h += 3) {
                    const m = e.getX(h + 0),
                        g = e.getX(h + 1),
                        A = e.getX(h + 2);
                    s.fromBufferAttribute(t, m), r.fromBufferAttribute(t, g), o.fromBufferAttribute(t, A), u.subVectors(o, r), d.subVectors(s, r), u.cross(d), a.fromBufferAttribute(i, m), l.fromBufferAttribute(i, g), c.fromBufferAttribute(i, A), a.add(u), l.add(u), c.add(u), i.setXYZ(m, a.x, a.y, a.z), i.setXYZ(g, l.x, l.y, l.z), i.setXYZ(A, c.x, c.y, c.z)
                } else
                for (let h = 0, f = t.count; h < f; h += 3) s.fromBufferAttribute(t, h + 0), r.fromBufferAttribute(t, h + 1), o.fromBufferAttribute(t, h + 2), u.subVectors(o, r), d.subVectors(s, r), u.cross(d), i.setXYZ(h + 0, u.x, u.y, u.z), i.setXYZ(h + 1, u.x, u.y, u.z), i.setXYZ(h + 2, u.x, u.y, u.z);
            this.normalizeNormals(), i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++) Si.fromBufferAttribute(e, t), Si.normalize(), e.setXYZ(t, Si.x, Si.y, Si.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array,
                u = a.itemSize,
                d = a.normalized,
                h = new c.constructor(l.length * u);
            let f = 0,
                m = 0;
            for (let g = 0, A = l.length; g < A; g++) {
                a.isInterleavedBufferAttribute ? f = l[g] * a.data.stride + a.offset : f = l[g] * u;
                for (let p = 0; p < u; p++) h[m++] = c[f++]
            }
            return new pi(h, u, d)
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const t = new Gi,
            i = this.index.array,
            s = this.attributes;
        for (const a in s) {
            const l = s[a],
                c = e(l, i);
            t.setAttribute(a, c)
        }
        const r = this.morphAttributes;
        for (const a in r) {
            const l = [],
                c = r[a];
            for (let u = 0, d = c.length; u < d; u++) {
                const h = c[u],
                    f = e(h, i);
                l.push(f)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const s = {};
        let r = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
                u = [];
            for (let d = 0, h = c.length; d < h; d++) {
                const f = c[d];
                u.push(f.toJSON(e.data))
            }
            u.length > 0 && (s[l] = u, r = !0)
        }
        r && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }), e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const s = e.attributes;
        for (const c in s) {
            const u = s[c];
            this.setAttribute(c, u.clone(t))
        }
        const r = e.morphAttributes;
        for (const c in r) {
            const u = [],
                d = r[c];
            for (let h = 0, f = d.length; h < f; h++) u.push(d[h].clone(t));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const d = o[c];
            this.addGroup(d.start, d.count, d.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Ev = new Xe,
    Go = new Wu,
    vd = new js,
    wv = new z,
    $a = new z,
    ja = new z,
    Ya = new z,
    Op = new z,
    bd = new z,
    xd = new _e,
    yd = new _e,
    Ed = new _e,
    Cv = new z,
    Sv = new z,
    Mv = new z,
    wd = new z,
    Cd = new z;
class Ri extends Ft {
    constructor(e = new Gi, t = new pr) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const s = t[i[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let r = 0, o = s.length; r < o; r++) {
                    const a = s[r].name || String(r);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry,
            s = i.attributes.position,
            r = i.morphAttributes.position,
            o = i.morphTargetsRelative;
        t.fromBufferAttribute(s, e);
        const a = this.morphTargetInfluences;
        if (r && a) {
            bd.set(0, 0, 0);
            for (let l = 0, c = r.length; l < c; l++) {
                const u = a[l],
                    d = r[l];
                u !== 0 && (Op.fromBufferAttribute(d, e), o ? bd.addScaledVector(Op, u) : bd.addScaledVector(Op.sub(t), u))
            }
            t.add(bd)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry,
            s = this.material,
            r = this.matrixWorld;
        s !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), vd.copy(i.boundingSphere), vd.applyMatrix4(r), Go.copy(e.ray).recast(e.near), !(vd.containsPoint(Go.origin) === !1 && (Go.intersectSphere(vd, wv) === null || Go.origin.distanceToSquared(wv) > (e.far - e.near) ** 2)) && (Ev.copy(r).invert(), Go.copy(e.ray).applyMatrix4(Ev), !(i.boundingBox !== null && Go.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Go)))
    }
    _computeIntersections(e, t, i) {
        let s;
        const r = this.geometry,
            o = this.material,
            a = r.index,
            l = r.attributes.position,
            c = r.attributes.uv,
            u = r.attributes.uv1,
            d = r.attributes.normal,
            h = r.groups,
            f = r.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let m = 0, g = h.length; m < g; m++) {
                    const A = h[m],
                        p = o[A.materialIndex],
                        v = Math.max(A.start, f.start),
                        _ = Math.min(a.count, Math.min(A.start + A.count, f.start + f.count));
                    for (let b = v, w = _; b < w; b += 3) {
                        const E = a.getX(b),
                            C = a.getX(b + 1),
                            S = a.getX(b + 2);
                        s = Sd(this, p, e, i, c, u, d, E, C, S), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = A.materialIndex, t.push(s))
                    }
                } else {
                const m = Math.max(0, f.start),
                    g = Math.min(a.count, f.start + f.count);
                for (let A = m, p = g; A < p; A += 3) {
                    const v = a.getX(A),
                        _ = a.getX(A + 1),
                        b = a.getX(A + 2);
                    s = Sd(this, o, e, i, c, u, d, v, _, b), s && (s.faceIndex = Math.floor(A / 3), t.push(s))
                }
            } else if (l !== void 0)
            if (Array.isArray(o))
                for (let m = 0, g = h.length; m < g; m++) {
                    const A = h[m],
                        p = o[A.materialIndex],
                        v = Math.max(A.start, f.start),
                        _ = Math.min(l.count, Math.min(A.start + A.count, f.start + f.count));
                    for (let b = v, w = _; b < w; b += 3) {
                        const E = b,
                            C = b + 1,
                            S = b + 2;
                        s = Sd(this, p, e, i, c, u, d, E, C, S), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = A.materialIndex, t.push(s))
                    }
                } else {
                const m = Math.max(0, f.start),
                    g = Math.min(l.count, f.start + f.count);
                for (let A = m, p = g; A < p; A += 3) {
                    const v = A,
                        _ = A + 1,
                        b = A + 2;
                    s = Sd(this, o, e, i, c, u, d, v, _, b), s && (s.faceIndex = Math.floor(A / 3), t.push(s))
                }
            }
    }
}

function C2(n, e, t, i, s, r, o, a) {
    let l;
    if (e.side === Mn ? l = i.intersectTriangle(o, r, s, !0, a) : l = i.intersectTriangle(s, r, o, e.side === wr, a), l === null) return null;
    Cd.copy(a), Cd.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo(Cd);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Cd.clone(),
        object: n
    }
}

function Sd(n, e, t, i, s, r, o, a, l, c) {
    n.getVertexPosition(a, $a), n.getVertexPosition(l, ja), n.getVertexPosition(c, Ya);
    const u = C2(n, e, t, i, $a, ja, Ya, wd);
    if (u) {
        s && (xd.fromBufferAttribute(s, a), yd.fromBufferAttribute(s, l), Ed.fromBufferAttribute(s, c), u.uv = bs.getInterpolation(wd, $a, ja, Ya, xd, yd, Ed, new _e)), r && (xd.fromBufferAttribute(r, a), yd.fromBufferAttribute(r, l), Ed.fromBufferAttribute(r, c), u.uv1 = bs.getInterpolation(wd, $a, ja, Ya, xd, yd, Ed, new _e)), o && (Cv.fromBufferAttribute(o, a), Sv.fromBufferAttribute(o, l), Mv.fromBufferAttribute(o, c), u.normal = bs.getInterpolation(wd, $a, ja, Ya, Cv, Sv, Mv, new z), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
        const d = {
            a,
            b: l,
            c,
            normal: new z,
            materialIndex: 0
        };
        bs.getNormal($a, ja, Ya, d.normal), u.face = d
    }
    return u
}
class qu extends Gi {
    constructor(e = 1, t = 1, i = 1, s = 1, r = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: s,
            heightSegments: r,
            depthSegments: o
        };
        const a = this;
        s = Math.floor(s), r = Math.floor(r), o = Math.floor(o);
        const l = [],
            c = [],
            u = [],
            d = [];
        let h = 0,
            f = 0;
        m("z", "y", "x", -1, -1, i, t, e, o, r, 0), m("z", "y", "x", 1, -1, i, t, -e, o, r, 1), m("x", "z", "y", 1, 1, e, i, t, s, o, 2), m("x", "z", "y", 1, -1, e, i, -t, s, o, 3), m("x", "y", "z", 1, -1, e, t, i, s, r, 4), m("x", "y", "z", -1, -1, e, t, -i, s, r, 5), this.setIndex(l), this.setAttribute("position", new xi(c, 3)), this.setAttribute("normal", new xi(u, 3)), this.setAttribute("uv", new xi(d, 2));

        function m(g, A, p, v, _, b, w, E, C, S, x) {
            const y = b / C,
                P = w / S,
                T = b / 2,
                R = w / 2,
                D = E / 2,
                U = C + 1,
                Q = S + 1;
            let F = 0,
                L = 0;
            const W = new z;
            for (let k = 0; k < Q; k++) {
                const $ = k * P - R;
                for (let X = 0; X < U; X++) {
                    const le = X * y - T;
                    W[g] = le * v, W[A] = $ * _, W[p] = D, c.push(W.x, W.y, W.z), W[g] = 0, W[A] = 0, W[p] = E > 0 ? 1 : -1, u.push(W.x, W.y, W.z), d.push(X / C), d.push(1 - k / S), F += 1
                }
            }
            for (let k = 0; k < S; k++)
                for (let $ = 0; $ < C; $++) {
                    const X = h + $ + U * k,
                        le = h + $ + U * (k + 1),
                        K = h + ($ + 1) + U * (k + 1),
                        te = h + ($ + 1) + U * k;
                    l.push(X, le, te), l.push(le, K, te), L += 6
                }
            a.addGroup(f, L, x), f += L, h += F
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new qu(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
    }
}

function ql(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const s = n[t][i];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = s.clone() : Array.isArray(s) ? e[t][i] = s.slice() : e[t][i] = s
        }
    }
    return e
}

function rn(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = ql(n[t]);
        for (const s in i) e[s] = i[s]
    }
    return e
}

function S2(n) {
    const e = [];
    for (let t = 0; t < n.length; t++) e.push(n[t].clone());
    return e
}

function bw(n) {
    const e = n.getRenderTarget();
    return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : vt.workingColorSpace
}
const wo = {
    clone: ql,
    merge: rn
};
var M2 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    T2 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ti extends In {
    constructor(e) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = M2, this.fragmentShader = T2, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ql(e.uniforms), this.uniformsGroups = S2(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion, t.uniforms = {};
        for (const s in this.uniforms) {
            const o = this.uniforms[s].value;
            o && o.isTexture ? t.uniforms[s] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[s] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[s] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[s] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[s] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[s] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[s] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[s] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
        const i = {};
        for (const s in this.extensions) this.extensions[s] === !0 && (i[s] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i), t
    }
}
let a0 = class extends Ft {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Xe, this.projectionMatrix = new Xe, this.projectionMatrixInverse = new Xe, this.coordinateSystem = fr
    }
    copy(e, t) {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
};
const Or = new z,
    Tv = new _e,
    Iv = new _e;
class cn extends a0 {
    constructor(e = 50, t = 1, i = .1, s = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = s, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Wl * 2 * Math.atan(t), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Yc * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Wl * 2 * Math.atan(Math.tan(Yc * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, i) {
        Or.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Or.x, Or.y).multiplyScalar(-e / Or.z), Or.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(Or.x, Or.y).multiplyScalar(-e / Or.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, Tv, Iv), t.subVectors(Iv, Tv)
    }
    setViewOffset(e, t, i, s, r, o) {
        this.aspect = e / t, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Yc * .5 * this.fov) / this.zoom,
            i = 2 * t,
            s = this.aspect * i,
            r = -.5 * s;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
                c = o.fullHeight;
            r += o.offsetX * s / l, t -= o.offsetY * i / c, s *= o.width / l, i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
    }
}
const Xa = -90,
    Ka = 1;
class I2 extends Ft {
    constructor(e, t, i) {
        super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
        const s = new cn(Xa, Ka, e, t);
        s.layers = this.layers, this.add(s);
        const r = new cn(Xa, Ka, e, t);
        r.layers = this.layers, this.add(r);
        const o = new cn(Xa, Ka, e, t);
        o.layers = this.layers, this.add(o);
        const a = new cn(Xa, Ka, e, t);
        a.layers = this.layers, this.add(a);
        const l = new cn(Xa, Ka, e, t);
        l.layers = this.layers, this.add(l);
        const c = new cn(Xa, Ka, e, t);
        c.layers = this.layers, this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem,
            t = this.children.concat(),
            [i, s, r, o, a, l] = t;
        for (const c of t) this.remove(c);
        if (e === fr) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
        else if (e === af) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
        else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t) this.add(c), c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {
            renderTarget: i,
            activeMipmapLevel: s
        } = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
        const [r, o, a, l, c, u] = this.children, d = e.getRenderTarget(), h = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
        e.xr.enabled = !1;
        const g = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, s), e.render(t, r), e.setRenderTarget(i, 1, s), e.render(t, o), e.setRenderTarget(i, 2, s), e.render(t, a), e.setRenderTarget(i, 3, s), e.render(t, l), e.setRenderTarget(i, 4, s), e.render(t, c), i.texture.generateMipmaps = g, e.setRenderTarget(i, 5, s), e.render(t, u), e.setRenderTarget(d, h, f), e.xr.enabled = m, i.texture.needsPMREMUpdate = !0
    }
}
class l0 extends oi {
    constructor(e, t, i, s, r, o, a, l, c, u) {
        e = e !== void 0 ? e : [], t = t !== void 0 ? t : ya, super(e, t, i, s, r, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class B2 extends mn {
    constructor(e = 1, t = {}) {
        super(e, e, t), this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        },
            s = [i, i, i, i, i, i];
        this.texture = new l0(s, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Pt
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        },
            s = new qu(5, 5, 5),
            r = new ti({
                name: "CubemapFromEquirect",
                uniforms: ql(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: Mn,
                blending: Hs
            });
        r.uniforms.tEquirect.value = t;
        const o = new Ri(s, r),
            a = t.minFilter;
        return t.minFilter === ys && (t.minFilter = Pt), new I2(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
    }
    clear(e, t, i, s) {
        const r = e.getRenderTarget();
        for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, s);
        e.setRenderTarget(r)
    }
}
const Up = new z,
    R2 = new z,
    P2 = new ot;
class $r {
    constructor(e = new z(1, 0, 0), t = 0) {
        this.isPlane = !0, this.normal = e, this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e), this.constant = t, this
    }
    setComponents(e, t, i, s) {
        return this.normal.set(e, t, i), this.constant = s, this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this
    }
    setFromCoplanarPoints(e, t, i) {
        const s = Up.subVectors(i, t).cross(R2.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(s, e), this
    }
    copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(Up),
            s = this.normal.dot(i);
        if (s === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / s;
        return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
            i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || P2.getNormalMatrix(e),
            s = this.coplanarPoint(Up).applyMatrix4(e),
            r = this.normal.applyMatrix3(i).normalize();
        return this.constant = -s.dot(r), this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal), this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ho = new js,
    Md = new z;
class Qf {
    constructor(e = new $r, t = new $r, i = new $r, s = new $r, r = new $r, o = new $r) {
        this.planes = [e, t, i, s, r, o]
    }
    set(e, t, i, s, r, o) {
        const a = this.planes;
        return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(s), a[4].copy(r), a[5].copy(o), this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t = fr) {
        const i = this.planes,
            s = e.elements,
            r = s[0],
            o = s[1],
            a = s[2],
            l = s[3],
            c = s[4],
            u = s[5],
            d = s[6],
            h = s[7],
            f = s[8],
            m = s[9],
            g = s[10],
            A = s[11],
            p = s[12],
            v = s[13],
            _ = s[14],
            b = s[15];
        if (i[0].setComponents(l - r, h - c, A - f, b - p).normalize(), i[1].setComponents(l + r, h + c, A + f, b + p).normalize(), i[2].setComponents(l + o, h + u, A + m, b + v).normalize(), i[3].setComponents(l - o, h - u, A - m, b - v).normalize(), i[4].setComponents(l - a, h - d, A - g, b - _).normalize(), t === fr) i[5].setComponents(l + a, h + d, A + g, b + _).normalize();
        else if (t === af) i[5].setComponents(a, d, g, _).normalize();
        else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ho.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(), Ho.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Ho)
    }
    intersectsSprite(e) {
        return Ho.center.set(0, 0, 0), Ho.radius = .7071067811865476, Ho.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ho)
    }
    intersectsSphere(e) {
        const t = this.planes,
            i = e.center,
            s = -e.radius;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(i) < s) return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const s = t[i];
            if (Md.x = s.normal.x > 0 ? e.max.x : e.min.x, Md.y = s.normal.y > 0 ? e.max.y : e.min.y, Md.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(Md) < 0) return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0) return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}

function xw() {
    let n = null,
        e = !1,
        t = null,
        i = null;

    function s(r, o) {
        t(r, o), i = n.requestAnimationFrame(s)
    }
    return {
        start: function () {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(s), e = !0)
        },
        stop: function () {
            n.cancelAnimationFrame(i), e = !1
        },
        setAnimationLoop: function (r) {
            t = r
        },
        setContext: function (r) {
            n = r
        }
    }
}

function D2(n) {
    const e = new WeakMap;

    function t(a, l) {
        const c = a.array,
            u = a.usage,
            d = c.byteLength,
            h = n.createBuffer();
        n.bindBuffer(l, h), n.bufferData(l, c, u), a.onUploadCallback();
        let f;
        if (c instanceof Float32Array) f = n.FLOAT;
        else if (c instanceof Uint16Array) a.isFloat16BufferAttribute ? f = n.HALF_FLOAT : f = n.UNSIGNED_SHORT;
        else if (c instanceof Int16Array) f = n.SHORT;
        else if (c instanceof Uint32Array) f = n.UNSIGNED_INT;
        else if (c instanceof Int32Array) f = n.INT;
        else if (c instanceof Int8Array) f = n.BYTE;
        else if (c instanceof Uint8Array) f = n.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray) f = n.UNSIGNED_BYTE;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: h,
            type: f,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: d
        }
    }

    function i(a, l, c) {
        const u = l.array,
            d = l._updateRange,
            h = l.updateRanges;
        if (n.bindBuffer(c, a), d.count === -1 && h.length === 0 && n.bufferSubData(c, 0, u), h.length !== 0) {
            for (let f = 0, m = h.length; f < m; f++) {
                const g = h[f];
                n.bufferSubData(c, g.start * u.BYTES_PER_ELEMENT, u, g.start, g.count)
            }
            l.clearUpdateRanges()
        }
        d.count !== -1 && (n.bufferSubData(c, d.offset * u.BYTES_PER_ELEMENT, u, d.offset, d.count), d.count = -1), l.onUploadCallback()
    }

    function s(a) {
        return a.isInterleavedBufferAttribute && (a = a.data), e.get(a)
    }

    function r(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (n.deleteBuffer(l.buffer), e.delete(a))
    }

    function o(a, l) {
        if (a.isGLBufferAttribute) {
            const u = e.get(a);
            (!u || u.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        a.isInterleavedBufferAttribute && (a = a.data);
        const c = e.get(a);
        if (c === void 0) e.set(a, t(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(c.buffer, a, l), c.version = a.version
        }
    }
    return {
        get: s,
        remove: r,
        update: o
    }
}
class $u extends Gi {
    constructor(e = 1, t = 1, i = 1, s = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: s
        };
        const r = e / 2,
            o = t / 2,
            a = Math.floor(i),
            l = Math.floor(s),
            c = a + 1,
            u = l + 1,
            d = e / a,
            h = t / l,
            f = [],
            m = [],
            g = [],
            A = [];
        for (let p = 0; p < u; p++) {
            const v = p * h - o;
            for (let _ = 0; _ < c; _++) {
                const b = _ * d - r;
                m.push(b, -v, 0), g.push(0, 0, 1), A.push(_ / a), A.push(1 - p / l)
            }
        }
        for (let p = 0; p < l; p++)
            for (let v = 0; v < a; v++) {
                const _ = v + c * p,
                    b = v + c * (p + 1),
                    w = v + 1 + c * (p + 1),
                    E = v + 1 + c * p;
                f.push(_, b, E), f.push(b, w, E)
            }
        this.setIndex(f), this.setAttribute("position", new xi(m, 3)), this.setAttribute("normal", new xi(g, 3)), this.setAttribute("uv", new xi(A, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new $u(e.width, e.height, e.widthSegments, e.heightSegments)
    }
}
var L2 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
    k2 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
    F2 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
    N2 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    O2 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
    U2 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    Q2 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    z2 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    G2 = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    H2 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
    V2 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
    W2 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    q2 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
    $2 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    j2 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    Y2 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
    X2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    K2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    J2 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    Z2 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    eP = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    tP = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    iP = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    nP = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
    sP = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    rP = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    oP = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    aP = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
    lP = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    cP = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    uP = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    dP = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
    hP = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    fP = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    pP = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    mP = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    gP = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    AP = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    _P = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    vP = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    bP = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    xP = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    yP = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    EP = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    wP = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    CP = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    SP = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    MP = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
    TP = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    IP = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    BP = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    RP = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    PP = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
    DP = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    LP = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    kP = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    FP = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
    NP = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    OP = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    UP = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    QP = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
    zP = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    GP = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    HP = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    VP = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    WP = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    qP = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    $P = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
    jP = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    YP = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    XP = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    KP = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    JP = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
    ZP = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    eD = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    tD = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    iD = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    nD = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
    sD = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
    rD = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
    oD = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
    aD = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    lD = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    cD = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
    uD = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    dD = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    hD = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    fD = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    pD = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    mD = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    gD = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`,
    AD = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    _D = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    vD = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    bD = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    xD = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    yD = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    ED = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    wD = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    CD = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    SD = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    MD = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, newPeak * vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    TD = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
    ID = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
    BD = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    RD = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    PD = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
    DD = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const LD = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    kD = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    FD = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    ND = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    OD = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    UD = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    QD = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    zD = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    GD = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    HD = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    VD = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    WD = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    qD = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    $D = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    jD = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    YD = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    XD = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    KD = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    JD = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    ZD = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    eL = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    tL = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    iL = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    nL = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    sL = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    rL = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    oL = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    aL = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    lL = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    cL = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    uL = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    dL = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    hL = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    fL = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    Je = {
        alphahash_fragment: L2,
        alphahash_pars_fragment: k2,
        alphamap_fragment: F2,
        alphamap_pars_fragment: N2,
        alphatest_fragment: O2,
        alphatest_pars_fragment: U2,
        aomap_fragment: Q2,
        aomap_pars_fragment: z2,
        batching_pars_vertex: G2,
        batching_vertex: H2,
        begin_vertex: V2,
        beginnormal_vertex: W2,
        bsdfs: q2,
        iridescence_fragment: $2,
        bumpmap_pars_fragment: j2,
        clipping_planes_fragment: Y2,
        clipping_planes_pars_fragment: X2,
        clipping_planes_pars_vertex: K2,
        clipping_planes_vertex: J2,
        color_fragment: Z2,
        color_pars_fragment: eP,
        color_pars_vertex: tP,
        color_vertex: iP,
        common: nP,
        cube_uv_reflection_fragment: sP,
        defaultnormal_vertex: rP,
        displacementmap_pars_vertex: oP,
        displacementmap_vertex: aP,
        emissivemap_fragment: lP,
        emissivemap_pars_fragment: cP,
        colorspace_fragment: uP,
        colorspace_pars_fragment: dP,
        envmap_fragment: hP,
        envmap_common_pars_fragment: fP,
        envmap_pars_fragment: pP,
        envmap_pars_vertex: mP,
        envmap_physical_pars_fragment: MP,
        envmap_vertex: gP,
        fog_vertex: AP,
        fog_pars_vertex: _P,
        fog_fragment: vP,
        fog_pars_fragment: bP,
        gradientmap_pars_fragment: xP,
        lightmap_fragment: yP,
        lightmap_pars_fragment: EP,
        lights_lambert_fragment: wP,
        lights_lambert_pars_fragment: CP,
        lights_pars_begin: SP,
        lights_toon_fragment: TP,
        lights_toon_pars_fragment: IP,
        lights_phong_fragment: BP,
        lights_phong_pars_fragment: RP,
        lights_physical_fragment: PP,
        lights_physical_pars_fragment: DP,
        lights_fragment_begin: LP,
        lights_fragment_maps: kP,
        lights_fragment_end: FP,
        logdepthbuf_fragment: NP,
        logdepthbuf_pars_fragment: OP,
        logdepthbuf_pars_vertex: UP,
        logdepthbuf_vertex: QP,
        map_fragment: zP,
        map_pars_fragment: GP,
        map_particle_fragment: HP,
        map_particle_pars_fragment: VP,
        metalnessmap_fragment: WP,
        metalnessmap_pars_fragment: qP,
        morphinstance_vertex: $P,
        morphcolor_vertex: jP,
        morphnormal_vertex: YP,
        morphtarget_pars_vertex: XP,
        morphtarget_vertex: KP,
        normal_fragment_begin: JP,
        normal_fragment_maps: ZP,
        normal_pars_fragment: eD,
        normal_pars_vertex: tD,
        normal_vertex: iD,
        normalmap_pars_fragment: nD,
        clearcoat_normal_fragment_begin: sD,
        clearcoat_normal_fragment_maps: rD,
        clearcoat_pars_fragment: oD,
        iridescence_pars_fragment: aD,
        opaque_fragment: lD,
        packing: cD,
        premultiplied_alpha_fragment: uD,
        project_vertex: dD,
        dithering_fragment: hD,
        dithering_pars_fragment: fD,
        roughnessmap_fragment: pD,
        roughnessmap_pars_fragment: mD,
        shadowmap_pars_fragment: gD,
        shadowmap_pars_vertex: AD,
        shadowmap_vertex: _D,
        shadowmask_pars_fragment: vD,
        skinbase_vertex: bD,
        skinning_pars_vertex: xD,
        skinning_vertex: yD,
        skinnormal_vertex: ED,
        specularmap_fragment: wD,
        specularmap_pars_fragment: CD,
        tonemapping_fragment: SD,
        tonemapping_pars_fragment: MD,
        transmission_fragment: TD,
        transmission_pars_fragment: ID,
        uv_pars_fragment: BD,
        uv_pars_vertex: RD,
        uv_vertex: PD,
        worldpos_vertex: DD,
        background_vert: LD,
        background_frag: kD,
        backgroundCube_vert: FD,
        backgroundCube_frag: ND,
        cube_vert: OD,
        cube_frag: UD,
        depth_vert: QD,
        depth_frag: zD,
        distanceRGBA_vert: GD,
        distanceRGBA_frag: HD,
        equirect_vert: VD,
        equirect_frag: WD,
        linedashed_vert: qD,
        linedashed_frag: $D,
        meshbasic_vert: jD,
        meshbasic_frag: YD,
        meshlambert_vert: XD,
        meshlambert_frag: KD,
        meshmatcap_vert: JD,
        meshmatcap_frag: ZD,
        meshnormal_vert: eL,
        meshnormal_frag: tL,
        meshphong_vert: iL,
        meshphong_frag: nL,
        meshphysical_vert: sL,
        meshphysical_frag: rL,
        meshtoon_vert: oL,
        meshtoon_frag: aL,
        points_vert: lL,
        points_frag: cL,
        shadow_vert: uL,
        shadow_frag: dL,
        sprite_vert: hL,
        sprite_frag: fL
    },
    Ie = {
        common: {
            diffuse: {
                value: new Ue(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new ot
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new ot
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new ot
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new ot
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new ot
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new ot
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new ot
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new ot
            },
            normalScale: {
                value: new _e(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new ot
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new ot
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new ot
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new ot
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Ue(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Ue(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new ot
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new ot
            }
        },
        sprite: {
            diffuse: {
                value: new Ue(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new _e(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new ot
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new ot
            },
            alphaTest: {
                value: 0
            }
        }
    },
    Ds = {
        basic: {
            uniforms: rn([Ie.common, Ie.specularmap, Ie.envmap, Ie.aomap, Ie.lightmap, Ie.fog]),
            vertexShader: Je.meshbasic_vert,
            fragmentShader: Je.meshbasic_frag
        },
        lambert: {
            uniforms: rn([Ie.common, Ie.specularmap, Ie.envmap, Ie.aomap, Ie.lightmap, Ie.emissivemap, Ie.bumpmap, Ie.normalmap, Ie.displacementmap, Ie.fog, Ie.lights, {
                emissive: {
                    value: new Ue(0)
                }
            }]),
            vertexShader: Je.meshlambert_vert,
            fragmentShader: Je.meshlambert_frag
        },
        phong: {
            uniforms: rn([Ie.common, Ie.specularmap, Ie.envmap, Ie.aomap, Ie.lightmap, Ie.emissivemap, Ie.bumpmap, Ie.normalmap, Ie.displacementmap, Ie.fog, Ie.lights, {
                emissive: {
                    value: new Ue(0)
                },
                specular: {
                    value: new Ue(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Je.meshphong_vert,
            fragmentShader: Je.meshphong_frag
        },
        standard: {
            uniforms: rn([Ie.common, Ie.envmap, Ie.aomap, Ie.lightmap, Ie.emissivemap, Ie.bumpmap, Ie.normalmap, Ie.displacementmap, Ie.roughnessmap, Ie.metalnessmap, Ie.fog, Ie.lights, {
                emissive: {
                    value: new Ue(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Je.meshphysical_vert,
            fragmentShader: Je.meshphysical_frag
        },
        toon: {
            uniforms: rn([Ie.common, Ie.aomap, Ie.lightmap, Ie.emissivemap, Ie.bumpmap, Ie.normalmap, Ie.displacementmap, Ie.gradientmap, Ie.fog, Ie.lights, {
                emissive: {
                    value: new Ue(0)
                }
            }]),
            vertexShader: Je.meshtoon_vert,
            fragmentShader: Je.meshtoon_frag
        },
        matcap: {
            uniforms: rn([Ie.common, Ie.bumpmap, Ie.normalmap, Ie.displacementmap, Ie.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Je.meshmatcap_vert,
            fragmentShader: Je.meshmatcap_frag
        },
        points: {
            uniforms: rn([Ie.points, Ie.fog]),
            vertexShader: Je.points_vert,
            fragmentShader: Je.points_frag
        },
        dashed: {
            uniforms: rn([Ie.common, Ie.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Je.linedashed_vert,
            fragmentShader: Je.linedashed_frag
        },
        depth: {
            uniforms: rn([Ie.common, Ie.displacementmap]),
            vertexShader: Je.depth_vert,
            fragmentShader: Je.depth_frag
        },
        normal: {
            uniforms: rn([Ie.common, Ie.bumpmap, Ie.normalmap, Ie.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Je.meshnormal_vert,
            fragmentShader: Je.meshnormal_frag
        },
        sprite: {
            uniforms: rn([Ie.sprite, Ie.fog]),
            vertexShader: Je.sprite_vert,
            fragmentShader: Je.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new ot
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: Je.background_vert,
            fragmentShader: Je.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new ot
                }
            },
            vertexShader: Je.backgroundCube_vert,
            fragmentShader: Je.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Je.cube_vert,
            fragmentShader: Je.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Je.equirect_vert,
            fragmentShader: Je.equirect_frag
        },
        distanceRGBA: {
            uniforms: rn([Ie.common, Ie.displacementmap, {
                referencePosition: {
                    value: new z
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Je.distanceRGBA_vert,
            fragmentShader: Je.distanceRGBA_frag
        },
        shadow: {
            uniforms: rn([Ie.lights, Ie.fog, {
                color: {
                    value: new Ue(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Je.shadow_vert,
            fragmentShader: Je.shadow_frag
        }
    };
Ds.physical = {
    uniforms: rn([Ds.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new ot
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new ot
        },
        clearcoatNormalScale: {
            value: new _e(1, 1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new ot
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new ot
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new ot
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Ue(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new ot
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new ot
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new ot
        },
        transmissionSamplerSize: {
            value: new _e
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new ot
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Ue(0)
        },
        specularColor: {
            value: new Ue(1, 1, 1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new ot
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new ot
        },
        anisotropyVector: {
            value: new _e
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new ot
        }
    }]),
    vertexShader: Je.meshphysical_vert,
    fragmentShader: Je.meshphysical_frag
};
const Td = {
    r: 0,
    b: 0,
    g: 0
},
    Vo = new Cs,
    pL = new Xe;

function mL(n, e, t, i, s, r, o) {
    const a = new Ue(0);
    let l = r === !0 ? 0 : 1,
        c, u, d = null,
        h = 0,
        f = null;

    function m(A, p) {
        let v = !1,
            _ = p.isScene === !0 ? p.background : null;
        _ && _.isTexture && (_ = (p.backgroundBlurriness > 0 ? t : e).get(_)), _ === null ? g(a, l) : _ && _.isColor && (g(_, 1), v = !0);
        const b = n.xr.getEnvironmentBlendMode();
        b === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : b === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (n.autoClear || v) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), _ && (_.isCubeTexture || _.mapping === Of) ? (u === void 0 && (u = new Ri(new qu(1, 1, 1), new ti({
            name: "BackgroundCubeMaterial",
            uniforms: ql(Ds.backgroundCube.uniforms),
            vertexShader: Ds.backgroundCube.vertexShader,
            fragmentShader: Ds.backgroundCube.fragmentShader,
            side: Mn,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (w, E, C) {
            this.matrixWorld.copyPosition(C.matrixWorld)
        }, Object.defineProperty(u.material, "envMap", {
            get: function () {
                return this.uniforms.envMap.value
            }
        }), s.update(u)), Vo.copy(p.backgroundRotation), Vo.x *= -1, Vo.y *= -1, Vo.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (Vo.y *= -1, Vo.z *= -1), u.material.uniforms.envMap.value = _, u.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = p.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(pL.makeRotationFromEuler(Vo)), u.material.toneMapped = vt.getTransfer(_.colorSpace) !== Lt, (d !== _ || h !== _.version || f !== n.toneMapping) && (u.material.needsUpdate = !0, d = _, h = _.version, f = n.toneMapping), u.layers.enableAll(), A.unshift(u, u.geometry, u.material, 0, 0, null)) : _ && _.isTexture && (c === void 0 && (c = new Ri(new $u(2, 2), new ti({
            name: "BackgroundMaterial",
            uniforms: ql(Ds.background.uniforms),
            vertexShader: Ds.background.vertexShader,
            fragmentShader: Ds.background.fragmentShader,
            side: wr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function () {
                return this.uniforms.t2D.value
            }
        }), s.update(c)), c.material.uniforms.t2D.value = _, c.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, c.material.toneMapped = vt.getTransfer(_.colorSpace) !== Lt, _.matrixAutoUpdate === !0 && _.updateMatrix(), c.material.uniforms.uvTransform.value.copy(_.matrix), (d !== _ || h !== _.version || f !== n.toneMapping) && (c.material.needsUpdate = !0, d = _, h = _.version, f = n.toneMapping), c.layers.enableAll(), A.unshift(c, c.geometry, c.material, 0, 0, null))
    }

    function g(A, p) {
        A.getRGB(Td, bw(n)), i.buffers.color.setClear(Td.r, Td.g, Td.b, p, o)
    }
    return {
        getClearColor: function () {
            return a
        },
        setClearColor: function (A, p = 1) {
            a.set(A), l = p, g(a, l)
        },
        getClearAlpha: function () {
            return l
        },
        setClearAlpha: function (A) {
            l = A, g(a, l)
        },
        render: m
    }
}

function gL(n, e) {
    const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
        i = {},
        s = h(null);
    let r = s,
        o = !1;

    function a(y, P, T, R, D) {
        let U = !1;
        const Q = d(R, T, P);
        r !== Q && (r = Q, c(r.object)), U = f(y, R, T, D), U && m(y, R, T, D), D !== null && e.update(D, n.ELEMENT_ARRAY_BUFFER), (U || o) && (o = !1, b(y, P, T, R), D !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(D).buffer))
    }

    function l() {
        return n.createVertexArray()
    }

    function c(y) {
        return n.bindVertexArray(y)
    }

    function u(y) {
        return n.deleteVertexArray(y)
    }

    function d(y, P, T) {
        const R = T.wireframe === !0;
        let D = i[y.id];
        D === void 0 && (D = {}, i[y.id] = D);
        let U = D[P.id];
        U === void 0 && (U = {}, D[P.id] = U);
        let Q = U[R];
        return Q === void 0 && (Q = h(l()), U[R] = Q), Q
    }

    function h(y) {
        const P = [],
            T = [],
            R = [];
        for (let D = 0; D < t; D++) P[D] = 0, T[D] = 0, R[D] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: P,
            enabledAttributes: T,
            attributeDivisors: R,
            object: y,
            attributes: {},
            index: null
        }
    }

    function f(y, P, T, R) {
        const D = r.attributes,
            U = P.attributes;
        let Q = 0;
        const F = T.getAttributes();
        for (const L in F)
            if (F[L].location >= 0) {
                const k = D[L];
                let $ = U[L];
                if ($ === void 0 && (L === "instanceMatrix" && y.instanceMatrix && ($ = y.instanceMatrix), L === "instanceColor" && y.instanceColor && ($ = y.instanceColor)), k === void 0 || k.attribute !== $ || $ && k.data !== $.data) return !0;
                Q++
            }
        return r.attributesNum !== Q || r.index !== R
    }

    function m(y, P, T, R) {
        const D = {},
            U = P.attributes;
        let Q = 0;
        const F = T.getAttributes();
        for (const L in F)
            if (F[L].location >= 0) {
                let k = U[L];
                k === void 0 && (L === "instanceMatrix" && y.instanceMatrix && (k = y.instanceMatrix), L === "instanceColor" && y.instanceColor && (k = y.instanceColor));
                const $ = {};
                $.attribute = k, k && k.data && ($.data = k.data), D[L] = $, Q++
            }
        r.attributes = D, r.attributesNum = Q, r.index = R
    }

    function g() {
        const y = r.newAttributes;
        for (let P = 0, T = y.length; P < T; P++) y[P] = 0
    }

    function A(y) {
        p(y, 0)
    }

    function p(y, P) {
        const T = r.newAttributes,
            R = r.enabledAttributes,
            D = r.attributeDivisors;
        T[y] = 1, R[y] === 0 && (n.enableVertexAttribArray(y), R[y] = 1), D[y] !== P && (n.vertexAttribDivisor(y, P), D[y] = P)
    }

    function v() {
        const y = r.newAttributes,
            P = r.enabledAttributes;
        for (let T = 0, R = P.length; T < R; T++) P[T] !== y[T] && (n.disableVertexAttribArray(T), P[T] = 0)
    }

    function _(y, P, T, R, D, U, Q) {
        Q === !0 ? n.vertexAttribIPointer(y, P, T, D, U) : n.vertexAttribPointer(y, P, T, R, D, U)
    }

    function b(y, P, T, R) {
        g();
        const D = R.attributes,
            U = T.getAttributes(),
            Q = P.defaultAttributeValues;
        for (const F in U) {
            const L = U[F];
            if (L.location >= 0) {
                let W = D[F];
                if (W === void 0 && (F === "instanceMatrix" && y.instanceMatrix && (W = y.instanceMatrix), F === "instanceColor" && y.instanceColor && (W = y.instanceColor)), W !== void 0) {
                    const k = W.normalized,
                        $ = W.itemSize,
                        X = e.get(W);
                    if (X === void 0) continue;
                    const le = X.buffer,
                        K = X.type,
                        te = X.bytesPerElement,
                        ue = K === n.INT || K === n.UNSIGNED_INT || W.gpuType === nw;
                    if (W.isInterleavedBufferAttribute) {
                        const fe = W.data,
                            Me = fe.stride,
                            Be = W.offset;
                        if (fe.isInstancedInterleavedBuffer) {
                            for (let Ce = 0; Ce < L.locationSize; Ce++) p(L.location + Ce, fe.meshPerAttribute);
                            y.isInstancedMesh !== !0 && R._maxInstanceCount === void 0 && (R._maxInstanceCount = fe.meshPerAttribute * fe.count)
                        } else
                            for (let Ce = 0; Ce < L.locationSize; Ce++) A(L.location + Ce);
                        n.bindBuffer(n.ARRAY_BUFFER, le);
                        for (let Ce = 0; Ce < L.locationSize; Ce++) _(L.location + Ce, $ / L.locationSize, K, k, Me * te, (Be + $ / L.locationSize * Ce) * te, ue)
                    } else {
                        if (W.isInstancedBufferAttribute) {
                            for (let fe = 0; fe < L.locationSize; fe++) p(L.location + fe, W.meshPerAttribute);
                            y.isInstancedMesh !== !0 && R._maxInstanceCount === void 0 && (R._maxInstanceCount = W.meshPerAttribute * W.count)
                        } else
                            for (let fe = 0; fe < L.locationSize; fe++) A(L.location + fe);
                        n.bindBuffer(n.ARRAY_BUFFER, le);
                        for (let fe = 0; fe < L.locationSize; fe++) _(L.location + fe, $ / L.locationSize, K, k, $ * te, $ / L.locationSize * fe * te, ue)
                    }
                } else if (Q !== void 0) {
                    const k = Q[F];
                    if (k !== void 0) switch (k.length) {
                        case 2:
                            n.vertexAttrib2fv(L.location, k);
                            break;
                        case 3:
                            n.vertexAttrib3fv(L.location, k);
                            break;
                        case 4:
                            n.vertexAttrib4fv(L.location, k);
                            break;
                        default:
                            n.vertexAttrib1fv(L.location, k)
                    }
                }
            }
        }
        v()
    }

    function w() {
        S();
        for (const y in i) {
            const P = i[y];
            for (const T in P) {
                const R = P[T];
                for (const D in R) u(R[D].object), delete R[D];
                delete P[T]
            }
            delete i[y]
        }
    }

    function E(y) {
        if (i[y.id] === void 0) return;
        const P = i[y.id];
        for (const T in P) {
            const R = P[T];
            for (const D in R) u(R[D].object), delete R[D];
            delete P[T]
        }
        delete i[y.id]
    }

    function C(y) {
        for (const P in i) {
            const T = i[P];
            if (T[y.id] === void 0) continue;
            const R = T[y.id];
            for (const D in R) u(R[D].object), delete R[D];
            delete T[y.id]
        }
    }

    function S() {
        x(), o = !0, r !== s && (r = s, c(r.object))
    }

    function x() {
        s.geometry = null, s.program = null, s.wireframe = !1
    }
    return {
        setup: a,
        reset: S,
        resetDefaultState: x,
        dispose: w,
        releaseStatesOfGeometry: E,
        releaseStatesOfProgram: C,
        initAttributes: g,
        enableAttribute: A,
        disableUnusedAttributes: v
    }
}

function AL(n, e, t) {
    let i;

    function s(l) {
        i = l
    }

    function r(l, c) {
        n.drawArrays(i, l, c), t.update(c, i, 1)
    }

    function o(l, c, u) {
        u !== 0 && (n.drawArraysInstanced(i, l, c, u), t.update(c, i, u))
    }

    function a(l, c, u) {
        if (u === 0) return;
        const d = e.get("WEBGL_multi_draw");
        if (d === null)
            for (let h = 0; h < u; h++) this.render(l[h], c[h]);
        else {
            d.multiDrawArraysWEBGL(i, l, 0, c, 0, u);
            let h = 0;
            for (let f = 0; f < u; f++) h += c[f];
            t.update(h, i, 1)
        }
    }
    this.setMode = s, this.render = r, this.renderInstances = o, this.renderMultiDraw = a
}

function _L(n, e, t) {
    let i;

    function s() {
        if (i !== void 0) return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const _ = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(_.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else i = 0;
        return i
    }

    function r(_) {
        if (_ === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp";
            _ = "mediump"
        }
        return _ === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let o = t.precision !== void 0 ? t.precision : "highp";
    const a = r(o);
    a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
    const l = t.logarithmicDepthBuffer === !0,
        c = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
        u = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        d = n.getParameter(n.MAX_TEXTURE_SIZE),
        h = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
        f = n.getParameter(n.MAX_VERTEX_ATTRIBS),
        m = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
        g = n.getParameter(n.MAX_VARYING_VECTORS),
        A = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
        p = u > 0,
        v = n.getParameter(n.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: r,
        precision: o,
        logarithmicDepthBuffer: l,
        maxTextures: c,
        maxVertexTextures: u,
        maxTextureSize: d,
        maxCubemapSize: h,
        maxAttributes: f,
        maxVertexUniforms: m,
        maxVaryings: g,
        maxFragmentUniforms: A,
        vertexTextures: p,
        maxSamples: v
    }
}

function vL(n) {
    const e = this;
    let t = null,
        i = 0,
        s = !1,
        r = !1;
    const o = new $r,
        a = new ot,
        l = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (d, h) {
        const f = d.length !== 0 || h || i !== 0 || s;
        return s = h, i = d.length, f
    }, this.beginShadows = function () {
        r = !0, u(null)
    }, this.endShadows = function () {
        r = !1
    }, this.setGlobalState = function (d, h) {
        t = u(d, h, 0)
    }, this.setState = function (d, h, f) {
        const m = d.clippingPlanes,
            g = d.clipIntersection,
            A = d.clipShadows,
            p = n.get(d);
        if (!s || m === null || m.length === 0 || r && !A) r ? u(null) : c();
        else {
            const v = r ? 0 : i,
                _ = v * 4;
            let b = p.clippingState || null;
            l.value = b, b = u(m, h, _, f);
            for (let w = 0; w !== _; ++w) b[w] = t[w];
            p.clippingState = b, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += v
        }
    };

    function c() {
        l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
    }

    function u(d, h, f, m) {
        const g = d !== null ? d.length : 0;
        let A = null;
        if (g !== 0) {
            if (A = l.value, m !== !0 || A === null) {
                const p = f + g * 4,
                    v = h.matrixWorldInverse;
                a.getNormalMatrix(v), (A === null || A.length < p) && (A = new Float32Array(p));
                for (let _ = 0, b = f; _ !== g; ++_, b += 4) o.copy(d[_]).applyMatrix4(v, a), o.normal.toArray(A, b), A[b + 3] = o.constant
            }
            l.value = A, l.needsUpdate = !0
        }
        return e.numPlanes = g, e.numIntersection = 0, A
    }
}

function bL(n) {
    let e = new WeakMap;

    function t(o, a) {
        return a === pg ? o.mapping = ya : a === mg && (o.mapping = Gl), o
    }

    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === pg || a === mg)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new B2(l.height);
                        return c.fromEquirectangularTexture(n, o), e.set(o, c), o.addEventListener("dispose", s), t(c.texture, o.mapping)
                    } else return null
                }
        }
        return o
    }

    function s(o) {
        const a = o.target;
        a.removeEventListener("dispose", s);
        const l = e.get(a);
        l !== void 0 && (e.delete(a), l.dispose())
    }

    function r() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class ju extends a0 {
    constructor(e = -1, t = 1, i = 1, s = -1, r = .1, o = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = s, this.near = r, this.far = o, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
    }
    setViewOffset(e, t, i, s, r, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            s = (this.top + this.bottom) / 2;
        let r = i - e,
            o = i + e,
            a = s + t,
            l = s - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += c * this.view.offsetX, o = r + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
    }
}
const ml = 4,
    Bv = [.125, .215, .35, .446, .526, .582],
    ia = 20,
    Qp = new ju,
    Rv = new Ue;
let zp = null,
    Gp = 0,
    Hp = 0,
    Vp = !1;
const Xo = (1 + Math.sqrt(5)) / 2,
    Ja = 1 / Xo,
    Pv = [new z(1, 1, 1), new z(-1, 1, 1), new z(1, 1, -1), new z(-1, 1, -1), new z(0, Xo, Ja), new z(0, Xo, -Ja), new z(Ja, 0, Xo), new z(-Ja, 0, Xo), new z(Xo, Ja, 0), new z(-Xo, Ja, 0)];
class Dv {
    constructor(e) {
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t = 0, i = .1, s = 100) {
        zp = this._renderer.getRenderTarget(), Gp = this._renderer.getActiveCubeFace(), Hp = this._renderer.getActiveMipmapLevel(), Vp = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
        const r = this._allocateTargets();
        return r.depthBuffer = !0, this._sceneToCubeUV(e, i, s, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
    }
    fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t = null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Fv(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = kv(), this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(zp, Gp, Hp), this._renderer.xr.enabled = Vp, e.scissorTest = !1, Id(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === ya || e.mapping === Gl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), zp = this._renderer.getRenderTarget(), Gp = this._renderer.getActiveCubeFace(), Hp = this._renderer.getActiveMipmapLevel(), Vp = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            i = {
                magFilter: Pt,
                minFilter: Pt,
                generateMipmaps: !1,
                type: yi,
                format: Jt,
                colorSpace: gi,
                depthBuffer: !1
            },
            s = Lv(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Lv(e, t, i);
            const {
                _lodMax: r
            } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = xL(r)), this._blurMaterial = yL(r, e, t)
        }
        return s
    }
    _compileMaterial(e) {
        const t = new Ri(this._lodPlanes[0], e);
        this._renderer.compile(t, Qp)
    }
    _sceneToCubeUV(e, t, i, s) {
        const a = new cn(90, 1, t, i),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            d = u.autoClear,
            h = u.toneMapping;
        u.getClearColor(Rv), u.toneMapping = _r, u.autoClear = !1;
        const f = new pr({
            name: "PMREM.Background",
            side: Mn,
            depthWrite: !1,
            depthTest: !1
        }),
            m = new Ri(new qu, f);
        let g = !1;
        const A = e.background;
        A ? A.isColor && (f.color.copy(A), e.background = null, g = !0) : (f.color.copy(Rv), g = !0);
        for (let p = 0; p < 6; p++) {
            const v = p % 3;
            v === 0 ? (a.up.set(0, l[p], 0), a.lookAt(c[p], 0, 0)) : v === 1 ? (a.up.set(0, 0, l[p]), a.lookAt(0, c[p], 0)) : (a.up.set(0, l[p], 0), a.lookAt(0, 0, c[p]));
            const _ = this._cubeSize;
            Id(s, v * _, p > 2 ? _ : 0, _, _), u.setRenderTarget(s), g && u.render(m, a), u.render(e, a)
        }
        m.geometry.dispose(), m.material.dispose(), u.toneMapping = h, u.autoClear = d, e.background = A
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer,
            s = e.mapping === ya || e.mapping === Gl;
        s ? (this._cubemapMaterial === null && (this._cubemapMaterial = Fv()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = kv());
        const r = s ? this._cubemapMaterial : this._equirectMaterial,
            o = new Ri(this._lodPlanes[0], r),
            a = r.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Id(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, Qp)
    }
    _applyPMREM(e) {
        const t = this._renderer,
            i = t.autoClear;
        t.autoClear = !1;
        for (let s = 1; s < this._lodPlanes.length; s++) {
            const r = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]),
                o = Pv[(s - 1) % Pv.length];
            this._blur(e, s - 1, s, r, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, s, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, s, "latitudinal", r), this._halfBlur(o, e, i, i, s, "longitudinal", r)
    }
    _halfBlur(e, t, i, s, r, o, a) {
        const l = this._renderer,
            c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3,
            d = new Ri(this._lodPlanes[s], c),
            h = c.uniforms,
            f = this._sizeLods[i] - 1,
            m = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * ia - 1),
            g = r / m,
            A = isFinite(r) ? 1 + Math.floor(u * g) : ia;
        A > ia && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${A} samples when the maximum is set to ${ia}`);
        const p = [];
        let v = 0;
        for (let C = 0; C < ia; ++C) {
            const S = C / g,
                x = Math.exp(-S * S / 2);
            p.push(x), C === 0 ? v += x : C < A && (v += 2 * x)
        }
        for (let C = 0; C < p.length; C++) p[C] = p[C] / v;
        h.envMap.value = e.texture, h.samples.value = A, h.weights.value = p, h.latitudinal.value = o === "latitudinal", a && (h.poleAxis.value = a);
        const {
            _lodMax: _
        } = this;
        h.dTheta.value = m, h.mipInt.value = _ - i;
        const b = this._sizeLods[s],
            w = 3 * b * (s > _ - ml ? s - _ + ml : 0),
            E = 4 * (this._cubeSize - b);
        Id(t, w, E, 3 * b, 2 * b), l.setRenderTarget(t), l.render(d, Qp)
    }
}

function xL(n) {
    const e = [],
        t = [],
        i = [];
    let s = n;
    const r = n - ml + 1 + Bv.length;
    for (let o = 0; o < r; o++) {
        const a = Math.pow(2, s);
        t.push(a);
        let l = 1 / a;
        o > n - ml ? l = Bv[o - n + ml - 1] : o === 0 && (l = 0), i.push(l);
        const c = 1 / (a - 2),
            u = -c,
            d = 1 + c,
            h = [u, u, d, u, d, d, u, u, d, d, u, d],
            f = 6,
            m = 6,
            g = 3,
            A = 2,
            p = 1,
            v = new Float32Array(g * m * f),
            _ = new Float32Array(A * m * f),
            b = new Float32Array(p * m * f);
        for (let E = 0; E < f; E++) {
            const C = E % 3 * 2 / 3 - 1,
                S = E > 2 ? 0 : -1,
                x = [C, S, 0, C + 2 / 3, S, 0, C + 2 / 3, S + 1, 0, C, S, 0, C + 2 / 3, S + 1, 0, C, S + 1, 0];
            v.set(x, g * m * E), _.set(h, A * m * E);
            const y = [E, E, E, E, E, E];
            b.set(y, p * m * E)
        }
        const w = new Gi;
        w.setAttribute("position", new pi(v, g)), w.setAttribute("uv", new pi(_, A)), w.setAttribute("faceIndex", new pi(b, p)), e.push(w), s > ml && s--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}

function Lv(n, e, t) {
    const i = new mn(n, e, t);
    return i.texture.mapping = Of, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
}

function Id(n, e, t, i, s) {
    n.viewport.set(e, t, i, s), n.scissor.set(e, t, i, s)
}

function yL(n, e, t) {
    const i = new Float32Array(ia),
        s = new z(0, 1, 0);
    return new ti({
        name: "SphericalGaussianBlur",
        defines: {
            n: ia,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: s
            }
        },
        vertexShader: c0(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Hs,
        depthTest: !1,
        depthWrite: !1
    })
}

function kv() {
    return new ti({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: c0(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Hs,
        depthTest: !1,
        depthWrite: !1
    })
}

function Fv() {
    return new ti({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: c0(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Hs,
        depthTest: !1,
        depthWrite: !1
    })
}

function c0() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function EL(n) {
    let e = new WeakMap,
        t = null;

    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping,
                c = l === pg || l === mg,
                u = l === ya || l === Gl;
            if (c || u) {
                let d = e.get(a);
                const h = d !== void 0 ? d.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== h) return t === null && (t = new Dv(n)), d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), d.texture.pmremVersion = a.pmremVersion, e.set(a, d), d.texture;
                if (d !== void 0) return d.texture; {
                    const f = a.image;
                    return c && f && f.height > 0 || u && f && s(f) ? (t === null && (t = new Dv(n)), d = c ? t.fromEquirectangular(a) : t.fromCubemap(a), d.texture.pmremVersion = a.pmremVersion, e.set(a, d), a.addEventListener("dispose", r), d.texture) : null
                }
            }
        }
        return a
    }

    function s(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
        return l === c
    }

    function r(a) {
        const l = a.target;
        l.removeEventListener("dispose", r);
        const c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose())
    }

    function o() {
        e = new WeakMap, t !== null && (t.dispose(), t = null)
    }
    return {
        get: i,
        dispose: o
    }
}

function wL(n) {
    const e = {};

    function t(i) {
        if (e[i] !== void 0) return e[i];
        let s;
        switch (i) {
            case "WEBGL_depth_texture":
                s = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                s = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                s = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                s = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                s = n.getExtension(i)
        }
        return e[i] = s, s
    }
    return {
        has: function (i) {
            return t(i) !== null
        },
        init: function () {
            t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent")
        },
        get: function (i) {
            const s = t(i);
            return s === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), s
        }
    }
}

function CL(n, e, t, i) {
    const s = {},
        r = new WeakMap;

    function o(d) {
        const h = d.target;
        h.index !== null && e.remove(h.index);
        for (const m in h.attributes) e.remove(h.attributes[m]);
        for (const m in h.morphAttributes) {
            const g = h.morphAttributes[m];
            for (let A = 0, p = g.length; A < p; A++) e.remove(g[A])
        }
        h.removeEventListener("dispose", o), delete s[h.id];
        const f = r.get(h);
        f && (e.remove(f), r.delete(h)), i.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount, t.memory.geometries--
    }

    function a(d, h) {
        return s[h.id] === !0 || (h.addEventListener("dispose", o), s[h.id] = !0, t.memory.geometries++), h
    }

    function l(d) {
        const h = d.attributes;
        for (const m in h) e.update(h[m], n.ARRAY_BUFFER);
        const f = d.morphAttributes;
        for (const m in f) {
            const g = f[m];
            for (let A = 0, p = g.length; A < p; A++) e.update(g[A], n.ARRAY_BUFFER)
        }
    }

    function c(d) {
        const h = [],
            f = d.index,
            m = d.attributes.position;
        let g = 0;
        if (f !== null) {
            const v = f.array;
            g = f.version;
            for (let _ = 0, b = v.length; _ < b; _ += 3) {
                const w = v[_ + 0],
                    E = v[_ + 1],
                    C = v[_ + 2];
                h.push(w, E, E, C, C, w)
            }
        } else if (m !== void 0) {
            const v = m.array;
            g = m.version;
            for (let _ = 0, b = v.length / 3 - 1; _ < b; _ += 3) {
                const w = _ + 0,
                    E = _ + 1,
                    C = _ + 2;
                h.push(w, E, E, C, C, w)
            }
        } else return;
        const A = new (hw(h) ? vw : _w)(h, 1);
        A.version = g;
        const p = r.get(d);
        p && e.remove(p), r.set(d, A)
    }

    function u(d) {
        const h = r.get(d);
        if (h) {
            const f = d.index;
            f !== null && h.version < f.version && c(d)
        } else c(d);
        return r.get(d)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}

function SL(n, e, t) {
    let i;

    function s(d) {
        i = d
    }
    let r, o;

    function a(d) {
        r = d.type, o = d.bytesPerElement
    }

    function l(d, h) {
        n.drawElements(i, h, r, d * o), t.update(h, i, 1)
    }

    function c(d, h, f) {
        f !== 0 && (n.drawElementsInstanced(i, h, r, d * o, f), t.update(h, i, f))
    }

    function u(d, h, f) {
        if (f === 0) return;
        const m = e.get("WEBGL_multi_draw");
        if (m === null)
            for (let g = 0; g < f; g++) this.render(d[g] / o, h[g]);
        else {
            m.multiDrawElementsWEBGL(i, h, 0, r, d, 0, f);
            let g = 0;
            for (let A = 0; A < f; A++) g += h[A];
            t.update(g, i, 1)
        }
    }
    this.setMode = s, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = u
}

function ML(n) {
    const e = {
        geometries: 0,
        textures: 0
    },
        t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };

    function i(r, o, a) {
        switch (t.calls++, o) {
            case n.TRIANGLES:
                t.triangles += a * (r / 3);
                break;
            case n.LINES:
                t.lines += a * (r / 2);
                break;
            case n.LINE_STRIP:
                t.lines += a * (r - 1);
                break;
            case n.LINE_LOOP:
                t.lines += a * r;
                break;
            case n.POINTS:
                t.points += a * r;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break
        }
    }

    function s() {
        t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: s,
        update: i
    }
}

function TL(n, e, t) {
    const i = new WeakMap,
        s = new Rt;

    function r(o, a, l) {
        const c = o.morphTargetInfluences,
            u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
            d = u !== void 0 ? u.length : 0;
        let h = i.get(a);
        if (h === void 0 || h.count !== d) {
            let y = function () {
                S.dispose(), i.delete(a), a.removeEventListener("dispose", y)
            };
            var f = y;
            h !== void 0 && h.texture.dispose();
            const m = a.morphAttributes.position !== void 0,
                g = a.morphAttributes.normal !== void 0,
                A = a.morphAttributes.color !== void 0,
                p = a.morphAttributes.position || [],
                v = a.morphAttributes.normal || [],
                _ = a.morphAttributes.color || [];
            let b = 0;
            m === !0 && (b = 1), g === !0 && (b = 2), A === !0 && (b = 3);
            let w = a.attributes.position.count * b,
                E = 1;
            w > e.maxTextureSize && (E = Math.ceil(w / e.maxTextureSize), w = e.maxTextureSize);
            const C = new Float32Array(w * E * 4 * d),
                S = new mw(C, w, E, d);
            S.type = ei, S.needsUpdate = !0;
            const x = b * 4;
            for (let P = 0; P < d; P++) {
                const T = p[P],
                    R = v[P],
                    D = _[P],
                    U = w * E * 4 * P;
                for (let Q = 0; Q < T.count; Q++) {
                    const F = Q * x;
                    m === !0 && (s.fromBufferAttribute(T, Q), C[U + F + 0] = s.x, C[U + F + 1] = s.y, C[U + F + 2] = s.z, C[U + F + 3] = 0), g === !0 && (s.fromBufferAttribute(R, Q), C[U + F + 4] = s.x, C[U + F + 5] = s.y, C[U + F + 6] = s.z, C[U + F + 7] = 0), A === !0 && (s.fromBufferAttribute(D, Q), C[U + F + 8] = s.x, C[U + F + 9] = s.y, C[U + F + 10] = s.z, C[U + F + 11] = D.itemSize === 4 ? s.w : 1)
                }
            }
            h = {
                count: d,
                texture: S,
                size: new _e(w, E)
            }, i.set(a, h), a.addEventListener("dispose", y)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null) l.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
        else {
            let m = 0;
            for (let A = 0; A < c.length; A++) m += c[A];
            const g = a.morphTargetsRelative ? 1 : 1 - m;
            l.getUniforms().setValue(n, "morphTargetBaseInfluence", g), l.getUniforms().setValue(n, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(n, "morphTargetsTexture", h.texture, t), l.getUniforms().setValue(n, "morphTargetsTextureSize", h.size)
    }
    return {
        update: r
    }
}

function IL(n, e, t, i) {
    let s = new WeakMap;

    function r(l) {
        const c = i.render.frame,
            u = l.geometry,
            d = e.get(l, u);
        if (s.get(d) !== c && (e.update(d), s.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), s.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER), s.set(l, c))), l.isSkinnedMesh) {
            const h = l.skeleton;
            s.get(h) !== c && (h.update(), s.set(h, c))
        }
        return d
    }

    function o() {
        s = new WeakMap
    }

    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: r,
        dispose: o
    }
}
class u0 extends oi {
    constructor(e, t, i, s, r, o, a, l, c, u) {
        if (u = u !== void 0 ? u : Il, u !== Il && u !== Cu) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && u === Il && (i = Hl), i === void 0 && u === Cu && (i = Hu), super(null, s, r, o, a, l, u, i, c), this.isDepthTexture = !0, this.image = {
            width: e,
            height: t
        }, this.magFilter = a !== void 0 ? a : Kt, this.minFilter = l !== void 0 ? l : Kt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
    }
    copy(e) {
        return super.copy(e), this.compareFunction = e.compareFunction, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
    }
}
const yw = new oi,
    Ew = new u0(1, 1);
Ew.compareFunction = dw;
const ww = new mw,
    Cw = new gw,
    Sw = new l0,
    Nv = [],
    Ov = [],
    Uv = new Float32Array(16),
    Qv = new Float32Array(9),
    zv = new Float32Array(4);

function tc(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0) return n;
    const s = e * t;
    let r = Nv[s];
    if (r === void 0 && (r = new Float32Array(s), Nv[s] = r), e !== 0) {
        i.toArray(r, 0);
        for (let o = 1, a = 0; o !== e; ++o) a += t, n[o].toArray(r, a)
    }
    return r
}

function wi(n, e) {
    if (n.length !== e.length) return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t]) return !1;
    return !0
}

function Ci(n, e) {
    for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}

function zf(n, e) {
    let t = Ov[e];
    t === void 0 && (t = new Int32Array(e), Ov[e] = t);
    for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
    return t
}

function BL(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e)
}

function RL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (wi(t, e)) return;
        n.uniform2fv(this.addr, e), Ci(t, e)
    }
}

function PL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
        if (wi(t, e)) return;
        n.uniform3fv(this.addr, e), Ci(t, e)
    }
}

function DL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (wi(t, e)) return;
        n.uniform4fv(this.addr, e), Ci(t, e)
    }
}

function LL(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (wi(t, e)) return;
        n.uniformMatrix2fv(this.addr, !1, e), Ci(t, e)
    } else {
        if (wi(t, i)) return;
        zv.set(i), n.uniformMatrix2fv(this.addr, !1, zv), Ci(t, i)
    }
}

function kL(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (wi(t, e)) return;
        n.uniformMatrix3fv(this.addr, !1, e), Ci(t, e)
    } else {
        if (wi(t, i)) return;
        Qv.set(i), n.uniformMatrix3fv(this.addr, !1, Qv), Ci(t, i)
    }
}

function FL(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (wi(t, e)) return;
        n.uniformMatrix4fv(this.addr, !1, e), Ci(t, e)
    } else {
        if (wi(t, i)) return;
        Uv.set(i), n.uniformMatrix4fv(this.addr, !1, Uv), Ci(t, i)
    }
}

function NL(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e)
}

function OL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (wi(t, e)) return;
        n.uniform2iv(this.addr, e), Ci(t, e)
    }
}

function UL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (wi(t, e)) return;
        n.uniform3iv(this.addr, e), Ci(t, e)
    }
}

function QL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (wi(t, e)) return;
        n.uniform4iv(this.addr, e), Ci(t, e)
    }
}

function zL(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e)
}

function GL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (wi(t, e)) return;
        n.uniform2uiv(this.addr, e), Ci(t, e)
    }
}

function HL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (wi(t, e)) return;
        n.uniform3uiv(this.addr, e), Ci(t, e)
    }
}

function VL(n, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (wi(t, e)) return;
        n.uniform4uiv(this.addr, e), Ci(t, e)
    }
}

function WL(n, e, t) {
    const i = this.cache,
        s = t.allocateTextureUnit();
    i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s);
    const r = this.type === n.SAMPLER_2D_SHADOW ? Ew : yw;
    t.setTexture2D(e || r, s)
}

function qL(n, e, t) {
    const i = this.cache,
        s = t.allocateTextureUnit();
    i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), t.setTexture3D(e || Cw, s)
}

function $L(n, e, t) {
    const i = this.cache,
        s = t.allocateTextureUnit();
    i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), t.setTextureCube(e || Sw, s)
}

function jL(n, e, t) {
    const i = this.cache,
        s = t.allocateTextureUnit();
    i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), t.setTexture2DArray(e || ww, s)
}

function YL(n) {
    switch (n) {
        case 5126:
            return BL;
        case 35664:
            return RL;
        case 35665:
            return PL;
        case 35666:
            return DL;
        case 35674:
            return LL;
        case 35675:
            return kL;
        case 35676:
            return FL;
        case 5124:
        case 35670:
            return NL;
        case 35667:
        case 35671:
            return OL;
        case 35668:
        case 35672:
            return UL;
        case 35669:
        case 35673:
            return QL;
        case 5125:
            return zL;
        case 36294:
            return GL;
        case 36295:
            return HL;
        case 36296:
            return VL;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return WL;
        case 35679:
        case 36299:
        case 36307:
            return qL;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return $L;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return jL
    }
}

function XL(n, e) {
    n.uniform1fv(this.addr, e)
}

function KL(n, e) {
    const t = tc(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}

function JL(n, e) {
    const t = tc(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}

function ZL(n, e) {
    const t = tc(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}

function ek(n, e) {
    const t = tc(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}

function tk(n, e) {
    const t = tc(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}

function ik(n, e) {
    const t = tc(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}

function nk(n, e) {
    n.uniform1iv(this.addr, e)
}

function sk(n, e) {
    n.uniform2iv(this.addr, e)
}

function rk(n, e) {
    n.uniform3iv(this.addr, e)
}

function ok(n, e) {
    n.uniform4iv(this.addr, e)
}

function ak(n, e) {
    n.uniform1uiv(this.addr, e)
}

function lk(n, e) {
    n.uniform2uiv(this.addr, e)
}

function ck(n, e) {
    n.uniform3uiv(this.addr, e)
}

function uk(n, e) {
    n.uniform4uiv(this.addr, e)
}

function dk(n, e, t) {
    const i = this.cache,
        s = e.length,
        r = zf(t, s);
    wi(i, r) || (n.uniform1iv(this.addr, r), Ci(i, r));
    for (let o = 0; o !== s; ++o) t.setTexture2D(e[o] || yw, r[o])
}

function hk(n, e, t) {
    const i = this.cache,
        s = e.length,
        r = zf(t, s);
    wi(i, r) || (n.uniform1iv(this.addr, r), Ci(i, r));
    for (let o = 0; o !== s; ++o) t.setTexture3D(e[o] || Cw, r[o])
}

function fk(n, e, t) {
    const i = this.cache,
        s = e.length,
        r = zf(t, s);
    wi(i, r) || (n.uniform1iv(this.addr, r), Ci(i, r));
    for (let o = 0; o !== s; ++o) t.setTextureCube(e[o] || Sw, r[o])
}

function pk(n, e, t) {
    const i = this.cache,
        s = e.length,
        r = zf(t, s);
    wi(i, r) || (n.uniform1iv(this.addr, r), Ci(i, r));
    for (let o = 0; o !== s; ++o) t.setTexture2DArray(e[o] || ww, r[o])
}

function mk(n) {
    switch (n) {
        case 5126:
            return XL;
        case 35664:
            return KL;
        case 35665:
            return JL;
        case 35666:
            return ZL;
        case 35674:
            return ek;
        case 35675:
            return tk;
        case 35676:
            return ik;
        case 5124:
        case 35670:
            return nk;
        case 35667:
        case 35671:
            return sk;
        case 35668:
        case 35672:
            return rk;
        case 35669:
        case 35673:
            return ok;
        case 5125:
            return ak;
        case 36294:
            return lk;
        case 36295:
            return ck;
        case 36296:
            return uk;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return dk;
        case 35679:
        case 36299:
        case 36307:
            return hk;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return fk;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return pk
    }
}
class gk {
    constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = YL(t.type)
    }
}
class Ak {
    constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = mk(t.type)
    }
}
class _k {
    constructor(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    setValue(e, t, i) {
        const s = this.seq;
        for (let r = 0, o = s.length; r !== o; ++r) {
            const a = s[r];
            a.setValue(e, t[a.id], i)
        }
    }
}
const Wp = /(\w+)(\])?(\[|\.)?/g;

function Gv(n, e) {
    n.seq.push(e), n.map[e.id] = e
}

function vk(n, e, t) {
    const i = n.name,
        s = i.length;
    for (Wp.lastIndex = 0; ;) {
        const r = Wp.exec(i),
            o = Wp.lastIndex;
        let a = r[1];
        const l = r[2] === "]",
            c = r[3];
        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === s) {
            Gv(t, c === void 0 ? new gk(a, n, e) : new Ak(a, n, e));
            break
        } else {
            let d = t.map[a];
            d === void 0 && (d = new _k(a), Gv(t, d)), t = d
        }
    }
}
class Eh {
    constructor(e, t) {
        this.seq = [], this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let s = 0; s < i; ++s) {
            const r = e.getActiveUniform(t, s),
                o = e.getUniformLocation(t, r.name);
            vk(r, o, this)
        }
    }
    setValue(e, t, i, s) {
        const r = this.map[t];
        r !== void 0 && r.setValue(e, i, s)
    }
    setOptional(e, t, i) {
        const s = t[i];
        s !== void 0 && this.setValue(e, i, s)
    }
    static upload(e, t, i, s) {
        for (let r = 0, o = t.length; r !== o; ++r) {
            const a = t[r],
                l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, s)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let s = 0, r = e.length; s !== r; ++s) {
            const o = e[s];
            o.id in t && i.push(o)
        }
        return i
    }
}

function Hv(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t), n.compileShader(i), i
}
const bk = 37297;
let xk = 0;

function yk(n, e) {
    const t = n.split(`
`),
        i = [],
        s = Math.max(e - 6, 0),
        r = Math.min(e + 6, t.length);
    for (let o = s; o < r; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}

function Ek(n) {
    const e = vt.getPrimaries(vt.workingColorSpace),
        t = vt.getPrimaries(n);
    let i;
    switch (e === t ? i = "" : e === of && t === rf ? i = "LinearDisplayP3ToLinearSRGB" : e === rf && t === of && (i = "LinearSRGBToLinearDisplayP3"), n) {
        case gi:
        case Vu:
            return [i, "LinearTransferOETF"];
        case Wt:
        case Uf:
            return [i, "sRGBTransferOETF"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [i, "LinearTransferOETF"]
    }
}

function Vv(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS),
        s = n.getShaderInfoLog(e).trim();
    if (i && s === "") return "";
    const r = /ERROR: 0:(\d+)/.exec(s);
    if (r) {
        const o = parseInt(r[1]);
        return t.toUpperCase() + `

` + s + `

` + yk(n.getShaderSource(e), o)
    } else return s
}

function wk(n, e) {
    const t = Ek(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}

function Ck(n, e) {
    let t;
    switch (e) {
        case KA:
            t = "Linear";
            break;
        case JA:
            t = "Reinhard";
            break;
        case ZA:
            t = "OptimizedCineon";
            break;
        case e0:
            t = "ACESFilmic";
            break;
        case t0:
            t = "AgX";
            break;
        case Zh:
            t = "Neutral";
            break;
        case xR:
            t = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}

function Sk(n) {
    return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Bc).join(`
`)
}

function Mk(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}

function Tk(n, e) {
    const t = {},
        i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let s = 0; s < i; s++) {
        const r = n.getActiveAttrib(e, s),
            o = r.name;
        let a = 1;
        r.type === n.FLOAT_MAT2 && (a = 2), r.type === n.FLOAT_MAT3 && (a = 3), r.type === n.FLOAT_MAT4 && (a = 4), t[o] = {
            type: r.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}

function Bc(n) {
    return n !== ""
}

function Wv(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function qv(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Ik = /^[ \t]*#include +<([\w\d./]+)>/gm;

function Eg(n) {
    return n.replace(Ik, Rk)
}
const Bk = new Map([
    ["encodings_fragment", "colorspace_fragment"],
    ["encodings_pars_fragment", "colorspace_pars_fragment"],
    ["output_fragment", "opaque_fragment"]
]);

function Rk(n, e) {
    let t = Je[e];
    if (t === void 0) {
        const i = Bk.get(e);
        if (i !== void 0) t = Je[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else throw new Error("Can not resolve #include <" + e + ">")
    }
    return Eg(t)
}
const Pk = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function $v(n) {
    return n.replace(Pk, Dk)
}

function Dk(n, e, t, i) {
    let s = "";
    for (let r = parseInt(e); r < parseInt(t); r++) s += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return s
}

function jv(n) {
    let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
}

function Lk(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === ZE ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === $B ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === sr && (e = "SHADOWMAP_TYPE_VSM"), e
}

function kk(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap) switch (n.envMapMode) {
        case ya:
        case Gl:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Of:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
    }
    return e
}

function Fk(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap) switch (n.envMapMode) {
        case Gl:
            e = "ENVMAP_MODE_REFRACTION";
            break
    }
    return e
}

function Nk(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap) switch (n.combine) {
        case XA:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case vR:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case bR:
            e = "ENVMAP_BLENDING_ADD";
            break
    }
    return e
}

function Ok(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2,
        i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}

function Uk(n, e, t, i) {
    const s = n.getContext(),
        r = t.defines;
    let o = t.vertexShader,
        a = t.fragmentShader;
    const l = Lk(t),
        c = kk(t),
        u = Fk(t),
        d = Nk(t),
        h = Ok(t),
        f = Sk(t),
        m = Mk(r),
        g = s.createProgram();
    let A, p, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (A = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(Bc).join(`
`), A.length > 0 && (A += `
`), p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(Bc).join(`
`), p.length > 0 && (p += `
`)) : (A = [jv(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Bc).join(`
`), p = [jv(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + d : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== _r ? "#define TONE_MAPPING" : "", t.toneMapping !== _r ? Je.tonemapping_pars_fragment : "", t.toneMapping !== _r ? Ck("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Je.colorspace_pars_fragment, wk("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Bc).join(`
`)), o = Eg(o), o = Wv(o, t), o = qv(o, t), a = Eg(a), a = Wv(a, t), a = qv(a, t), o = $v(o), a = $v(a), t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, A = [f, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + A, p = ["#define varying in", t.glslVersion === cv ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === cv ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
    const _ = v + A + o,
        b = v + p + a,
        w = Hv(s, s.VERTEX_SHADER, _),
        E = Hv(s, s.FRAGMENT_SHADER, b);
    s.attachShader(g, w), s.attachShader(g, E), t.index0AttributeName !== void 0 ? s.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g);

    function C(P) {
        if (n.debug.checkShaderErrors) {
            const T = s.getProgramInfoLog(g).trim(),
                R = s.getShaderInfoLog(w).trim(),
                D = s.getShaderInfoLog(E).trim();
            let U = !0,
                Q = !0;
            if (s.getProgramParameter(g, s.LINK_STATUS) === !1)
                if (U = !1, typeof n.debug.onShaderError == "function") n.debug.onShaderError(s, g, w, E);
                else {
                    const F = Vv(s, w, "vertex"),
                        L = Vv(s, E, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(g, s.VALIDATE_STATUS) + `

Material Name: ` + P.name + `
Material Type: ` + P.type + `

Program Info Log: ` + T + `
` + F + `
` + L)
                }
            else T !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", T) : (R === "" || D === "") && (Q = !1);
            Q && (P.diagnostics = {
                runnable: U,
                programLog: T,
                vertexShader: {
                    log: R,
                    prefix: A
                },
                fragmentShader: {
                    log: D,
                    prefix: p
                }
            })
        }
        s.deleteShader(w), s.deleteShader(E), S = new Eh(s, g), x = Tk(s, g)
    }
    let S;
    this.getUniforms = function () {
        return S === void 0 && C(this), S
    };
    let x;
    this.getAttributes = function () {
        return x === void 0 && C(this), x
    };
    let y = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function () {
        return y === !1 && (y = s.getProgramParameter(g, bk)), y
    }, this.destroy = function () {
        i.releaseStatesOfProgram(this), s.deleteProgram(g), this.program = void 0
    }, this.type = t.shaderType, this.name = t.shaderName, this.id = xk++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = w, this.fragmentShader = E, this
}
let Qk = 0;
class zk {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader,
            i = e.fragmentShader,
            s = this._getShaderStage(t),
            r = this._getShaderStage(i),
            o = this._getShaderCacheForMaterial(e);
        return o.has(s) === !1 && (o.add(s), s.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e), this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set, t.set(e, i)), i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new Gk(e), t.set(e, i)), i
    }
}
class Gk {
    constructor(e) {
        this.id = Qk++, this.code = e, this.usedTimes = 0
    }
}

function Hk(n, e, t, i, s, r, o) {
    const a = new o0,
        l = new zk,
        c = new Set,
        u = [],
        d = s.logarithmicDepthBuffer,
        h = s.vertexTextures;
    let f = s.precision;
    const m = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function g(x) {
        return c.add(x), x === 0 ? "uv" : `uv${x}`
    }

    function A(x, y, P, T, R) {
        const D = T.fog,
            U = R.geometry,
            Q = x.isMeshStandardMaterial ? T.environment : null,
            F = (x.isMeshStandardMaterial ? t : e).get(x.envMap || Q),
            L = F && F.mapping === Of ? F.image.height : null,
            W = m[x.type];
        x.precision !== null && (f = s.getMaxPrecision(x.precision), f !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", f, "instead."));
        const k = U.morphAttributes.position || U.morphAttributes.normal || U.morphAttributes.color,
            $ = k !== void 0 ? k.length : 0;
        let X = 0;
        U.morphAttributes.position !== void 0 && (X = 1), U.morphAttributes.normal !== void 0 && (X = 2), U.morphAttributes.color !== void 0 && (X = 3);
        let le, K, te, ue;
        if (W) {
            const Tt = Ds[W];
            le = Tt.vertexShader, K = Tt.fragmentShader
        } else le = x.vertexShader, K = x.fragmentShader, l.update(x), te = l.getVertexShaderID(x), ue = l.getFragmentShaderID(x);
        const fe = n.getRenderTarget(),
            Me = R.isInstancedMesh === !0,
            Be = R.isBatchedMesh === !0,
            Ce = !!x.map,
            Z = !!x.matcap,
            ke = !!F,
            N = !!x.aoMap,
            G = !!x.lightMap,
            Y = !!x.bumpMap,
            se = !!x.normalMap,
            M = !!x.displacementMap,
            I = !!x.emissiveMap,
            H = !!x.metalnessMap,
            V = !!x.roughnessMap,
            j = x.anisotropy > 0,
            q = x.clearcoat > 0,
            he = x.iridescence > 0,
            re = x.sheen > 0,
            de = x.transmission > 0,
            ge = j && !!x.anisotropyMap,
            ce = q && !!x.clearcoatMap,
            me = q && !!x.clearcoatNormalMap,
            xe = q && !!x.clearcoatRoughnessMap,
            ve = he && !!x.iridescenceMap,
            we = he && !!x.iridescenceThicknessMap,
            Pe = re && !!x.sheenColorMap,
            Ke = re && !!x.sheenRoughnessMap,
            Ve = !!x.specularMap,
            Le = !!x.specularColorMap,
            We = !!x.specularIntensityMap,
            Te = de && !!x.transmissionMap,
            B = de && !!x.thicknessMap,
            ee = !!x.gradientMap,
            pe = !!x.alphaMap,
            be = x.alphaTest > 0,
            Se = !!x.alphaHash,
            et = !!x.extensions;
        let tt = _r;
        x.toneMapped && (fe === null || fe.isXRRenderTarget === !0) && (tt = n.toneMapping);
        const xt = {
            shaderID: W,
            shaderType: x.type,
            shaderName: x.name,
            vertexShader: le,
            fragmentShader: K,
            defines: x.defines,
            customVertexShaderID: te,
            customFragmentShaderID: ue,
            isRawShaderMaterial: x.isRawShaderMaterial === !0,
            glslVersion: x.glslVersion,
            precision: f,
            batching: Be,
            instancing: Me,
            instancingColor: Me && R.instanceColor !== null,
            instancingMorph: Me && R.morphTexture !== null,
            supportsVertexTextures: h,
            outputColorSpace: fe === null ? n.outputColorSpace : fe.isXRRenderTarget === !0 ? fe.texture.colorSpace : gi,
            alphaToCoverage: !!x.alphaToCoverage,
            map: Ce,
            matcap: Z,
            envMap: ke,
            envMapMode: ke && F.mapping,
            envMapCubeUVHeight: L,
            aoMap: N,
            lightMap: G,
            bumpMap: Y,
            normalMap: se,
            displacementMap: h && M,
            emissiveMap: I,
            normalMapObjectSpace: se && x.normalMapType === NR,
            normalMapTangentSpace: se && x.normalMapType === s0,
            metalnessMap: H,
            roughnessMap: V,
            anisotropy: j,
            anisotropyMap: ge,
            clearcoat: q,
            clearcoatMap: ce,
            clearcoatNormalMap: me,
            clearcoatRoughnessMap: xe,
            iridescence: he,
            iridescenceMap: ve,
            iridescenceThicknessMap: we,
            sheen: re,
            sheenColorMap: Pe,
            sheenRoughnessMap: Ke,
            specularMap: Ve,
            specularColorMap: Le,
            specularIntensityMap: We,
            transmission: de,
            transmissionMap: Te,
            thicknessMap: B,
            gradientMap: ee,
            opaque: x.transparent === !1 && x.blending === Tl && x.alphaToCoverage === !1,
            alphaMap: pe,
            alphaTest: be,
            alphaHash: Se,
            combine: x.combine,
            mapUv: Ce && g(x.map.channel),
            aoMapUv: N && g(x.aoMap.channel),
            lightMapUv: G && g(x.lightMap.channel),
            bumpMapUv: Y && g(x.bumpMap.channel),
            normalMapUv: se && g(x.normalMap.channel),
            displacementMapUv: M && g(x.displacementMap.channel),
            emissiveMapUv: I && g(x.emissiveMap.channel),
            metalnessMapUv: H && g(x.metalnessMap.channel),
            roughnessMapUv: V && g(x.roughnessMap.channel),
            anisotropyMapUv: ge && g(x.anisotropyMap.channel),
            clearcoatMapUv: ce && g(x.clearcoatMap.channel),
            clearcoatNormalMapUv: me && g(x.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: xe && g(x.clearcoatRoughnessMap.channel),
            iridescenceMapUv: ve && g(x.iridescenceMap.channel),
            iridescenceThicknessMapUv: we && g(x.iridescenceThicknessMap.channel),
            sheenColorMapUv: Pe && g(x.sheenColorMap.channel),
            sheenRoughnessMapUv: Ke && g(x.sheenRoughnessMap.channel),
            specularMapUv: Ve && g(x.specularMap.channel),
            specularColorMapUv: Le && g(x.specularColorMap.channel),
            specularIntensityMapUv: We && g(x.specularIntensityMap.channel),
            transmissionMapUv: Te && g(x.transmissionMap.channel),
            thicknessMapUv: B && g(x.thicknessMap.channel),
            alphaMapUv: pe && g(x.alphaMap.channel),
            vertexTangents: !!U.attributes.tangent && (se || j),
            vertexColors: x.vertexColors,
            vertexAlphas: x.vertexColors === !0 && !!U.attributes.color && U.attributes.color.itemSize === 4,
            pointsUvs: R.isPoints === !0 && !!U.attributes.uv && (Ce || pe),
            fog: !!D,
            useFog: x.fog === !0,
            fogExp2: !!D && D.isFogExp2,
            flatShading: x.flatShading === !0,
            sizeAttenuation: x.sizeAttenuation === !0,
            logarithmicDepthBuffer: d,
            skinning: R.isSkinnedMesh === !0,
            morphTargets: U.morphAttributes.position !== void 0,
            morphNormals: U.morphAttributes.normal !== void 0,
            morphColors: U.morphAttributes.color !== void 0,
            morphTargetsCount: $,
            morphTextureStride: X,
            numDirLights: y.directional.length,
            numPointLights: y.point.length,
            numSpotLights: y.spot.length,
            numSpotLightMaps: y.spotLightMap.length,
            numRectAreaLights: y.rectArea.length,
            numHemiLights: y.hemi.length,
            numDirLightShadows: y.directionalShadowMap.length,
            numPointLightShadows: y.pointShadowMap.length,
            numSpotLightShadows: y.spotShadowMap.length,
            numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps,
            numLightProbes: y.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: x.dithering,
            shadowMapEnabled: n.shadowMap.enabled && P.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: tt,
            useLegacyLights: n._useLegacyLights,
            decodeVideoTexture: Ce && x.map.isVideoTexture === !0 && vt.getTransfer(x.map.colorSpace) === Lt,
            premultipliedAlpha: x.premultipliedAlpha,
            doubleSided: x.side === Fs,
            flipSided: x.side === Mn,
            useDepthPacking: x.depthPacking >= 0,
            depthPacking: x.depthPacking || 0,
            index0AttributeName: x.index0AttributeName,
            extensionClipCullDistance: et && x.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: et && x.extensions.multiDraw === !0 && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: x.customProgramCacheKey()
        };
        return xt.vertexUv1s = c.has(1), xt.vertexUv2s = c.has(2), xt.vertexUv3s = c.has(3), c.clear(), xt
    }

    function p(x) {
        const y = [];
        if (x.shaderID ? y.push(x.shaderID) : (y.push(x.customVertexShaderID), y.push(x.customFragmentShaderID)), x.defines !== void 0)
            for (const P in x.defines) y.push(P), y.push(x.defines[P]);
        return x.isRawShaderMaterial === !1 && (v(y, x), _(y, x), y.push(n.outputColorSpace)), y.push(x.customProgramCacheKey), y.join()
    }

    function v(x, y) {
        x.push(y.precision), x.push(y.outputColorSpace), x.push(y.envMapMode), x.push(y.envMapCubeUVHeight), x.push(y.mapUv), x.push(y.alphaMapUv), x.push(y.lightMapUv), x.push(y.aoMapUv), x.push(y.bumpMapUv), x.push(y.normalMapUv), x.push(y.displacementMapUv), x.push(y.emissiveMapUv), x.push(y.metalnessMapUv), x.push(y.roughnessMapUv), x.push(y.anisotropyMapUv), x.push(y.clearcoatMapUv), x.push(y.clearcoatNormalMapUv), x.push(y.clearcoatRoughnessMapUv), x.push(y.iridescenceMapUv), x.push(y.iridescenceThicknessMapUv), x.push(y.sheenColorMapUv), x.push(y.sheenRoughnessMapUv), x.push(y.specularMapUv), x.push(y.specularColorMapUv), x.push(y.specularIntensityMapUv), x.push(y.transmissionMapUv), x.push(y.thicknessMapUv), x.push(y.combine), x.push(y.fogExp2), x.push(y.sizeAttenuation), x.push(y.morphTargetsCount), x.push(y.morphAttributeCount), x.push(y.numDirLights), x.push(y.numPointLights), x.push(y.numSpotLights), x.push(y.numSpotLightMaps), x.push(y.numHemiLights), x.push(y.numRectAreaLights), x.push(y.numDirLightShadows), x.push(y.numPointLightShadows), x.push(y.numSpotLightShadows), x.push(y.numSpotLightShadowsWithMaps), x.push(y.numLightProbes), x.push(y.shadowMapType), x.push(y.toneMapping), x.push(y.numClippingPlanes), x.push(y.numClipIntersection), x.push(y.depthPacking)
    }

    function _(x, y) {
        a.disableAll(), y.supportsVertexTextures && a.enable(0), y.instancing && a.enable(1), y.instancingColor && a.enable(2), y.instancingMorph && a.enable(3), y.matcap && a.enable(4), y.envMap && a.enable(5), y.normalMapObjectSpace && a.enable(6), y.normalMapTangentSpace && a.enable(7), y.clearcoat && a.enable(8), y.iridescence && a.enable(9), y.alphaTest && a.enable(10), y.vertexColors && a.enable(11), y.vertexAlphas && a.enable(12), y.vertexUv1s && a.enable(13), y.vertexUv2s && a.enable(14), y.vertexUv3s && a.enable(15), y.vertexTangents && a.enable(16), y.anisotropy && a.enable(17), y.alphaHash && a.enable(18), y.batching && a.enable(19), x.push(a.mask), a.disableAll(), y.fog && a.enable(0), y.useFog && a.enable(1), y.flatShading && a.enable(2), y.logarithmicDepthBuffer && a.enable(3), y.skinning && a.enable(4), y.morphTargets && a.enable(5), y.morphNormals && a.enable(6), y.morphColors && a.enable(7), y.premultipliedAlpha && a.enable(8), y.shadowMapEnabled && a.enable(9), y.useLegacyLights && a.enable(10), y.doubleSided && a.enable(11), y.flipSided && a.enable(12), y.useDepthPacking && a.enable(13), y.dithering && a.enable(14), y.transmission && a.enable(15), y.sheen && a.enable(16), y.opaque && a.enable(17), y.pointsUvs && a.enable(18), y.decodeVideoTexture && a.enable(19), y.alphaToCoverage && a.enable(20), x.push(a.mask)
    }

    function b(x) {
        const y = m[x.type];
        let P;
        if (y) {
            const T = Ds[y];
            P = wo.clone(T.uniforms)
        } else P = x.uniforms;
        return P
    }

    function w(x, y) {
        let P;
        for (let T = 0, R = u.length; T < R; T++) {
            const D = u[T];
            if (D.cacheKey === y) {
                P = D, ++P.usedTimes;
                break
            }
        }
        return P === void 0 && (P = new Uk(n, y, x, r), u.push(P)), P
    }

    function E(x) {
        if (--x.usedTimes === 0) {
            const y = u.indexOf(x);
            u[y] = u[u.length - 1], u.pop(), x.destroy()
        }
    }

    function C(x) {
        l.remove(x)
    }

    function S() {
        l.dispose()
    }
    return {
        getParameters: A,
        getProgramCacheKey: p,
        getUniforms: b,
        acquireProgram: w,
        releaseProgram: E,
        releaseShaderCache: C,
        programs: u,
        dispose: S
    }
}

function Vk() {
    let n = new WeakMap;

    function e(r) {
        let o = n.get(r);
        return o === void 0 && (o = {}, n.set(r, o)), o
    }

    function t(r) {
        n.delete(r)
    }

    function i(r, o, a) {
        n.get(r)[o] = a
    }

    function s() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: s
    }
}

function Wk(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}

function Yv(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}

function Xv() {
    const n = [];
    let e = 0;
    const t = [],
        i = [],
        s = [];

    function r() {
        e = 0, t.length = 0, i.length = 0, s.length = 0
    }

    function o(d, h, f, m, g, A) {
        let p = n[e];
        return p === void 0 ? (p = {
            id: d.id,
            object: d,
            geometry: h,
            material: f,
            groupOrder: m,
            renderOrder: d.renderOrder,
            z: g,
            group: A
        }, n[e] = p) : (p.id = d.id, p.object = d, p.geometry = h, p.material = f, p.groupOrder = m, p.renderOrder = d.renderOrder, p.z = g, p.group = A), e++, p
    }

    function a(d, h, f, m, g, A) {
        const p = o(d, h, f, m, g, A);
        f.transmission > 0 ? i.push(p) : f.transparent === !0 ? s.push(p) : t.push(p)
    }

    function l(d, h, f, m, g, A) {
        const p = o(d, h, f, m, g, A);
        f.transmission > 0 ? i.unshift(p) : f.transparent === !0 ? s.unshift(p) : t.unshift(p)
    }

    function c(d, h) {
        t.length > 1 && t.sort(d || Wk), i.length > 1 && i.sort(h || Yv), s.length > 1 && s.sort(h || Yv)
    }

    function u() {
        for (let d = e, h = n.length; d < h; d++) {
            const f = n[d];
            if (f.id === null) break;
            f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: s,
        init: r,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}

function qk() {
    let n = new WeakMap;

    function e(i, s) {
        const r = n.get(i);
        let o;
        return r === void 0 ? (o = new Xv, n.set(i, [o])) : s >= r.length ? (o = new Xv, r.push(o)) : o = r[s], o
    }

    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}

function $k() {
    const n = {};
    return {
        get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = {
                        direction: new z,
                        color: new Ue
                    };
                    break;
                case "SpotLight":
                    t = {
                        position: new z,
                        direction: new z,
                        color: new Ue,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    t = {
                        position: new z,
                        color: new Ue,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    t = {
                        direction: new z,
                        skyColor: new Ue,
                        groundColor: new Ue
                    };
                    break;
                case "RectAreaLight":
                    t = {
                        color: new Ue,
                        position: new z,
                        halfWidth: new z,
                        halfHeight: new z
                    };
                    break
            }
            return n[e.id] = t, t
        }
    }
}

function jk() {
    const n = {};
    return {
        get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new _e
                    };
                    break;
                case "SpotLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new _e
                    };
                    break;
                case "PointLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new _e,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break
            }
            return n[e.id] = t, t
        }
    }
}
let Yk = 0;

function Xk(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}

function Kk(n) {
    const e = new $k,
        t = jk(),
        i = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
    for (let c = 0; c < 9; c++) i.probe.push(new z);
    const s = new z,
        r = new Xe,
        o = new Xe;

    function a(c, u) {
        let d = 0,
            h = 0,
            f = 0;
        for (let P = 0; P < 9; P++) i.probe[P].set(0, 0, 0);
        let m = 0,
            g = 0,
            A = 0,
            p = 0,
            v = 0,
            _ = 0,
            b = 0,
            w = 0,
            E = 0,
            C = 0,
            S = 0;
        c.sort(Xk);
        const x = u === !0 ? Math.PI : 1;
        for (let P = 0, T = c.length; P < T; P++) {
            const R = c[P],
                D = R.color,
                U = R.intensity,
                Q = R.distance,
                F = R.shadow && R.shadow.map ? R.shadow.map.texture : null;
            if (R.isAmbientLight) d += D.r * U * x, h += D.g * U * x, f += D.b * U * x;
            else if (R.isLightProbe) {
                for (let L = 0; L < 9; L++) i.probe[L].addScaledVector(R.sh.coefficients[L], U);
                S++
            } else if (R.isDirectionalLight) {
                const L = e.get(R);
                if (L.color.copy(R.color).multiplyScalar(R.intensity * x), R.castShadow) {
                    const W = R.shadow,
                        k = t.get(R);
                    k.shadowBias = W.bias, k.shadowNormalBias = W.normalBias, k.shadowRadius = W.radius, k.shadowMapSize = W.mapSize, i.directionalShadow[m] = k, i.directionalShadowMap[m] = F, i.directionalShadowMatrix[m] = R.shadow.matrix, _++
                }
                i.directional[m] = L, m++
            } else if (R.isSpotLight) {
                const L = e.get(R);
                L.position.setFromMatrixPosition(R.matrixWorld), L.color.copy(D).multiplyScalar(U * x), L.distance = Q, L.coneCos = Math.cos(R.angle), L.penumbraCos = Math.cos(R.angle * (1 - R.penumbra)), L.decay = R.decay, i.spot[A] = L;
                const W = R.shadow;
                if (R.map && (i.spotLightMap[E] = R.map, E++, W.updateMatrices(R), R.castShadow && C++), i.spotLightMatrix[A] = W.matrix, R.castShadow) {
                    const k = t.get(R);
                    k.shadowBias = W.bias, k.shadowNormalBias = W.normalBias, k.shadowRadius = W.radius, k.shadowMapSize = W.mapSize, i.spotShadow[A] = k, i.spotShadowMap[A] = F, w++
                }
                A++
            } else if (R.isRectAreaLight) {
                const L = e.get(R);
                L.color.copy(D).multiplyScalar(U), L.halfWidth.set(R.width * .5, 0, 0), L.halfHeight.set(0, R.height * .5, 0), i.rectArea[p] = L, p++
            } else if (R.isPointLight) {
                const L = e.get(R);
                if (L.color.copy(R.color).multiplyScalar(R.intensity * x), L.distance = R.distance, L.decay = R.decay, R.castShadow) {
                    const W = R.shadow,
                        k = t.get(R);
                    k.shadowBias = W.bias, k.shadowNormalBias = W.normalBias, k.shadowRadius = W.radius, k.shadowMapSize = W.mapSize, k.shadowCameraNear = W.camera.near, k.shadowCameraFar = W.camera.far, i.pointShadow[g] = k, i.pointShadowMap[g] = F, i.pointShadowMatrix[g] = R.shadow.matrix, b++
                }
                i.point[g] = L, g++
            } else if (R.isHemisphereLight) {
                const L = e.get(R);
                L.skyColor.copy(R.color).multiplyScalar(U * x), L.groundColor.copy(R.groundColor).multiplyScalar(U * x), i.hemi[v] = L, v++
            }
        }
        p > 0 && (n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Ie.LTC_FLOAT_1, i.rectAreaLTC2 = Ie.LTC_FLOAT_2) : (i.rectAreaLTC1 = Ie.LTC_HALF_1, i.rectAreaLTC2 = Ie.LTC_HALF_2)), i.ambient[0] = d, i.ambient[1] = h, i.ambient[2] = f;
        const y = i.hash;
        (y.directionalLength !== m || y.pointLength !== g || y.spotLength !== A || y.rectAreaLength !== p || y.hemiLength !== v || y.numDirectionalShadows !== _ || y.numPointShadows !== b || y.numSpotShadows !== w || y.numSpotMaps !== E || y.numLightProbes !== S) && (i.directional.length = m, i.spot.length = A, i.rectArea.length = p, i.point.length = g, i.hemi.length = v, i.directionalShadow.length = _, i.directionalShadowMap.length = _, i.pointShadow.length = b, i.pointShadowMap.length = b, i.spotShadow.length = w, i.spotShadowMap.length = w, i.directionalShadowMatrix.length = _, i.pointShadowMatrix.length = b, i.spotLightMatrix.length = w + E - C, i.spotLightMap.length = E, i.numSpotLightShadowsWithMaps = C, i.numLightProbes = S, y.directionalLength = m, y.pointLength = g, y.spotLength = A, y.rectAreaLength = p, y.hemiLength = v, y.numDirectionalShadows = _, y.numPointShadows = b, y.numSpotShadows = w, y.numSpotMaps = E, y.numLightProbes = S, i.version = Yk++)
    }

    function l(c, u) {
        let d = 0,
            h = 0,
            f = 0,
            m = 0,
            g = 0;
        const A = u.matrixWorldInverse;
        for (let p = 0, v = c.length; p < v; p++) {
            const _ = c[p];
            if (_.isDirectionalLight) {
                const b = i.directional[d];
                b.direction.setFromMatrixPosition(_.matrixWorld), s.setFromMatrixPosition(_.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(A), d++
            } else if (_.isSpotLight) {
                const b = i.spot[f];
                b.position.setFromMatrixPosition(_.matrixWorld), b.position.applyMatrix4(A), b.direction.setFromMatrixPosition(_.matrixWorld), s.setFromMatrixPosition(_.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(A), f++
            } else if (_.isRectAreaLight) {
                const b = i.rectArea[m];
                b.position.setFromMatrixPosition(_.matrixWorld), b.position.applyMatrix4(A), o.identity(), r.copy(_.matrixWorld), r.premultiply(A), o.extractRotation(r), b.halfWidth.set(_.width * .5, 0, 0), b.halfHeight.set(0, _.height * .5, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), m++
            } else if (_.isPointLight) {
                const b = i.point[h];
                b.position.setFromMatrixPosition(_.matrixWorld), b.position.applyMatrix4(A), h++
            } else if (_.isHemisphereLight) {
                const b = i.hemi[g];
                b.direction.setFromMatrixPosition(_.matrixWorld), b.direction.transformDirection(A), g++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: i
    }
}

function Kv(n) {
    const e = new Kk(n),
        t = [],
        i = [];

    function s() {
        t.length = 0, i.length = 0
    }

    function r(u) {
        t.push(u)
    }

    function o(u) {
        i.push(u)
    }

    function a(u) {
        e.setup(t, u)
    }

    function l(u) {
        e.setupView(t, u)
    }
    return {
        init: s,
        state: {
            lightsArray: t,
            shadowsArray: i,
            lights: e,
            transmissionRenderTarget: null
        },
        setupLights: a,
        setupLightsView: l,
        pushLight: r,
        pushShadow: o
    }
}

function Jk(n) {
    let e = new WeakMap;

    function t(s, r = 0) {
        const o = e.get(s);
        let a;
        return o === void 0 ? (a = new Kv(n), e.set(s, [a])) : r >= o.length ? (a = new Kv(n), o.push(a)) : a = o[r], a
    }

    function i() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: i
    }
}
class Mw extends In {
    constructor(e) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = FR, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }
}
class Zk extends In {
    constructor(e) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }
}
const eF = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    tF = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function iF(n, e, t) {
    let i = new Qf;
    const s = new _e,
        r = new _e,
        o = new Rt,
        a = new Mw({
            depthPacking: uw
        }),
        l = new Zk,
        c = {},
        u = t.maxTextureSize,
        d = {
            [wr]: Mn,
            [Mn]: wr,
            [Fs]: Fs
        },
        h = new ti({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new _e
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: eF,
            fragmentShader: tF
        }),
        f = h.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const m = new Gi;
    m.setAttribute("position", new pi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const g = new Ri(m, h),
        A = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ZE;
    let p = this.type;
    this.render = function (E, C, S) {
        if (A.enabled === !1 || A.autoUpdate === !1 && A.needsUpdate === !1 || E.length === 0) return;
        const x = n.getRenderTarget(),
            y = n.getActiveCubeFace(),
            P = n.getActiveMipmapLevel(),
            T = n.state;
        T.setBlending(Hs), T.buffers.color.setClear(1, 1, 1, 1), T.buffers.depth.setTest(!0), T.setScissorTest(!1);
        const R = p !== sr && this.type === sr,
            D = p === sr && this.type !== sr;
        for (let U = 0, Q = E.length; U < Q; U++) {
            const F = E[U],
                L = F.shadow;
            if (L === void 0) {
                console.warn("THREE.WebGLShadowMap:", F, "has no shadow.");
                continue
            }
            if (L.autoUpdate === !1 && L.needsUpdate === !1) continue;
            s.copy(L.mapSize);
            const W = L.getFrameExtents();
            if (s.multiply(W), r.copy(L.mapSize), (s.x > u || s.y > u) && (s.x > u && (r.x = Math.floor(u / W.x), s.x = r.x * W.x, L.mapSize.x = r.x), s.y > u && (r.y = Math.floor(u / W.y), s.y = r.y * W.y, L.mapSize.y = r.y)), L.map === null || R === !0 || D === !0) {
                const $ = this.type !== sr ? {
                    minFilter: Kt,
                    magFilter: Kt
                } : {};
                L.map !== null && L.map.dispose(), L.map = new mn(s.x, s.y, $), L.map.texture.name = F.name + ".shadowMap", L.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(L.map), n.clear();
            const k = L.getViewportCount();
            for (let $ = 0; $ < k; $++) {
                const X = L.getViewport($);
                o.set(r.x * X.x, r.y * X.y, r.x * X.z, r.y * X.w), T.viewport(o), L.updateMatrices(F, $), i = L.getFrustum(), b(C, S, L.camera, F, this.type)
            }
            L.isPointLightShadow !== !0 && this.type === sr && v(L, S), L.needsUpdate = !1
        }
        p = this.type, A.needsUpdate = !1, n.setRenderTarget(x, y, P)
    };

    function v(E, C) {
        const S = e.update(g);
        h.defines.VSM_SAMPLES !== E.blurSamples && (h.defines.VSM_SAMPLES = E.blurSamples, f.defines.VSM_SAMPLES = E.blurSamples, h.needsUpdate = !0, f.needsUpdate = !0), E.mapPass === null && (E.mapPass = new mn(s.x, s.y)), h.uniforms.shadow_pass.value = E.map.texture, h.uniforms.resolution.value = E.mapSize, h.uniforms.radius.value = E.radius, n.setRenderTarget(E.mapPass), n.clear(), n.renderBufferDirect(C, null, S, h, g, null), f.uniforms.shadow_pass.value = E.mapPass.texture, f.uniforms.resolution.value = E.mapSize, f.uniforms.radius.value = E.radius, n.setRenderTarget(E.map), n.clear(), n.renderBufferDirect(C, null, S, f, g, null)
    }

    function _(E, C, S, x) {
        let y = null;
        const P = S.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
        if (P !== void 0) y = P;
        else if (y = S.isPointLight === !0 ? l : a, n.localClippingEnabled && C.clipShadows === !0 && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0 || C.displacementMap && C.displacementScale !== 0 || C.alphaMap && C.alphaTest > 0 || C.map && C.alphaTest > 0) {
            const T = y.uuid,
                R = C.uuid;
            let D = c[T];
            D === void 0 && (D = {}, c[T] = D);
            let U = D[R];
            U === void 0 && (U = y.clone(), D[R] = U, C.addEventListener("dispose", w)), y = U
        }
        if (y.visible = C.visible, y.wireframe = C.wireframe, x === sr ? y.side = C.shadowSide !== null ? C.shadowSide : C.side : y.side = C.shadowSide !== null ? C.shadowSide : d[C.side], y.alphaMap = C.alphaMap, y.alphaTest = C.alphaTest, y.map = C.map, y.clipShadows = C.clipShadows, y.clippingPlanes = C.clippingPlanes, y.clipIntersection = C.clipIntersection, y.displacementMap = C.displacementMap, y.displacementScale = C.displacementScale, y.displacementBias = C.displacementBias, y.wireframeLinewidth = C.wireframeLinewidth, y.linewidth = C.linewidth, S.isPointLight === !0 && y.isMeshDistanceMaterial === !0) {
            const T = n.properties.get(y);
            T.light = S
        }
        return y
    }

    function b(E, C, S, x, y) {
        if (E.visible === !1) return;
        if (E.layers.test(C.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && y === sr) && (!E.frustumCulled || i.intersectsObject(E))) {
            E.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, E.matrixWorld);
            const R = e.update(E),
                D = E.material;
            if (Array.isArray(D)) {
                const U = R.groups;
                for (let Q = 0, F = U.length; Q < F; Q++) {
                    const L = U[Q],
                        W = D[L.materialIndex];
                    if (W && W.visible) {
                        const k = _(E, W, x, y);
                        E.onBeforeShadow(n, E, C, S, R, k, L), n.renderBufferDirect(S, null, R, k, E, L), E.onAfterShadow(n, E, C, S, R, k, L)
                    }
                }
            } else if (D.visible) {
                const U = _(E, D, x, y);
                E.onBeforeShadow(n, E, C, S, R, U, null), n.renderBufferDirect(S, null, R, U, E, null), E.onAfterShadow(n, E, C, S, R, U, null)
            }
        }
        const T = E.children;
        for (let R = 0, D = T.length; R < D; R++) b(T[R], C, S, x, y)
    }

    function w(E) {
        E.target.removeEventListener("dispose", w);
        for (const S in c) {
            const x = c[S],
                y = E.target.uuid;
            y in x && (x[y].dispose(), delete x[y])
        }
    }
}

function nF(n) {
    function e() {
        let B = !1;
        const ee = new Rt;
        let pe = null;
        const be = new Rt(0, 0, 0, 0);
        return {
            setMask: function (Se) {
                pe !== Se && !B && (n.colorMask(Se, Se, Se, Se), pe = Se)
            },
            setLocked: function (Se) {
                B = Se
            },
            setClear: function (Se, et, tt, xt, Tt) {
                Tt === !0 && (Se *= xt, et *= xt, tt *= xt), ee.set(Se, et, tt, xt), be.equals(ee) === !1 && (n.clearColor(Se, et, tt, xt), be.copy(ee))
            },
            reset: function () {
                B = !1, pe = null, be.set(-1, 0, 0, 0)
            }
        }
    }

    function t() {
        let B = !1,
            ee = null,
            pe = null,
            be = null;
        return {
            setTest: function (Se) {
                Se ? ue(n.DEPTH_TEST) : fe(n.DEPTH_TEST)
            },
            setMask: function (Se) {
                ee !== Se && !B && (n.depthMask(Se), ee = Se)
            },
            setFunc: function (Se) {
                if (pe !== Se) {
                    switch (Se) {
                        case hR:
                            n.depthFunc(n.NEVER);
                            break;
                        case fR:
                            n.depthFunc(n.ALWAYS);
                            break;
                        case pR:
                            n.depthFunc(n.LESS);
                            break;
                        case Jh:
                            n.depthFunc(n.LEQUAL);
                            break;
                        case mR:
                            n.depthFunc(n.EQUAL);
                            break;
                        case gR:
                            n.depthFunc(n.GEQUAL);
                            break;
                        case AR:
                            n.depthFunc(n.GREATER);
                            break;
                        case _R:
                            n.depthFunc(n.NOTEQUAL);
                            break;
                        default:
                            n.depthFunc(n.LEQUAL)
                    }
                    pe = Se
                }
            },
            setLocked: function (Se) {
                B = Se
            },
            setClear: function (Se) {
                be !== Se && (n.clearDepth(Se), be = Se)
            },
            reset: function () {
                B = !1, ee = null, pe = null, be = null
            }
        }
    }

    function i() {
        let B = !1,
            ee = null,
            pe = null,
            be = null,
            Se = null,
            et = null,
            tt = null,
            xt = null,
            Tt = null;
        return {
            setTest: function (mt) {
                B || (mt ? ue(n.STENCIL_TEST) : fe(n.STENCIL_TEST))
            },
            setMask: function (mt) {
                ee !== mt && !B && (n.stencilMask(mt), ee = mt)
            },
            setFunc: function (mt, Ne, De) {
                (pe !== mt || be !== Ne || Se !== De) && (n.stencilFunc(mt, Ne, De), pe = mt, be = Ne, Se = De)
            },
            setOp: function (mt, Ne, De) {
                (et !== mt || tt !== Ne || xt !== De) && (n.stencilOp(mt, Ne, De), et = mt, tt = Ne, xt = De)
            },
            setLocked: function (mt) {
                B = mt
            },
            setClear: function (mt) {
                Tt !== mt && (n.clearStencil(mt), Tt = mt)
            },
            reset: function () {
                B = !1, ee = null, pe = null, be = null, Se = null, et = null, tt = null, xt = null, Tt = null
            }
        }
    }
    const s = new e,
        r = new t,
        o = new i,
        a = new WeakMap,
        l = new WeakMap;
    let c = {},
        u = {},
        d = new WeakMap,
        h = [],
        f = null,
        m = !1,
        g = null,
        A = null,
        p = null,
        v = null,
        _ = null,
        b = null,
        w = null,
        E = new Ue(0, 0, 0),
        C = 0,
        S = !1,
        x = null,
        y = null,
        P = null,
        T = null,
        R = null;
    const D = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let U = !1,
        Q = 0;
    const F = n.getParameter(n.VERSION);
    F.indexOf("WebGL") !== -1 ? (Q = parseFloat(/^WebGL (\d)/.exec(F)[1]), U = Q >= 1) : F.indexOf("OpenGL ES") !== -1 && (Q = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]), U = Q >= 2);
    let L = null,
        W = {};
    const k = n.getParameter(n.SCISSOR_BOX),
        $ = n.getParameter(n.VIEWPORT),
        X = new Rt().fromArray(k),
        le = new Rt().fromArray($);

    function K(B, ee, pe, be) {
        const Se = new Uint8Array(4),
            et = n.createTexture();
        n.bindTexture(B, et), n.texParameteri(B, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(B, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let tt = 0; tt < pe; tt++) B === n.TEXTURE_3D || B === n.TEXTURE_2D_ARRAY ? n.texImage3D(ee, 0, n.RGBA, 1, 1, be, 0, n.RGBA, n.UNSIGNED_BYTE, Se) : n.texImage2D(ee + tt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Se);
        return et
    }
    const te = {};
    te[n.TEXTURE_2D] = K(n.TEXTURE_2D, n.TEXTURE_2D, 1), te[n.TEXTURE_CUBE_MAP] = K(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), te[n.TEXTURE_2D_ARRAY] = K(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), te[n.TEXTURE_3D] = K(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), r.setClear(1), o.setClear(0), ue(n.DEPTH_TEST), r.setFunc(Jh), Y(!1), se(U_), ue(n.CULL_FACE), N(Hs);

    function ue(B) {
        c[B] !== !0 && (n.enable(B), c[B] = !0)
    }

    function fe(B) {
        c[B] !== !1 && (n.disable(B), c[B] = !1)
    }

    function Me(B, ee) {
        return u[B] !== ee ? (n.bindFramebuffer(B, ee), u[B] = ee, B === n.DRAW_FRAMEBUFFER && (u[n.FRAMEBUFFER] = ee), B === n.FRAMEBUFFER && (u[n.DRAW_FRAMEBUFFER] = ee), !0) : !1
    }

    function Be(B, ee) {
        let pe = h,
            be = !1;
        if (B) {
            pe = d.get(ee), pe === void 0 && (pe = [], d.set(ee, pe));
            const Se = B.textures;
            if (pe.length !== Se.length || pe[0] !== n.COLOR_ATTACHMENT0) {
                for (let et = 0, tt = Se.length; et < tt; et++) pe[et] = n.COLOR_ATTACHMENT0 + et;
                pe.length = Se.length, be = !0
            }
        } else pe[0] !== n.BACK && (pe[0] = n.BACK, be = !0);
        be && n.drawBuffers(pe)
    }

    function Ce(B) {
        return f !== B ? (n.useProgram(B), f = B, !0) : !1
    }
    const Z = {
        [ta]: n.FUNC_ADD,
        [YB]: n.FUNC_SUBTRACT,
        [XB]: n.FUNC_REVERSE_SUBTRACT
    };
    Z[KB] = n.MIN, Z[JB] = n.MAX;
    const ke = {
        [ZB]: n.ZERO,
        [eR]: n.ONE,
        [tR]: n.SRC_COLOR,
        [hg]: n.SRC_ALPHA,
        [aR]: n.SRC_ALPHA_SATURATE,
        [rR]: n.DST_COLOR,
        [nR]: n.DST_ALPHA,
        [iR]: n.ONE_MINUS_SRC_COLOR,
        [fg]: n.ONE_MINUS_SRC_ALPHA,
        [oR]: n.ONE_MINUS_DST_COLOR,
        [sR]: n.ONE_MINUS_DST_ALPHA,
        [lR]: n.CONSTANT_COLOR,
        [cR]: n.ONE_MINUS_CONSTANT_COLOR,
        [uR]: n.CONSTANT_ALPHA,
        [dR]: n.ONE_MINUS_CONSTANT_ALPHA
    };

    function N(B, ee, pe, be, Se, et, tt, xt, Tt, mt) {
        if (B === Hs) {
            m === !0 && (fe(n.BLEND), m = !1);
            return
        }
        if (m === !1 && (ue(n.BLEND), m = !0), B !== jB) {
            if (B !== g || mt !== S) {
                if ((A !== ta || _ !== ta) && (n.blendEquation(n.FUNC_ADD), A = ta, _ = ta), mt) switch (B) {
                    case Tl:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Kh:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case Q_:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case z_:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", B);
                        break
                } else switch (B) {
                    case Tl:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Kh:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case Q_:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case z_:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", B);
                        break
                }
                p = null, v = null, b = null, w = null, E.set(0, 0, 0), C = 0, g = B, S = mt
            }
            return
        }
        Se = Se || ee, et = et || pe, tt = tt || be, (ee !== A || Se !== _) && (n.blendEquationSeparate(Z[ee], Z[Se]), A = ee, _ = Se), (pe !== p || be !== v || et !== b || tt !== w) && (n.blendFuncSeparate(ke[pe], ke[be], ke[et], ke[tt]), p = pe, v = be, b = et, w = tt), (xt.equals(E) === !1 || Tt !== C) && (n.blendColor(xt.r, xt.g, xt.b, Tt), E.copy(xt), C = Tt), g = B, S = !1
    }

    function G(B, ee) {
        B.side === Fs ? fe(n.CULL_FACE) : ue(n.CULL_FACE);
        let pe = B.side === Mn;
        ee && (pe = !pe), Y(pe), B.blending === Tl && B.transparent === !1 ? N(Hs) : N(B.blending, B.blendEquation, B.blendSrc, B.blendDst, B.blendEquationAlpha, B.blendSrcAlpha, B.blendDstAlpha, B.blendColor, B.blendAlpha, B.premultipliedAlpha), r.setFunc(B.depthFunc), r.setTest(B.depthTest), r.setMask(B.depthWrite), s.setMask(B.colorWrite);
        const be = B.stencilWrite;
        o.setTest(be), be && (o.setMask(B.stencilWriteMask), o.setFunc(B.stencilFunc, B.stencilRef, B.stencilFuncMask), o.setOp(B.stencilFail, B.stencilZFail, B.stencilZPass)), I(B.polygonOffset, B.polygonOffsetFactor, B.polygonOffsetUnits), B.alphaToCoverage === !0 ? ue(n.SAMPLE_ALPHA_TO_COVERAGE) : fe(n.SAMPLE_ALPHA_TO_COVERAGE)
    }

    function Y(B) {
        x !== B && (B ? n.frontFace(n.CW) : n.frontFace(n.CCW), x = B)
    }

    function se(B) {
        B !== WB ? (ue(n.CULL_FACE), B !== y && (B === U_ ? n.cullFace(n.BACK) : B === qB ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : fe(n.CULL_FACE), y = B
    }

    function M(B) {
        B !== P && (U && n.lineWidth(B), P = B)
    }

    function I(B, ee, pe) {
        B ? (ue(n.POLYGON_OFFSET_FILL), (T !== ee || R !== pe) && (n.polygonOffset(ee, pe), T = ee, R = pe)) : fe(n.POLYGON_OFFSET_FILL)
    }

    function H(B) {
        B ? ue(n.SCISSOR_TEST) : fe(n.SCISSOR_TEST)
    }

    function V(B) {
        B === void 0 && (B = n.TEXTURE0 + D - 1), L !== B && (n.activeTexture(B), L = B)
    }

    function j(B, ee, pe) {
        pe === void 0 && (L === null ? pe = n.TEXTURE0 + D - 1 : pe = L);
        let be = W[pe];
        be === void 0 && (be = {
            type: void 0,
            texture: void 0
        }, W[pe] = be), (be.type !== B || be.texture !== ee) && (L !== pe && (n.activeTexture(pe), L = pe), n.bindTexture(B, ee || te[B]), be.type = B, be.texture = ee)
    }

    function q() {
        const B = W[L];
        B !== void 0 && B.type !== void 0 && (n.bindTexture(B.type, null), B.type = void 0, B.texture = void 0)
    }

    function he() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function re() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function de() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function ge() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function ce() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function me() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function xe() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function ve() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function we() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function Pe() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (B) {
            console.error("THREE.WebGLState:", B)
        }
    }

    function Ke(B) {
        X.equals(B) === !1 && (n.scissor(B.x, B.y, B.z, B.w), X.copy(B))
    }

    function Ve(B) {
        le.equals(B) === !1 && (n.viewport(B.x, B.y, B.z, B.w), le.copy(B))
    }

    function Le(B, ee) {
        let pe = l.get(ee);
        pe === void 0 && (pe = new WeakMap, l.set(ee, pe));
        let be = pe.get(B);
        be === void 0 && (be = n.getUniformBlockIndex(ee, B.name), pe.set(B, be))
    }

    function We(B, ee) {
        const be = l.get(ee).get(B);
        a.get(ee) !== be && (n.uniformBlockBinding(ee, be, B.__bindingPointIndex), a.set(ee, be))
    }

    function Te() {
        n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), c = {}, L = null, W = {}, u = {}, d = new WeakMap, h = [], f = null, m = !1, g = null, A = null, p = null, v = null, _ = null, b = null, w = null, E = new Ue(0, 0, 0), C = 0, S = !1, x = null, y = null, P = null, T = null, R = null, X.set(0, 0, n.canvas.width, n.canvas.height), le.set(0, 0, n.canvas.width, n.canvas.height), s.reset(), r.reset(), o.reset()
    }
    return {
        buffers: {
            color: s,
            depth: r,
            stencil: o
        },
        enable: ue,
        disable: fe,
        bindFramebuffer: Me,
        drawBuffers: Be,
        useProgram: Ce,
        setBlending: N,
        setMaterial: G,
        setFlipSided: Y,
        setCullFace: se,
        setLineWidth: M,
        setPolygonOffset: I,
        setScissorTest: H,
        activeTexture: V,
        bindTexture: j,
        unbindTexture: q,
        compressedTexImage2D: he,
        compressedTexImage3D: re,
        texImage2D: we,
        texImage3D: Pe,
        updateUBOMapping: Le,
        uniformBlockBinding: We,
        texStorage2D: xe,
        texStorage3D: ve,
        texSubImage2D: de,
        texSubImage3D: ge,
        compressedTexSubImage2D: ce,
        compressedTexSubImage3D: me,
        scissor: Ke,
        viewport: Ve,
        reset: Te
    }
}

function sF(n, e, t, i, s, r, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
        l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        c = new _e,
        u = new WeakMap;
    let d;
    const h = new WeakMap;
    let f = !1;
    try {
        f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch { }

    function m(M, I) {
        return f ? new OffscreenCanvas(M, I) : Mu("canvas")
    }

    function g(M, I, H) {
        let V = 1;
        const j = se(M);
        if ((j.width > H || j.height > H) && (V = H / Math.max(j.width, j.height)), V < 1)
            if (typeof HTMLImageElement < "u" && M instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && M instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && M instanceof ImageBitmap || typeof VideoFrame < "u" && M instanceof VideoFrame) {
                const q = Math.floor(V * j.width),
                    he = Math.floor(V * j.height);
                d === void 0 && (d = m(q, he));
                const re = I ? m(q, he) : d;
                return re.width = q, re.height = he, re.getContext("2d").drawImage(M, 0, 0, q, he), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + j.width + "x" + j.height + ") to (" + q + "x" + he + ")."), re
            } else return "data" in M && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + j.width + "x" + j.height + ")."), M;
        return M
    }

    function A(M) {
        return M.generateMipmaps && M.minFilter !== Kt && M.minFilter !== Pt
    }

    function p(M) {
        n.generateMipmap(M)
    }

    function v(M, I, H, V, j = !1) {
        if (M !== null) {
            if (n[M] !== void 0) return n[M];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + M + "'")
        }
        let q = I;
        if (I === n.RED && (H === n.FLOAT && (q = n.R32F), H === n.HALF_FLOAT && (q = n.R16F), H === n.UNSIGNED_BYTE && (q = n.R8)), I === n.RED_INTEGER && (H === n.UNSIGNED_BYTE && (q = n.R8UI), H === n.UNSIGNED_SHORT && (q = n.R16UI), H === n.UNSIGNED_INT && (q = n.R32UI), H === n.BYTE && (q = n.R8I), H === n.SHORT && (q = n.R16I), H === n.INT && (q = n.R32I)), I === n.RG && (H === n.FLOAT && (q = n.RG32F), H === n.HALF_FLOAT && (q = n.RG16F), H === n.UNSIGNED_BYTE && (q = n.RG8)), I === n.RG_INTEGER && (H === n.UNSIGNED_BYTE && (q = n.RG8UI), H === n.UNSIGNED_SHORT && (q = n.RG16UI), H === n.UNSIGNED_INT && (q = n.RG32UI), H === n.BYTE && (q = n.RG8I), H === n.SHORT && (q = n.RG16I), H === n.INT && (q = n.RG32I)), I === n.RGB && H === n.UNSIGNED_INT_5_9_9_9_REV && (q = n.RGB9_E5), I === n.RGBA) {
            const he = j ? sf : vt.getTransfer(V);
            H === n.FLOAT && (q = n.RGBA32F), H === n.HALF_FLOAT && (q = n.RGBA16F), H === n.UNSIGNED_BYTE && (q = he === Lt ? n.SRGB8_ALPHA8 : n.RGBA8), H === n.UNSIGNED_SHORT_4_4_4_4 && (q = n.RGBA4), H === n.UNSIGNED_SHORT_5_5_5_1 && (q = n.RGB5_A1)
        }
        return (q === n.R16F || q === n.R32F || q === n.RG16F || q === n.RG32F || q === n.RGBA16F || q === n.RGBA32F) && e.get("EXT_color_buffer_float"), q
    }

    function _(M, I) {
        return A(M) === !0 || M.isFramebufferTexture && M.minFilter !== Kt && M.minFilter !== Pt ? Math.log2(Math.max(I.width, I.height)) + 1 : M.mipmaps !== void 0 && M.mipmaps.length > 0 ? M.mipmaps.length : M.isCompressedTexture && Array.isArray(M.image) ? I.mipmaps.length : 1
    }

    function b(M) {
        const I = M.target;
        I.removeEventListener("dispose", b), E(I), I.isVideoTexture && u.delete(I)
    }

    function w(M) {
        const I = M.target;
        I.removeEventListener("dispose", w), S(I)
    }

    function E(M) {
        const I = i.get(M);
        if (I.__webglInit === void 0) return;
        const H = M.source,
            V = h.get(H);
        if (V) {
            const j = V[I.__cacheKey];
            j.usedTimes--, j.usedTimes === 0 && C(M), Object.keys(V).length === 0 && h.delete(H)
        }
        i.remove(M)
    }

    function C(M) {
        const I = i.get(M);
        n.deleteTexture(I.__webglTexture);
        const H = M.source,
            V = h.get(H);
        delete V[I.__cacheKey], o.memory.textures--
    }

    function S(M) {
        const I = i.get(M);
        if (M.depthTexture && M.depthTexture.dispose(), M.isWebGLCubeRenderTarget)
            for (let V = 0; V < 6; V++) {
                if (Array.isArray(I.__webglFramebuffer[V]))
                    for (let j = 0; j < I.__webglFramebuffer[V].length; j++) n.deleteFramebuffer(I.__webglFramebuffer[V][j]);
                else n.deleteFramebuffer(I.__webglFramebuffer[V]);
                I.__webglDepthbuffer && n.deleteRenderbuffer(I.__webglDepthbuffer[V])
            } else {
            if (Array.isArray(I.__webglFramebuffer))
                for (let V = 0; V < I.__webglFramebuffer.length; V++) n.deleteFramebuffer(I.__webglFramebuffer[V]);
            else n.deleteFramebuffer(I.__webglFramebuffer);
            if (I.__webglDepthbuffer && n.deleteRenderbuffer(I.__webglDepthbuffer), I.__webglMultisampledFramebuffer && n.deleteFramebuffer(I.__webglMultisampledFramebuffer), I.__webglColorRenderbuffer)
                for (let V = 0; V < I.__webglColorRenderbuffer.length; V++) I.__webglColorRenderbuffer[V] && n.deleteRenderbuffer(I.__webglColorRenderbuffer[V]);
            I.__webglDepthRenderbuffer && n.deleteRenderbuffer(I.__webglDepthRenderbuffer)
        }
        const H = M.textures;
        for (let V = 0, j = H.length; V < j; V++) {
            const q = i.get(H[V]);
            q.__webglTexture && (n.deleteTexture(q.__webglTexture), o.memory.textures--), i.remove(H[V])
        }
        i.remove(M)
    }
    let x = 0;

    function y() {
        x = 0
    }

    function P() {
        const M = x;
        return M >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + M + " texture units while this GPU supports only " + s.maxTextures), x += 1, M
    }

    function T(M) {
        const I = [];
        return I.push(M.wrapS), I.push(M.wrapT), I.push(M.wrapR || 0), I.push(M.magFilter), I.push(M.minFilter), I.push(M.anisotropy), I.push(M.internalFormat), I.push(M.format), I.push(M.type), I.push(M.generateMipmaps), I.push(M.premultiplyAlpha), I.push(M.flipY), I.push(M.unpackAlignment), I.push(M.colorSpace), I.join()
    }

    function R(M, I) {
        const H = i.get(M);
        if (M.isVideoTexture && G(M), M.isRenderTargetTexture === !1 && M.version > 0 && H.__version !== M.version) {
            const V = M.image;
            if (V === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (V.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                X(H, M, I);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, H.__webglTexture, n.TEXTURE0 + I)
    }

    function D(M, I) {
        const H = i.get(M);
        if (M.version > 0 && H.__version !== M.version) {
            X(H, M, I);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, H.__webglTexture, n.TEXTURE0 + I)
    }

    function U(M, I) {
        const H = i.get(M);
        if (M.version > 0 && H.__version !== M.version) {
            X(H, M, I);
            return
        }
        t.bindTexture(n.TEXTURE_3D, H.__webglTexture, n.TEXTURE0 + I)
    }

    function Q(M, I) {
        const H = i.get(M);
        if (M.version > 0 && H.__version !== M.version) {
            le(H, M, I);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, H.__webglTexture, n.TEXTURE0 + I)
    }
    const F = {
        [Eo]: n.REPEAT,
        [pn]: n.CLAMP_TO_EDGE,
        [ef]: n.MIRRORED_REPEAT
    },
        L = {
            [Kt]: n.NEAREST,
            [tw]: n.NEAREST_MIPMAP_NEAREST,
            [Ic]: n.NEAREST_MIPMAP_LINEAR,
            [Pt]: n.LINEAR,
            [vh]: n.LINEAR_MIPMAP_NEAREST,
            [ys]: n.LINEAR_MIPMAP_LINEAR
        },
        W = {
            [OR]: n.NEVER,
            [VR]: n.ALWAYS,
            [UR]: n.LESS,
            [dw]: n.LEQUAL,
            [QR]: n.EQUAL,
            [HR]: n.GEQUAL,
            [zR]: n.GREATER,
            [GR]: n.NOTEQUAL
        };

    function k(M, I) {
        if (I.type === ei && e.has("OES_texture_float_linear") === !1 && (I.magFilter === Pt || I.magFilter === vh || I.magFilter === Ic || I.magFilter === ys || I.minFilter === Pt || I.minFilter === vh || I.minFilter === Ic || I.minFilter === ys) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), n.texParameteri(M, n.TEXTURE_WRAP_S, F[I.wrapS]), n.texParameteri(M, n.TEXTURE_WRAP_T, F[I.wrapT]), (M === n.TEXTURE_3D || M === n.TEXTURE_2D_ARRAY) && n.texParameteri(M, n.TEXTURE_WRAP_R, F[I.wrapR]), n.texParameteri(M, n.TEXTURE_MAG_FILTER, L[I.magFilter]), n.texParameteri(M, n.TEXTURE_MIN_FILTER, L[I.minFilter]), I.compareFunction && (n.texParameteri(M, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(M, n.TEXTURE_COMPARE_FUNC, W[I.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
            if (I.magFilter === Kt || I.minFilter !== Ic && I.minFilter !== ys || I.type === ei && e.has("OES_texture_float_linear") === !1) return;
            if (I.anisotropy > 1 || i.get(I).__currentAnisotropy) {
                const H = e.get("EXT_texture_filter_anisotropic");
                n.texParameterf(M, H.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(I.anisotropy, s.getMaxAnisotropy())), i.get(I).__currentAnisotropy = I.anisotropy
            }
        }
    }

    function $(M, I) {
        let H = !1;
        M.__webglInit === void 0 && (M.__webglInit = !0, I.addEventListener("dispose", b));
        const V = I.source;
        let j = h.get(V);
        j === void 0 && (j = {}, h.set(V, j));
        const q = T(I);
        if (q !== M.__cacheKey) {
            j[q] === void 0 && (j[q] = {
                texture: n.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, H = !0), j[q].usedTimes++;
            const he = j[M.__cacheKey];
            he !== void 0 && (j[M.__cacheKey].usedTimes--, he.usedTimes === 0 && C(I)), M.__cacheKey = q, M.__webglTexture = j[q].texture
        }
        return H
    }

    function X(M, I, H) {
        let V = n.TEXTURE_2D;
        (I.isDataArrayTexture || I.isCompressedArrayTexture) && (V = n.TEXTURE_2D_ARRAY), I.isData3DTexture && (V = n.TEXTURE_3D);
        const j = $(M, I),
            q = I.source;
        t.bindTexture(V, M.__webglTexture, n.TEXTURE0 + H);
        const he = i.get(q);
        if (q.version !== he.__version || j === !0) {
            t.activeTexture(n.TEXTURE0 + H);
            const re = vt.getPrimaries(vt.workingColorSpace),
                de = I.colorSpace === Ns ? null : vt.getPrimaries(I.colorSpace),
                ge = I.colorSpace === Ns || re === de ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ge);
            let ce = g(I.image, !1, s.maxTextureSize);
            ce = Y(I, ce);
            const me = r.convert(I.format, I.colorSpace),
                xe = r.convert(I.type);
            let ve = v(I.internalFormat, me, xe, I.colorSpace, I.isVideoTexture);
            k(V, I);
            let we;
            const Pe = I.mipmaps,
                Ke = I.isVideoTexture !== !0 && ve !== i0,
                Ve = he.__version === void 0 || j === !0,
                Le = q.dataReady,
                We = _(I, ce);
            if (I.isDepthTexture) ve = n.DEPTH_COMPONENT16, I.type === ei ? ve = n.DEPTH_COMPONENT32F : I.type === Hl ? ve = n.DEPTH_COMPONENT24 : I.type === Hu && (ve = n.DEPTH24_STENCIL8), Ve && (Ke ? t.texStorage2D(n.TEXTURE_2D, 1, ve, ce.width, ce.height) : t.texImage2D(n.TEXTURE_2D, 0, ve, ce.width, ce.height, 0, me, xe, null));
            else if (I.isDataTexture)
                if (Pe.length > 0) {
                    Ke && Ve && t.texStorage2D(n.TEXTURE_2D, We, ve, Pe[0].width, Pe[0].height);
                    for (let Te = 0, B = Pe.length; Te < B; Te++) we = Pe[Te], Ke ? Le && t.texSubImage2D(n.TEXTURE_2D, Te, 0, 0, we.width, we.height, me, xe, we.data) : t.texImage2D(n.TEXTURE_2D, Te, ve, we.width, we.height, 0, me, xe, we.data);
                    I.generateMipmaps = !1
                } else Ke ? (Ve && t.texStorage2D(n.TEXTURE_2D, We, ve, ce.width, ce.height), Le && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, ce.width, ce.height, me, xe, ce.data)) : t.texImage2D(n.TEXTURE_2D, 0, ve, ce.width, ce.height, 0, me, xe, ce.data);
            else if (I.isCompressedTexture)
                if (I.isCompressedArrayTexture) {
                    Ke && Ve && t.texStorage3D(n.TEXTURE_2D_ARRAY, We, ve, Pe[0].width, Pe[0].height, ce.depth);
                    for (let Te = 0, B = Pe.length; Te < B; Te++) we = Pe[Te], I.format !== Jt ? me !== null ? Ke ? Le && t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Te, 0, 0, 0, we.width, we.height, ce.depth, me, we.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Te, ve, we.width, we.height, ce.depth, 0, we.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ke ? Le && t.texSubImage3D(n.TEXTURE_2D_ARRAY, Te, 0, 0, 0, we.width, we.height, ce.depth, me, xe, we.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, Te, ve, we.width, we.height, ce.depth, 0, me, xe, we.data)
                } else {
                    Ke && Ve && t.texStorage2D(n.TEXTURE_2D, We, ve, Pe[0].width, Pe[0].height);
                    for (let Te = 0, B = Pe.length; Te < B; Te++) we = Pe[Te], I.format !== Jt ? me !== null ? Ke ? Le && t.compressedTexSubImage2D(n.TEXTURE_2D, Te, 0, 0, we.width, we.height, me, we.data) : t.compressedTexImage2D(n.TEXTURE_2D, Te, ve, we.width, we.height, 0, we.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ke ? Le && t.texSubImage2D(n.TEXTURE_2D, Te, 0, 0, we.width, we.height, me, xe, we.data) : t.texImage2D(n.TEXTURE_2D, Te, ve, we.width, we.height, 0, me, xe, we.data)
                }
            else if (I.isDataArrayTexture) Ke ? (Ve && t.texStorage3D(n.TEXTURE_2D_ARRAY, We, ve, ce.width, ce.height, ce.depth), Le && t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ce.width, ce.height, ce.depth, me, xe, ce.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, ve, ce.width, ce.height, ce.depth, 0, me, xe, ce.data);
            else if (I.isData3DTexture) Ke ? (Ve && t.texStorage3D(n.TEXTURE_3D, We, ve, ce.width, ce.height, ce.depth), Le && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, ce.width, ce.height, ce.depth, me, xe, ce.data)) : t.texImage3D(n.TEXTURE_3D, 0, ve, ce.width, ce.height, ce.depth, 0, me, xe, ce.data);
            else if (I.isFramebufferTexture) {
                if (Ve)
                    if (Ke) t.texStorage2D(n.TEXTURE_2D, We, ve, ce.width, ce.height);
                    else {
                        let Te = ce.width,
                            B = ce.height;
                        for (let ee = 0; ee < We; ee++) t.texImage2D(n.TEXTURE_2D, ee, ve, Te, B, 0, me, xe, null), Te >>= 1, B >>= 1
                    }
            } else if (Pe.length > 0) {
                if (Ke && Ve) {
                    const Te = se(Pe[0]);
                    t.texStorage2D(n.TEXTURE_2D, We, ve, Te.width, Te.height)
                }
                for (let Te = 0, B = Pe.length; Te < B; Te++) we = Pe[Te], Ke ? Le && t.texSubImage2D(n.TEXTURE_2D, Te, 0, 0, me, xe, we) : t.texImage2D(n.TEXTURE_2D, Te, ve, me, xe, we);
                I.generateMipmaps = !1
            } else if (Ke) {
                if (Ve) {
                    const Te = se(ce);
                    t.texStorage2D(n.TEXTURE_2D, We, ve, Te.width, Te.height)
                }
                Le && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, me, xe, ce)
            } else t.texImage2D(n.TEXTURE_2D, 0, ve, me, xe, ce);
            A(I) && p(V), he.__version = q.version, I.onUpdate && I.onUpdate(I)
        }
        M.__version = I.version
    }

    function le(M, I, H) {
        if (I.image.length !== 6) return;
        const V = $(M, I),
            j = I.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, M.__webglTexture, n.TEXTURE0 + H);
        const q = i.get(j);
        if (j.version !== q.__version || V === !0) {
            t.activeTexture(n.TEXTURE0 + H);
            const he = vt.getPrimaries(vt.workingColorSpace),
                re = I.colorSpace === Ns ? null : vt.getPrimaries(I.colorSpace),
                de = I.colorSpace === Ns || he === re ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, de);
            const ge = I.isCompressedTexture || I.image[0].isCompressedTexture,
                ce = I.image[0] && I.image[0].isDataTexture,
                me = [];
            for (let B = 0; B < 6; B++) !ge && !ce ? me[B] = g(I.image[B], !0, s.maxCubemapSize) : me[B] = ce ? I.image[B].image : I.image[B], me[B] = Y(I, me[B]);
            const xe = me[0],
                ve = r.convert(I.format, I.colorSpace),
                we = r.convert(I.type),
                Pe = v(I.internalFormat, ve, we, I.colorSpace),
                Ke = I.isVideoTexture !== !0,
                Ve = q.__version === void 0 || V === !0,
                Le = j.dataReady;
            let We = _(I, xe);
            k(n.TEXTURE_CUBE_MAP, I);
            let Te;
            if (ge) {
                Ke && Ve && t.texStorage2D(n.TEXTURE_CUBE_MAP, We, Pe, xe.width, xe.height);
                for (let B = 0; B < 6; B++) {
                    Te = me[B].mipmaps;
                    for (let ee = 0; ee < Te.length; ee++) {
                        const pe = Te[ee];
                        I.format !== Jt ? ve !== null ? Ke ? Le && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee, 0, 0, pe.width, pe.height, ve, pe.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee, Pe, pe.width, pe.height, 0, pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ke ? Le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee, 0, 0, pe.width, pe.height, ve, we, pe.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee, Pe, pe.width, pe.height, 0, ve, we, pe.data)
                    }
                }
            } else {
                if (Te = I.mipmaps, Ke && Ve) {
                    Te.length > 0 && We++;
                    const B = se(me[0]);
                    t.texStorage2D(n.TEXTURE_CUBE_MAP, We, Pe, B.width, B.height)
                }
                for (let B = 0; B < 6; B++)
                    if (ce) {
                        Ke ? Le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, 0, 0, 0, me[B].width, me[B].height, ve, we, me[B].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, 0, Pe, me[B].width, me[B].height, 0, ve, we, me[B].data);
                        for (let ee = 0; ee < Te.length; ee++) {
                            const be = Te[ee].image[B].image;
                            Ke ? Le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee + 1, 0, 0, be.width, be.height, ve, we, be.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee + 1, Pe, be.width, be.height, 0, ve, we, be.data)
                        }
                    } else {
                        Ke ? Le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, 0, 0, 0, ve, we, me[B]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, 0, Pe, ve, we, me[B]);
                        for (let ee = 0; ee < Te.length; ee++) {
                            const pe = Te[ee];
                            Ke ? Le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee + 1, 0, 0, ve, we, pe.image[B]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + B, ee + 1, Pe, ve, we, pe.image[B])
                        }
                    }
            }
            A(I) && p(n.TEXTURE_CUBE_MAP), q.__version = j.version, I.onUpdate && I.onUpdate(I)
        }
        M.__version = I.version
    }

    function K(M, I, H, V, j, q) {
        const he = r.convert(H.format, H.colorSpace),
            re = r.convert(H.type),
            de = v(H.internalFormat, he, re, H.colorSpace);
        if (!i.get(I).__hasExternalTextures) {
            const ce = Math.max(1, I.width >> q),
                me = Math.max(1, I.height >> q);
            j === n.TEXTURE_3D || j === n.TEXTURE_2D_ARRAY ? t.texImage3D(j, q, de, ce, me, I.depth, 0, he, re, null) : t.texImage2D(j, q, de, ce, me, 0, he, re, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, M), N(I) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, V, j, i.get(H).__webglTexture, 0, ke(I)) : (j === n.TEXTURE_2D || j >= n.TEXTURE_CUBE_MAP_POSITIVE_X && j <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, V, j, i.get(H).__webglTexture, q), t.bindFramebuffer(n.FRAMEBUFFER, null)
    }

    function te(M, I, H) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, M), I.depthBuffer && !I.stencilBuffer) {
            let V = n.DEPTH_COMPONENT24;
            if (H || N(I)) {
                const j = I.depthTexture;
                j && j.isDepthTexture && (j.type === ei ? V = n.DEPTH_COMPONENT32F : j.type === Hl && (V = n.DEPTH_COMPONENT24));
                const q = ke(I);
                N(I) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, q, V, I.width, I.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, q, V, I.width, I.height)
            } else n.renderbufferStorage(n.RENDERBUFFER, V, I.width, I.height);
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, M)
        } else if (I.depthBuffer && I.stencilBuffer) {
            const V = ke(I);
            H && N(I) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, V, n.DEPTH24_STENCIL8, I.width, I.height) : N(I) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, V, n.DEPTH24_STENCIL8, I.width, I.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, I.width, I.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, M)
        } else {
            const V = I.textures;
            for (let j = 0; j < V.length; j++) {
                const q = V[j],
                    he = r.convert(q.format, q.colorSpace),
                    re = r.convert(q.type),
                    de = v(q.internalFormat, he, re, q.colorSpace),
                    ge = ke(I);
                H && N(I) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, ge, de, I.width, I.height) : N(I) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, ge, de, I.width, I.height) : n.renderbufferStorage(n.RENDERBUFFER, de, I.width, I.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }

    function ue(M, I) {
        if (I && I.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, M), !(I.depthTexture && I.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(I.depthTexture).__webglTexture || I.depthTexture.image.width !== I.width || I.depthTexture.image.height !== I.height) && (I.depthTexture.image.width = I.width, I.depthTexture.image.height = I.height, I.depthTexture.needsUpdate = !0), R(I.depthTexture, 0);
        const V = i.get(I.depthTexture).__webglTexture,
            j = ke(I);
        if (I.depthTexture.format === Il) N(I) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, V, 0, j) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, V, 0);
        else if (I.depthTexture.format === Cu) N(I) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, V, 0, j) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, V, 0);
        else throw new Error("Unknown depthTexture format")
    }

    function fe(M) {
        const I = i.get(M),
            H = M.isWebGLCubeRenderTarget === !0;
        if (M.depthTexture && !I.__autoAllocateDepthBuffer) {
            if (H) throw new Error("target.depthTexture not supported in Cube render targets");
            ue(I.__webglFramebuffer, M)
        } else if (H) {
            I.__webglDepthbuffer = [];
            for (let V = 0; V < 6; V++) t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer[V]), I.__webglDepthbuffer[V] = n.createRenderbuffer(), te(I.__webglDepthbuffer[V], M, !1)
        } else t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer), I.__webglDepthbuffer = n.createRenderbuffer(), te(I.__webglDepthbuffer, M, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }

    function Me(M, I, H) {
        const V = i.get(M);
        I !== void 0 && K(V.__webglFramebuffer, M, M.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), H !== void 0 && fe(M)
    }

    function Be(M) {
        const I = M.texture,
            H = i.get(M),
            V = i.get(I);
        M.addEventListener("dispose", w);
        const j = M.textures,
            q = M.isWebGLCubeRenderTarget === !0,
            he = j.length > 1;
        if (he || (V.__webglTexture === void 0 && (V.__webglTexture = n.createTexture()), V.__version = I.version, o.memory.textures++), q) {
            H.__webglFramebuffer = [];
            for (let re = 0; re < 6; re++)
                if (I.mipmaps && I.mipmaps.length > 0) {
                    H.__webglFramebuffer[re] = [];
                    for (let de = 0; de < I.mipmaps.length; de++) H.__webglFramebuffer[re][de] = n.createFramebuffer()
                } else H.__webglFramebuffer[re] = n.createFramebuffer()
        } else {
            if (I.mipmaps && I.mipmaps.length > 0) {
                H.__webglFramebuffer = [];
                for (let re = 0; re < I.mipmaps.length; re++) H.__webglFramebuffer[re] = n.createFramebuffer()
            } else H.__webglFramebuffer = n.createFramebuffer();
            if (he)
                for (let re = 0, de = j.length; re < de; re++) {
                    const ge = i.get(j[re]);
                    ge.__webglTexture === void 0 && (ge.__webglTexture = n.createTexture(), o.memory.textures++)
                }
            if (M.samples > 0 && N(M) === !1) {
                H.__webglMultisampledFramebuffer = n.createFramebuffer(), H.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, H.__webglMultisampledFramebuffer);
                for (let re = 0; re < j.length; re++) {
                    const de = j[re];
                    H.__webglColorRenderbuffer[re] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, H.__webglColorRenderbuffer[re]);
                    const ge = r.convert(de.format, de.colorSpace),
                        ce = r.convert(de.type),
                        me = v(de.internalFormat, ge, ce, de.colorSpace, M.isXRRenderTarget === !0),
                        xe = ke(M);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, xe, me, M.width, M.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + re, n.RENDERBUFFER, H.__webglColorRenderbuffer[re])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null), M.depthBuffer && (H.__webglDepthRenderbuffer = n.createRenderbuffer(), te(H.__webglDepthRenderbuffer, M, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (q) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, V.__webglTexture), k(n.TEXTURE_CUBE_MAP, I);
            for (let re = 0; re < 6; re++)
                if (I.mipmaps && I.mipmaps.length > 0)
                    for (let de = 0; de < I.mipmaps.length; de++) K(H.__webglFramebuffer[re][de], M, I, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + re, de);
                else K(H.__webglFramebuffer[re], M, I, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + re, 0);
            A(I) && p(n.TEXTURE_CUBE_MAP), t.unbindTexture()
        } else if (he) {
            for (let re = 0, de = j.length; re < de; re++) {
                const ge = j[re],
                    ce = i.get(ge);
                t.bindTexture(n.TEXTURE_2D, ce.__webglTexture), k(n.TEXTURE_2D, ge), K(H.__webglFramebuffer, M, ge, n.COLOR_ATTACHMENT0 + re, n.TEXTURE_2D, 0), A(ge) && p(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let re = n.TEXTURE_2D;
            if ((M.isWebGL3DRenderTarget || M.isWebGLArrayRenderTarget) && (re = M.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), t.bindTexture(re, V.__webglTexture), k(re, I), I.mipmaps && I.mipmaps.length > 0)
                for (let de = 0; de < I.mipmaps.length; de++) K(H.__webglFramebuffer[de], M, I, n.COLOR_ATTACHMENT0, re, de);
            else K(H.__webglFramebuffer, M, I, n.COLOR_ATTACHMENT0, re, 0);
            A(I) && p(re), t.unbindTexture()
        }
        M.depthBuffer && fe(M)
    }

    function Ce(M) {
        const I = M.textures;
        for (let H = 0, V = I.length; H < V; H++) {
            const j = I[H];
            if (A(j)) {
                const q = M.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D,
                    he = i.get(j).__webglTexture;
                t.bindTexture(q, he), p(q), t.unbindTexture()
            }
        }
    }

    function Z(M) {
        if (M.samples > 0 && N(M) === !1) {
            const I = M.textures,
                H = M.width,
                V = M.height;
            let j = n.COLOR_BUFFER_BIT;
            const q = [],
                he = M.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
                re = i.get(M),
                de = I.length > 1;
            if (de)
                for (let ge = 0; ge < I.length; ge++) t.bindFramebuffer(n.FRAMEBUFFER, re.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ge, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, re.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ge, n.TEXTURE_2D, null, 0);
            t.bindFramebuffer(n.READ_FRAMEBUFFER, re.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, re.__webglFramebuffer);
            for (let ge = 0; ge < I.length; ge++) {
                q.push(n.COLOR_ATTACHMENT0 + ge), M.depthBuffer && q.push(he);
                const ce = re.__ignoreDepthValues !== void 0 ? re.__ignoreDepthValues : !1;
                if (ce === !1 && (M.depthBuffer && (j |= n.DEPTH_BUFFER_BIT), M.stencilBuffer && re.__isTransmissionRenderTarget !== !0 && (j |= n.STENCIL_BUFFER_BIT)), de && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, re.__webglColorRenderbuffer[ge]), ce === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [he]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [he])), de) {
                    const me = i.get(I[ge]).__webglTexture;
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, me, 0)
                }
                n.blitFramebuffer(0, 0, H, V, 0, 0, H, V, j, n.NEAREST), l && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, q)
            }
            if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), de)
                for (let ge = 0; ge < I.length; ge++) {
                    t.bindFramebuffer(n.FRAMEBUFFER, re.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ge, n.RENDERBUFFER, re.__webglColorRenderbuffer[ge]);
                    const ce = i.get(I[ge]).__webglTexture;
                    t.bindFramebuffer(n.FRAMEBUFFER, re.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ge, n.TEXTURE_2D, ce, 0)
                }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, re.__webglMultisampledFramebuffer)
        }
    }

    function ke(M) {
        return Math.min(s.maxSamples, M.samples)
    }

    function N(M) {
        const I = i.get(M);
        return M.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && I.__useRenderToTexture !== !1
    }

    function G(M) {
        const I = o.render.frame;
        u.get(M) !== I && (u.set(M, I), M.update())
    }

    function Y(M, I) {
        const H = M.colorSpace,
            V = M.format,
            j = M.type;
        return M.isCompressedTexture === !0 || M.isVideoTexture === !0 || H !== gi && H !== Ns && (vt.getTransfer(H) === Lt ? (V !== Jt || j !== hi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", H)), I
    }

    function se(M) {
        return typeof HTMLImageElement < "u" && M instanceof HTMLImageElement ? (c.width = M.naturalWidth || M.width, c.height = M.naturalHeight || M.height) : typeof VideoFrame < "u" && M instanceof VideoFrame ? (c.width = M.displayWidth, c.height = M.displayHeight) : (c.width = M.width, c.height = M.height), c
    }
    this.allocateTextureUnit = P, this.resetTextureUnits = y, this.setTexture2D = R, this.setTexture2DArray = D, this.setTexture3D = U, this.setTextureCube = Q, this.rebindTextures = Me, this.setupRenderTarget = Be, this.updateRenderTargetMipmap = Ce, this.updateMultisampleRenderTarget = Z, this.setupDepthRenderbuffer = fe, this.setupFrameBufferTexture = K, this.useMultisampledRTT = N
}

function rF(n, e) {
    function t(i, s = Ns) {
        let r;
        const o = vt.getTransfer(s);
        if (i === hi) return n.UNSIGNED_BYTE;
        if (i === sw) return n.UNSIGNED_SHORT_4_4_4_4;
        if (i === rw) return n.UNSIGNED_SHORT_5_5_5_1;
        if (i === CR) return n.UNSIGNED_INT_5_9_9_9_REV;
        if (i === ER) return n.BYTE;
        if (i === wR) return n.SHORT;
        if (i === iw) return n.UNSIGNED_SHORT;
        if (i === nw) return n.INT;
        if (i === Hl) return n.UNSIGNED_INT;
        if (i === ei) return n.FLOAT;
        if (i === yi) return n.HALF_FLOAT;
        if (i === SR) return n.ALPHA;
        if (i === MR) return n.RGB;
        if (i === Jt) return n.RGBA;
        if (i === TR) return n.LUMINANCE;
        if (i === IR) return n.LUMINANCE_ALPHA;
        if (i === Il) return n.DEPTH_COMPONENT;
        if (i === Cu) return n.DEPTH_STENCIL;
        if (i === ra) return n.RED;
        if (i === ow) return n.RED_INTEGER;
        if (i === hl) return n.RG;
        if (i === aw) return n.RG_INTEGER;
        if (i === lw) return n.RGBA_INTEGER;
        if (i === bh || i === vp || i === bp || i === xh)
            if (o === Lt)
                if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
                    if (i === bh) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (i === vp) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (i === bp) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (i === xh) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else return null;
            else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
                if (i === bh) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (i === vp) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (i === bp) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (i === xh) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else return null;
        if (i === gg || i === H_ || i === Ag || i === V_)
            if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
                if (i === gg) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (i === H_) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (i === Ag) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (i === V_) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else return null;
        if (i === i0) return r = e.get("WEBGL_compressed_texture_etc1"), r !== null ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (i === _g || i === vg)
            if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
                if (i === _g) return o === Lt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                if (i === vg) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
            } else return null;
        if (i === bg || i === W_ || i === q_ || i === $_ || i === tf || i === j_ || i === Y_ || i === X_ || i === K_ || i === J_ || i === Z_ || i === ev || i === tv || i === iv)
            if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
                if (i === bg) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (i === W_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (i === q_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (i === $_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (i === tf) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (i === j_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (i === Y_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (i === X_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (i === K_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (i === J_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (i === Z_) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (i === ev) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (i === tv) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (i === iv) return o === Lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else return null;
        if (i === yh || i === nv || i === sv)
            if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
                if (i === yh) return o === Lt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (i === nv) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (i === sv) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else return null;
        if (i === BR || i === rv || i === ov || i === av)
            if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
                if (i === yh) return r.COMPRESSED_RED_RGTC1_EXT;
                if (i === rv) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (i === ov) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (i === av) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else return null;
        return i === Hu ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null
    }
    return {
        convert: t
    }
}
class oF extends cn {
    constructor(e = []) {
        super(), this.isArrayCamera = !0, this.cameras = e
    }
}
class Hn extends Ft {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
}
const aF = {
    type: "move"
};
class qp {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Hn, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Hn, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new z, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new z), this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Hn, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new z, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new z), this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values()) this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }), this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }
    update(e, t, i) {
        let s = null,
            r = null,
            o = null;
        const a = this._targetRay,
            l = this._grip,
            c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const g of e.hand.values()) {
                    const A = t.getJointPose(g, i),
                        p = this._getHandJoint(c, g);
                    A !== null && (p.matrix.fromArray(A.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = A.radius), p.visible = A !== null
                }
                const u = c.joints["index-finger-tip"],
                    d = c.joints["thumb-tip"],
                    h = u.position.distanceTo(d.position),
                    f = .02,
                    m = .005;
                c.inputState.pinching && h > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && h <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (s = t.getPose(e.targetRaySpace, i), s === null && r !== null && (s = r), s !== null && (a.matrix.fromArray(s.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(s.linearVelocity)) : a.hasLinearVelocity = !1, s.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(s.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(aF)))
        }
        return a !== null && (a.visible = s !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new Hn;
            i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i)
        }
        return e.joints[t.jointName]
    }
}
const lF = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
    cF = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class uF {
    constructor() {
        this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
    }
    init(e, t, i) {
        if (this.texture === null) {
            const s = new oi,
                r = e.properties.get(s);
            r.__webglTexture = t.texture, (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = s
        }
    }
    render(e, t) {
        if (this.texture !== null) {
            if (this.mesh === null) {
                const i = t.cameras[0].viewport,
                    s = new ti({
                        vertexShader: lF,
                        fragmentShader: cF,
                        uniforms: {
                            depthColor: {
                                value: this.texture
                            },
                            depthWidth: {
                                value: i.z
                            },
                            depthHeight: {
                                value: i.w
                            }
                        }
                    });
                this.mesh = new Ri(new $u(20, 20), s)
            }
            e.render(this.mesh, t)
        }
    }
    reset() {
        this.texture = null, this.mesh = null
    }
}
class dF extends Io {
    constructor(e, t) {
        super();
        const i = this;
        let s = null,
            r = 1,
            o = null,
            a = "local-floor",
            l = 1,
            c = null,
            u = null,
            d = null,
            h = null,
            f = null,
            m = null;
        const g = new uF,
            A = t.getContextAttributes();
        let p = null,
            v = null;
        const _ = [],
            b = [],
            w = new _e;
        let E = null;
        const C = new cn;
        C.layers.enable(1), C.viewport = new Rt;
        const S = new cn;
        S.layers.enable(2), S.viewport = new Rt;
        const x = [C, S],
            y = new oF;
        y.layers.enable(1), y.layers.enable(2);
        let P = null,
            T = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (K) {
            let te = _[K];
            return te === void 0 && (te = new qp, _[K] = te), te.getTargetRaySpace()
        }, this.getControllerGrip = function (K) {
            let te = _[K];
            return te === void 0 && (te = new qp, _[K] = te), te.getGripSpace()
        }, this.getHand = function (K) {
            let te = _[K];
            return te === void 0 && (te = new qp, _[K] = te), te.getHandSpace()
        };

        function R(K) {
            const te = b.indexOf(K.inputSource);
            if (te === -1) return;
            const ue = _[te];
            ue !== void 0 && (ue.update(K.inputSource, K.frame, c || o), ue.dispatchEvent({
                type: K.type,
                data: K.inputSource
            }))
        }

        function D() {
            s.removeEventListener("select", R), s.removeEventListener("selectstart", R), s.removeEventListener("selectend", R), s.removeEventListener("squeeze", R), s.removeEventListener("squeezestart", R), s.removeEventListener("squeezeend", R), s.removeEventListener("end", D), s.removeEventListener("inputsourceschange", U);
            for (let K = 0; K < _.length; K++) {
                const te = b[K];
                te !== null && (b[K] = null, _[K].disconnect(te))
            }
            P = null, T = null, g.reset(), e.setRenderTarget(p), f = null, h = null, d = null, s = null, v = null, le.stop(), i.isPresenting = !1, e.setPixelRatio(E), e.setSize(w.width, w.height, !1), i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function (K) {
            r = K, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function (K) {
            a = K, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function () {
            return c || o
        }, this.setReferenceSpace = function (K) {
            c = K
        }, this.getBaseLayer = function () {
            return h !== null ? h : f
        }, this.getBinding = function () {
            return d
        }, this.getFrame = function () {
            return m
        }, this.getSession = function () {
            return s
        }, this.setSession = async function (K) {
            if (s = K, s !== null) {
                if (p = e.getRenderTarget(), s.addEventListener("select", R), s.addEventListener("selectstart", R), s.addEventListener("selectend", R), s.addEventListener("squeeze", R), s.addEventListener("squeezestart", R), s.addEventListener("squeezeend", R), s.addEventListener("end", D), s.addEventListener("inputsourceschange", U), A.xrCompatible !== !0 && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(w), s.renderState.layers === void 0) {
                    const te = {
                        antialias: A.antialias,
                        alpha: !0,
                        depth: A.depth,
                        stencil: A.stencil,
                        framebufferScaleFactor: r
                    };
                    f = new XRWebGLLayer(s, t, te), s.updateRenderState({
                        baseLayer: f
                    }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), v = new mn(f.framebufferWidth, f.framebufferHeight, {
                        format: Jt,
                        type: hi,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: A.stencil
                    })
                } else {
                    let te = null,
                        ue = null,
                        fe = null;
                    A.depth && (fe = A.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, te = A.stencil ? Cu : Il, ue = A.stencil ? Hu : Hl);
                    const Me = {
                        colorFormat: t.RGBA8,
                        depthFormat: fe,
                        scaleFactor: r
                    };
                    d = new XRWebGLBinding(s, t), h = d.createProjectionLayer(Me), s.updateRenderState({
                        layers: [h]
                    }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), v = new mn(h.textureWidth, h.textureHeight, {
                        format: Jt,
                        type: hi,
                        depthTexture: new u0(h.textureWidth, h.textureHeight, ue, void 0, void 0, void 0, void 0, void 0, void 0, te),
                        stencilBuffer: A.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: A.antialias ? 4 : 0
                    });
                    const Be = e.properties.get(v);
                    Be.__ignoreDepthValues = h.ignoreDepthValues
                }
                v.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await s.requestReferenceSpace(a), le.setContext(s), le.start(), i.isPresenting = !0, i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }, this.getEnvironmentBlendMode = function () {
            if (s !== null) return s.environmentBlendMode
        };

        function U(K) {
            for (let te = 0; te < K.removed.length; te++) {
                const ue = K.removed[te],
                    fe = b.indexOf(ue);
                fe >= 0 && (b[fe] = null, _[fe].disconnect(ue))
            }
            for (let te = 0; te < K.added.length; te++) {
                const ue = K.added[te];
                let fe = b.indexOf(ue);
                if (fe === -1) {
                    for (let Be = 0; Be < _.length; Be++)
                        if (Be >= b.length) {
                            b.push(ue), fe = Be;
                            break
                        } else if (b[Be] === null) {
                            b[Be] = ue, fe = Be;
                            break
                        }
                    if (fe === -1) break
                }
                const Me = _[fe];
                Me && Me.connect(ue)
            }
        }
        const Q = new z,
            F = new z;

        function L(K, te, ue) {
            Q.setFromMatrixPosition(te.matrixWorld), F.setFromMatrixPosition(ue.matrixWorld);
            const fe = Q.distanceTo(F),
                Me = te.projectionMatrix.elements,
                Be = ue.projectionMatrix.elements,
                Ce = Me[14] / (Me[10] - 1),
                Z = Me[14] / (Me[10] + 1),
                ke = (Me[9] + 1) / Me[5],
                N = (Me[9] - 1) / Me[5],
                G = (Me[8] - 1) / Me[0],
                Y = (Be[8] + 1) / Be[0],
                se = Ce * G,
                M = Ce * Y,
                I = fe / (-G + Y),
                H = I * -G;
            te.matrixWorld.decompose(K.position, K.quaternion, K.scale), K.translateX(H), K.translateZ(I), K.matrixWorld.compose(K.position, K.quaternion, K.scale), K.matrixWorldInverse.copy(K.matrixWorld).invert();
            const V = Ce + I,
                j = Z + I,
                q = se - H,
                he = M + (fe - H),
                re = ke * Z / j * V,
                de = N * Z / j * V;
            K.projectionMatrix.makePerspective(q, he, re, de, V, j), K.projectionMatrixInverse.copy(K.projectionMatrix).invert()
        }

        function W(K, te) {
            te === null ? K.matrixWorld.copy(K.matrix) : K.matrixWorld.multiplyMatrices(te.matrixWorld, K.matrix), K.matrixWorldInverse.copy(K.matrixWorld).invert()
        }
        this.updateCamera = function (K) {
            if (s === null) return;
            g.texture !== null && (K.near = g.depthNear, K.far = g.depthFar), y.near = S.near = C.near = K.near, y.far = S.far = C.far = K.far, (P !== y.near || T !== y.far) && (s.updateRenderState({
                depthNear: y.near,
                depthFar: y.far
            }), P = y.near, T = y.far, C.near = P, C.far = T, S.near = P, S.far = T, C.updateProjectionMatrix(), S.updateProjectionMatrix(), K.updateProjectionMatrix());
            const te = K.parent,
                ue = y.cameras;
            W(y, te);
            for (let fe = 0; fe < ue.length; fe++) W(ue[fe], te);
            ue.length === 2 ? L(y, C, S) : y.projectionMatrix.copy(C.projectionMatrix), k(K, y, te)
        };

        function k(K, te, ue) {
            ue === null ? K.matrix.copy(te.matrixWorld) : (K.matrix.copy(ue.matrixWorld), K.matrix.invert(), K.matrix.multiply(te.matrixWorld)), K.matrix.decompose(K.position, K.quaternion, K.scale), K.updateMatrixWorld(!0), K.projectionMatrix.copy(te.projectionMatrix), K.projectionMatrixInverse.copy(te.projectionMatrixInverse), K.isPerspectiveCamera && (K.fov = Wl * 2 * Math.atan(1 / K.projectionMatrix.elements[5]), K.zoom = 1)
        }
        this.getCamera = function () {
            return y
        }, this.getFoveation = function () {
            if (!(h === null && f === null)) return l
        }, this.setFoveation = function (K) {
            l = K, h !== null && (h.fixedFoveation = K), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = K)
        }, this.hasDepthSensing = function () {
            return g.texture !== null
        };
        let $ = null;

        function X(K, te) {
            if (u = te.getViewerPose(c || o), m = te, u !== null) {
                const ue = u.views;
                f !== null && (e.setRenderTargetFramebuffer(v, f.framebuffer), e.setRenderTarget(v));
                let fe = !1;
                ue.length !== y.cameras.length && (y.cameras.length = 0, fe = !0);
                for (let Be = 0; Be < ue.length; Be++) {
                    const Ce = ue[Be];
                    let Z = null;
                    if (f !== null) Z = f.getViewport(Ce);
                    else {
                        const N = d.getViewSubImage(h, Ce);
                        Z = N.viewport, Be === 0 && (e.setRenderTargetTextures(v, N.colorTexture, h.ignoreDepthValues ? void 0 : N.depthStencilTexture), e.setRenderTarget(v))
                    }
                    let ke = x[Be];
                    ke === void 0 && (ke = new cn, ke.layers.enable(Be), ke.viewport = new Rt, x[Be] = ke), ke.matrix.fromArray(Ce.transform.matrix), ke.matrix.decompose(ke.position, ke.quaternion, ke.scale), ke.projectionMatrix.fromArray(Ce.projectionMatrix), ke.projectionMatrixInverse.copy(ke.projectionMatrix).invert(), ke.viewport.set(Z.x, Z.y, Z.width, Z.height), Be === 0 && (y.matrix.copy(ke.matrix), y.matrix.decompose(y.position, y.quaternion, y.scale)), fe === !0 && y.cameras.push(ke)
                }
                const Me = s.enabledFeatures;
                if (Me && Me.includes("depth-sensing")) {
                    const Be = d.getDepthInformation(ue[0]);
                    Be && Be.isValid && Be.texture && g.init(e, Be, s.renderState)
                }
            }
            for (let ue = 0; ue < _.length; ue++) {
                const fe = b[ue],
                    Me = _[ue];
                fe !== null && Me !== void 0 && Me.update(fe, te, c || o)
            }
            g.render(e, y), $ && $(K, te), te.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: te
            }), m = null
        }
        const le = new xw;
        le.setAnimationLoop(X), this.setAnimationLoop = function (K) {
            $ = K
        }, this.dispose = function () { }
    }
}
const Wo = new Cs,
    hF = new Xe;

function fF(n, e) {
    function t(A, p) {
        A.matrixAutoUpdate === !0 && A.updateMatrix(), p.value.copy(A.matrix)
    }

    function i(A, p) {
        p.color.getRGB(A.fogColor.value, bw(n)), p.isFog ? (A.fogNear.value = p.near, A.fogFar.value = p.far) : p.isFogExp2 && (A.fogDensity.value = p.density)
    }

    function s(A, p, v, _, b) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? r(A, p) : p.isMeshToonMaterial ? (r(A, p), d(A, p)) : p.isMeshPhongMaterial ? (r(A, p), u(A, p)) : p.isMeshStandardMaterial ? (r(A, p), h(A, p), p.isMeshPhysicalMaterial && f(A, p, b)) : p.isMeshMatcapMaterial ? (r(A, p), m(A, p)) : p.isMeshDepthMaterial ? r(A, p) : p.isMeshDistanceMaterial ? (r(A, p), g(A, p)) : p.isMeshNormalMaterial ? r(A, p) : p.isLineBasicMaterial ? (o(A, p), p.isLineDashedMaterial && a(A, p)) : p.isPointsMaterial ? l(A, p, v, _) : p.isSpriteMaterial ? c(A, p) : p.isShadowMaterial ? (A.color.value.copy(p.color), A.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }

    function r(A, p) {
        A.opacity.value = p.opacity, p.color && A.diffuse.value.copy(p.color), p.emissive && A.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (A.map.value = p.map, t(p.map, A.mapTransform)), p.alphaMap && (A.alphaMap.value = p.alphaMap, t(p.alphaMap, A.alphaMapTransform)), p.bumpMap && (A.bumpMap.value = p.bumpMap, t(p.bumpMap, A.bumpMapTransform), A.bumpScale.value = p.bumpScale, p.side === Mn && (A.bumpScale.value *= -1)), p.normalMap && (A.normalMap.value = p.normalMap, t(p.normalMap, A.normalMapTransform), A.normalScale.value.copy(p.normalScale), p.side === Mn && A.normalScale.value.negate()), p.displacementMap && (A.displacementMap.value = p.displacementMap, t(p.displacementMap, A.displacementMapTransform), A.displacementScale.value = p.displacementScale, A.displacementBias.value = p.displacementBias), p.emissiveMap && (A.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, A.emissiveMapTransform)), p.specularMap && (A.specularMap.value = p.specularMap, t(p.specularMap, A.specularMapTransform)), p.alphaTest > 0 && (A.alphaTest.value = p.alphaTest);
        const v = e.get(p),
            _ = v.envMap,
            b = v.envMapRotation;
        if (_ && (A.envMap.value = _, Wo.copy(b), Wo.x *= -1, Wo.y *= -1, Wo.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (Wo.y *= -1, Wo.z *= -1), A.envMapRotation.value.setFromMatrix4(hF.makeRotationFromEuler(Wo)), A.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, A.reflectivity.value = p.reflectivity, A.ior.value = p.ior, A.refractionRatio.value = p.refractionRatio), p.lightMap) {
            A.lightMap.value = p.lightMap;
            const w = n._useLegacyLights === !0 ? Math.PI : 1;
            A.lightMapIntensity.value = p.lightMapIntensity * w, t(p.lightMap, A.lightMapTransform)
        }
        p.aoMap && (A.aoMap.value = p.aoMap, A.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, A.aoMapTransform))
    }

    function o(A, p) {
        A.diffuse.value.copy(p.color), A.opacity.value = p.opacity, p.map && (A.map.value = p.map, t(p.map, A.mapTransform))
    }

    function a(A, p) {
        A.dashSize.value = p.dashSize, A.totalSize.value = p.dashSize + p.gapSize, A.scale.value = p.scale
    }

    function l(A, p, v, _) {
        A.diffuse.value.copy(p.color), A.opacity.value = p.opacity, A.size.value = p.size * v, A.scale.value = _ * .5, p.map && (A.map.value = p.map, t(p.map, A.uvTransform)), p.alphaMap && (A.alphaMap.value = p.alphaMap, t(p.alphaMap, A.alphaMapTransform)), p.alphaTest > 0 && (A.alphaTest.value = p.alphaTest)
    }

    function c(A, p) {
        A.diffuse.value.copy(p.color), A.opacity.value = p.opacity, A.rotation.value = p.rotation, p.map && (A.map.value = p.map, t(p.map, A.mapTransform)), p.alphaMap && (A.alphaMap.value = p.alphaMap, t(p.alphaMap, A.alphaMapTransform)), p.alphaTest > 0 && (A.alphaTest.value = p.alphaTest)
    }

    function u(A, p) {
        A.specular.value.copy(p.specular), A.shininess.value = Math.max(p.shininess, 1e-4)
    }

    function d(A, p) {
        p.gradientMap && (A.gradientMap.value = p.gradientMap)
    }

    function h(A, p) {
        A.metalness.value = p.metalness, p.metalnessMap && (A.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, A.metalnessMapTransform)), A.roughness.value = p.roughness, p.roughnessMap && (A.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, A.roughnessMapTransform)), p.envMap && (A.envMapIntensity.value = p.envMapIntensity)
    }

    function f(A, p, v) {
        A.ior.value = p.ior, p.sheen > 0 && (A.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), A.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (A.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, A.sheenColorMapTransform)), p.sheenRoughnessMap && (A.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, A.sheenRoughnessMapTransform))), p.clearcoat > 0 && (A.clearcoat.value = p.clearcoat, A.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (A.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, A.clearcoatMapTransform)), p.clearcoatRoughnessMap && (A.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, A.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (A.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, A.clearcoatNormalMapTransform), A.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === Mn && A.clearcoatNormalScale.value.negate())), p.iridescence > 0 && (A.iridescence.value = p.iridescence, A.iridescenceIOR.value = p.iridescenceIOR, A.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], A.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (A.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, A.iridescenceMapTransform)), p.iridescenceThicknessMap && (A.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, A.iridescenceThicknessMapTransform))), p.transmission > 0 && (A.transmission.value = p.transmission, A.transmissionSamplerMap.value = v.texture, A.transmissionSamplerSize.value.set(v.width, v.height), p.transmissionMap && (A.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, A.transmissionMapTransform)), A.thickness.value = p.thickness, p.thicknessMap && (A.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, A.thicknessMapTransform)), A.attenuationDistance.value = p.attenuationDistance, A.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (A.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (A.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, A.anisotropyMapTransform))), A.specularIntensity.value = p.specularIntensity, A.specularColor.value.copy(p.specularColor), p.specularColorMap && (A.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, A.specularColorMapTransform)), p.specularIntensityMap && (A.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, A.specularIntensityMapTransform))
    }

    function m(A, p) {
        p.matcap && (A.matcap.value = p.matcap)
    }

    function g(A, p) {
        const v = e.get(p).light;
        A.referencePosition.value.setFromMatrixPosition(v.matrixWorld), A.nearDistance.value = v.shadow.camera.near, A.farDistance.value = v.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: s
    }
}

function pF(n, e, t, i) {
    let s = {},
        r = {},
        o = [];
    const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);

    function l(v, _) {
        const b = _.program;
        i.uniformBlockBinding(v, b)
    }

    function c(v, _) {
        let b = s[v.id];
        b === void 0 && (m(v), b = u(v), s[v.id] = b, v.addEventListener("dispose", A));
        const w = _.program;
        i.updateUBOMapping(v, w);
        const E = e.render.frame;
        r[v.id] !== E && (h(v), r[v.id] = E)
    }

    function u(v) {
        const _ = d();
        v.__bindingPointIndex = _;
        const b = n.createBuffer(),
            w = v.__size,
            E = v.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, b), n.bufferData(n.UNIFORM_BUFFER, w, E), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, _, b), b
    }

    function d() {
        for (let v = 0; v < a; v++)
            if (o.indexOf(v) === -1) return o.push(v), v;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }

    function h(v) {
        const _ = s[v.id],
            b = v.uniforms,
            w = v.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, _);
        for (let E = 0, C = b.length; E < C; E++) {
            const S = Array.isArray(b[E]) ? b[E] : [b[E]];
            for (let x = 0, y = S.length; x < y; x++) {
                const P = S[x];
                if (f(P, E, x, w) === !0) {
                    const T = P.__offset,
                        R = Array.isArray(P.value) ? P.value : [P.value];
                    let D = 0;
                    for (let U = 0; U < R.length; U++) {
                        const Q = R[U],
                            F = g(Q);
                        typeof Q == "number" || typeof Q == "boolean" ? (P.__data[0] = Q, n.bufferSubData(n.UNIFORM_BUFFER, T + D, P.__data)) : Q.isMatrix3 ? (P.__data[0] = Q.elements[0], P.__data[1] = Q.elements[1], P.__data[2] = Q.elements[2], P.__data[3] = 0, P.__data[4] = Q.elements[3], P.__data[5] = Q.elements[4], P.__data[6] = Q.elements[5], P.__data[7] = 0, P.__data[8] = Q.elements[6], P.__data[9] = Q.elements[7], P.__data[10] = Q.elements[8], P.__data[11] = 0) : (Q.toArray(P.__data, D), D += F.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, T, P.__data)
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }

    function f(v, _, b, w) {
        const E = v.value,
            C = _ + "_" + b;
        if (w[C] === void 0) return typeof E == "number" || typeof E == "boolean" ? w[C] = E : w[C] = E.clone(), !0; {
            const S = w[C];
            if (typeof E == "number" || typeof E == "boolean") {
                if (S !== E) return w[C] = E, !0
            } else if (S.equals(E) === !1) return S.copy(E), !0
        }
        return !1
    }

    function m(v) {
        const _ = v.uniforms;
        let b = 0;
        const w = 16;
        for (let C = 0, S = _.length; C < S; C++) {
            const x = Array.isArray(_[C]) ? _[C] : [_[C]];
            for (let y = 0, P = x.length; y < P; y++) {
                const T = x[y],
                    R = Array.isArray(T.value) ? T.value : [T.value];
                for (let D = 0, U = R.length; D < U; D++) {
                    const Q = R[D],
                        F = g(Q),
                        L = b % w;
                    L !== 0 && w - L < F.boundary && (b += w - L), T.__data = new Float32Array(F.storage / Float32Array.BYTES_PER_ELEMENT), T.__offset = b, b += F.storage
                }
            }
        }
        const E = b % w;
        return E > 0 && (b += w - E), v.__size = b, v.__cache = {}, this
    }

    function g(v) {
        const _ = {
            boundary: 0,
            storage: 0
        };
        return typeof v == "number" || typeof v == "boolean" ? (_.boundary = 4, _.storage = 4) : v.isVector2 ? (_.boundary = 8, _.storage = 8) : v.isVector3 || v.isColor ? (_.boundary = 16, _.storage = 12) : v.isVector4 ? (_.boundary = 16, _.storage = 16) : v.isMatrix3 ? (_.boundary = 48, _.storage = 48) : v.isMatrix4 ? (_.boundary = 64, _.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), _
    }

    function A(v) {
        const _ = v.target;
        _.removeEventListener("dispose", A);
        const b = o.indexOf(_.__bindingPointIndex);
        o.splice(b, 1), n.deleteBuffer(s[_.id]), delete s[_.id], delete r[_.id]
    }

    function p() {
        for (const v in s) n.deleteBuffer(s[v]);
        o = [], s = {}, r = {}
    }
    return {
        bind: l,
        update: c,
        dispose: p
    }
}
class mF {
    constructor(e = {}) {
        const {
            canvas: t = a2(),
            context: i = null,
            depth: s = !0,
            stencil: r = !1,
            alpha: o = !1,
            antialias: a = !1,
            premultipliedAlpha: l = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: u = "default",
            failIfMajorPerformanceCaveat: d = !1
        } = e;
        this.isWebGLRenderer = !0;
        let h;
        if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            h = i.getContextAttributes().alpha
        } else h = o;
        const f = new Uint32Array(4),
            m = new Int32Array(4);
        let g = null,
            A = null;
        const p = [],
            v = [];
        this.domElement = t, this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Wt, this._useLegacyLights = !1, this.toneMapping = _r, this.toneMappingExposure = 1;
        const _ = this;
        let b = !1,
            w = 0,
            E = 0,
            C = null,
            S = -1,
            x = null;
        const y = new Rt,
            P = new Rt;
        let T = null;
        const R = new Ue(0);
        let D = 0,
            U = t.width,
            Q = t.height,
            F = 1,
            L = null,
            W = null;
        const k = new Rt(0, 0, U, Q),
            $ = new Rt(0, 0, U, Q);
        let X = !1;
        const le = new Qf;
        let K = !1,
            te = !1;
        const ue = new Xe,
            fe = new _e,
            Me = new z,
            Be = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };

        function Ce() {
            return C === null ? F : 1
        }
        let Z = i;

        function ke(O, J) {
            const oe = t.getContext(O, J);
            return oe !== null ? oe : null
        }
        try {
            const O = {
                alpha: !0,
                depth: s,
                stencil: r,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${YA}`), t.addEventListener("webglcontextlost", ee, !1), t.addEventListener("webglcontextrestored", pe, !1), t.addEventListener("webglcontextcreationerror", be, !1), Z === null) {
                const J = "webgl2";
                if (Z = ke(J, O), Z === null) throw ke(J) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (O) {
            throw console.error("THREE.WebGLRenderer: " + O.message), O
        }
        let N, G, Y, se, M, I, H, V, j, q, he, re, de, ge, ce, me, xe, ve, we, Pe, Ke, Ve, Le, We;

        function Te() {
            N = new wL(Z), N.init(), G = new _L(Z, N, e), Ve = new rF(Z, N), Y = new nF(Z), se = new ML(Z), M = new Vk, I = new sF(Z, N, Y, M, G, Ve, se), H = new bL(_), V = new EL(_), j = new D2(Z), Le = new gL(Z, j), q = new CL(Z, j, se, Le), he = new IL(Z, q, j, se), we = new TL(Z, G, I), me = new vL(M), re = new Hk(_, H, V, N, G, Le, me), de = new fF(_, M), ge = new qk, ce = new Jk(N), ve = new mL(_, H, V, Y, he, h, l), xe = new iF(_, he, G), We = new pF(Z, se, G, Y), Pe = new AL(Z, N, se), Ke = new SL(Z, N, se), se.programs = re.programs, _.capabilities = G, _.extensions = N, _.properties = M, _.renderLists = ge, _.shadowMap = xe, _.state = Y, _.info = se
        }
        Te();
        const B = new dF(_, Z);
        this.xr = B, this.getContext = function () {
            return Z
        }, this.getContextAttributes = function () {
            return Z.getContextAttributes()
        }, this.forceContextLoss = function () {
            const O = N.get("WEBGL_lose_context");
            O && O.loseContext()
        }, this.forceContextRestore = function () {
            const O = N.get("WEBGL_lose_context");
            O && O.restoreContext()
        }, this.getPixelRatio = function () {
            return F
        }, this.setPixelRatio = function (O) {
            O !== void 0 && (F = O, this.setSize(U, Q, !1))
        }, this.getSize = function (O) {
            return O.set(U, Q)
        }, this.setSize = function (O, J, oe = !0) {
            if (B.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            U = O, Q = J, t.width = Math.floor(O * F), t.height = Math.floor(J * F), oe === !0 && (t.style.width = O + "px", t.style.height = J + "px"), this.setViewport(0, 0, O, J)
        }, this.getDrawingBufferSize = function (O) {
            return O.set(U * F, Q * F).floor()
        }, this.setDrawingBufferSize = function (O, J, oe) {
            U = O, Q = J, F = oe, t.width = Math.floor(O * oe), t.height = Math.floor(J * oe), this.setViewport(0, 0, O, J)
        }, this.getCurrentViewport = function (O) {
            return O.copy(y)
        }, this.getViewport = function (O) {
            return O.copy(k)
        }, this.setViewport = function (O, J, oe, ae) {
            O.isVector4 ? k.set(O.x, O.y, O.z, O.w) : k.set(O, J, oe, ae), Y.viewport(y.copy(k).multiplyScalar(F).round())
        }, this.getScissor = function (O) {
            return O.copy($)
        }, this.setScissor = function (O, J, oe, ae) {
            O.isVector4 ? $.set(O.x, O.y, O.z, O.w) : $.set(O, J, oe, ae), Y.scissor(P.copy($).multiplyScalar(F).round())
        }, this.getScissorTest = function () {
            return X
        }, this.setScissorTest = function (O) {
            Y.setScissorTest(X = O)
        }, this.setOpaqueSort = function (O) {
            L = O
        }, this.setTransparentSort = function (O) {
            W = O
        }, this.getClearColor = function (O) {
            return O.copy(ve.getClearColor())
        }, this.setClearColor = function () {
            ve.setClearColor.apply(ve, arguments)
        }, this.getClearAlpha = function () {
            return ve.getClearAlpha()
        }, this.setClearAlpha = function () {
            ve.setClearAlpha.apply(ve, arguments)
        }, this.clear = function (O = !0, J = !0, oe = !0) {
            let ae = 0;
            if (O) {
                let ne = !1;
                if (C !== null) {
                    const ye = C.texture.format;
                    ne = ye === lw || ye === aw || ye === ow
                }
                if (ne) {
                    const ye = C.texture.type,
                        Re = ye === hi || ye === Hl || ye === iw || ye === Hu || ye === sw || ye === rw,
                        He = ve.getClearColor(),
                        Ye = ve.getClearAlpha(),
                        ze = He.r,
                        Oe = He.g,
                        qe = He.b;
                    Re ? (f[0] = ze, f[1] = Oe, f[2] = qe, f[3] = Ye, Z.clearBufferuiv(Z.COLOR, 0, f)) : (m[0] = ze, m[1] = Oe, m[2] = qe, m[3] = Ye, Z.clearBufferiv(Z.COLOR, 0, m))
                } else ae |= Z.COLOR_BUFFER_BIT
            }
            J && (ae |= Z.DEPTH_BUFFER_BIT), oe && (ae |= Z.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Z.clear(ae)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            t.removeEventListener("webglcontextlost", ee, !1), t.removeEventListener("webglcontextrestored", pe, !1), t.removeEventListener("webglcontextcreationerror", be, !1), ge.dispose(), ce.dispose(), M.dispose(), H.dispose(), V.dispose(), he.dispose(), Le.dispose(), We.dispose(), re.dispose(), B.dispose(), B.removeEventListener("sessionstart", Ne), B.removeEventListener("sessionend", De), it.stop()
        };

        function ee(O) {
            O.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0
        }

        function pe() {
            console.log("THREE.WebGLRenderer: Context Restored."), b = !1;
            const O = se.autoReset,
                J = xe.enabled,
                oe = xe.autoUpdate,
                ae = xe.needsUpdate,
                ne = xe.type;
            Te(), se.autoReset = O, xe.enabled = J, xe.autoUpdate = oe, xe.needsUpdate = ae, xe.type = ne
        }

        function be(O) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", O.statusMessage)
        }

        function Se(O) {
            const J = O.target;
            J.removeEventListener("dispose", Se), et(J)
        }

        function et(O) {
            tt(O), M.remove(O)
        }

        function tt(O) {
            const J = M.get(O).programs;
            J !== void 0 && (J.forEach(function (oe) {
                re.releaseProgram(oe)
            }), O.isShaderMaterial && re.releaseShaderCache(O))
        }
        this.renderBufferDirect = function (O, J, oe, ae, ne, ye) {
            J === null && (J = Be);
            const Re = ne.isMesh && ne.matrixWorld.determinant() < 0,
                He = zt(O, J, oe, ae, ne);
            Y.setMaterial(ae, Re);
            let Ye = oe.index,
                ze = 1;
            if (ae.wireframe === !0) {
                if (Ye = q.getWireframeAttribute(oe), Ye === void 0) return;
                ze = 2
            }
            const Oe = oe.drawRange,
                qe = oe.attributes.position;
            let Nt = Oe.start * ze,
                Hi = (Oe.start + Oe.count) * ze;
            ye !== null && (Nt = Math.max(Nt, ye.start * ze), Hi = Math.min(Hi, (ye.start + ye.count) * ze)), Ye !== null ? (Nt = Math.max(Nt, 0), Hi = Math.min(Hi, Ye.count)) : qe != null && (Nt = Math.max(Nt, 0), Hi = Math.min(Hi, qe.count));
            const Gt = Hi - Nt;
            if (Gt < 0 || Gt === 1 / 0) return;
            Le.setup(ne, ae, He, oe, Ye);
            let li, Ct = Pe;
            if (Ye !== null && (li = j.get(Ye), Ct = Ke, Ct.setIndex(li)), ne.isMesh) ae.wireframe === !0 ? (Y.setLineWidth(ae.wireframeLinewidth * Ce()), Ct.setMode(Z.LINES)) : Ct.setMode(Z.TRIANGLES);
            else if (ne.isLine) {
                let nt = ae.linewidth;
                nt === void 0 && (nt = 1), Y.setLineWidth(nt * Ce()), ne.isLineSegments ? Ct.setMode(Z.LINES) : ne.isLineLoop ? Ct.setMode(Z.LINE_LOOP) : Ct.setMode(Z.LINE_STRIP)
            } else ne.isPoints ? Ct.setMode(Z.POINTS) : ne.isSprite && Ct.setMode(Z.TRIANGLES);
            if (ne.isBatchedMesh) Ct.renderMultiDraw(ne._multiDrawStarts, ne._multiDrawCounts, ne._multiDrawCount);
            else if (ne.isInstancedMesh) Ct.renderInstances(Nt, Gt, ne.count);
            else if (oe.isInstancedBufferGeometry) {
                const nt = oe._maxInstanceCount !== void 0 ? oe._maxInstanceCount : 1 / 0,
                    Ks = Math.min(oe.instanceCount, nt);
                Ct.renderInstances(Nt, Gt, Ks)
            } else Ct.render(Nt, Gt)
        };

        function xt(O, J, oe) {
            O.transparent === !0 && O.side === Fs && O.forceSinglePass === !1 ? (O.side = Mn, O.needsUpdate = !0, rt(O, J, oe), O.side = wr, O.needsUpdate = !0, rt(O, J, oe), O.side = Fs) : rt(O, J, oe)
        }
        this.compile = function (O, J, oe = null) {
            oe === null && (oe = O), A = ce.get(oe), A.init(), v.push(A), oe.traverseVisible(function (ne) {
                ne.isLight && ne.layers.test(J.layers) && (A.pushLight(ne), ne.castShadow && A.pushShadow(ne))
            }), O !== oe && O.traverseVisible(function (ne) {
                ne.isLight && ne.layers.test(J.layers) && (A.pushLight(ne), ne.castShadow && A.pushShadow(ne))
            }), A.setupLights(_._useLegacyLights);
            const ae = new Set;
            return O.traverse(function (ne) {
                const ye = ne.material;
                if (ye)
                    if (Array.isArray(ye))
                        for (let Re = 0; Re < ye.length; Re++) {
                            const He = ye[Re];
                            xt(He, oe, ne), ae.add(He)
                        } else xt(ye, oe, ne), ae.add(ye)
            }), v.pop(), A = null, ae
        }, this.compileAsync = function (O, J, oe = null) {
            const ae = this.compile(O, J, oe);
            return new Promise(ne => {
                function ye() {
                    if (ae.forEach(function (Re) {
                        M.get(Re).currentProgram.isReady() && ae.delete(Re)
                    }), ae.size === 0) {
                        ne(O);
                        return
                    }
                    setTimeout(ye, 10)
                }
                N.get("KHR_parallel_shader_compile") !== null ? ye() : setTimeout(ye, 10)
            })
        };
        let Tt = null;

        function mt(O) {
            Tt && Tt(O)
        }

        function Ne() {
            it.stop()
        }

        function De() {
            it.start()
        }
        const it = new xw;
        it.setAnimationLoop(mt), typeof self < "u" && it.setContext(self), this.setAnimationLoop = function (O) {
            Tt = O, B.setAnimationLoop(O), O === null ? it.stop() : it.start()
        }, B.addEventListener("sessionstart", Ne), B.addEventListener("sessionend", De), this.render = function (O, J) {
            if (J !== void 0 && J.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (b === !0) return;
            O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(), J.parent === null && J.matrixWorldAutoUpdate === !0 && J.updateMatrixWorld(), B.enabled === !0 && B.isPresenting === !0 && (B.cameraAutoUpdate === !0 && B.updateCamera(J), J = B.getCamera()), O.isScene === !0 && O.onBeforeRender(_, O, J, C), A = ce.get(O, v.length), A.init(), v.push(A), ue.multiplyMatrices(J.projectionMatrix, J.matrixWorldInverse), le.setFromProjectionMatrix(ue), te = this.localClippingEnabled, K = me.init(this.clippingPlanes, te), g = ge.get(O, p.length), g.init(), p.push(g), Ee(O, J, 0, _.sortObjects), g.finish(), _.sortObjects === !0 && g.sort(L, W), this.info.render.frame++, K === !0 && me.beginShadows();
            const oe = A.state.shadowsArray;
            if (xe.render(oe, O, J), K === !0 && me.endShadows(), this.info.autoReset === !0 && this.info.reset(), (B.enabled === !1 || B.isPresenting === !1 || B.hasDepthSensing() === !1) && ve.render(g, O), A.setupLights(_._useLegacyLights), J.isArrayCamera) {
                const ae = J.cameras;
                for (let ne = 0, ye = ae.length; ne < ye; ne++) {
                    const Re = ae[ne];
                    $e(g, O, Re, Re.viewport)
                }
            } else $e(g, O, J);
            C !== null && (I.updateMultisampleRenderTarget(C), I.updateRenderTargetMipmap(C)), O.isScene === !0 && O.onAfterRender(_, O, J), Le.resetDefaultState(), S = -1, x = null, v.pop(), v.length > 0 ? A = v[v.length - 1] : A = null, p.pop(), p.length > 0 ? g = p[p.length - 1] : g = null
        };

        function Ee(O, J, oe, ae) {
            if (O.visible === !1) return;
            if (O.layers.test(J.layers)) {
                if (O.isGroup) oe = O.renderOrder;
                else if (O.isLOD) O.autoUpdate === !0 && O.update(J);
                else if (O.isLight) A.pushLight(O), O.castShadow && A.pushShadow(O);
                else if (O.isSprite) {
                    if (!O.frustumCulled || le.intersectsSprite(O)) {
                        ae && Me.setFromMatrixPosition(O.matrixWorld).applyMatrix4(ue);
                        const Re = he.update(O),
                            He = O.material;
                        He.visible && g.push(O, Re, He, oe, Me.z, null)
                    }
                } else if ((O.isMesh || O.isLine || O.isPoints) && (!O.frustumCulled || le.intersectsObject(O))) {
                    const Re = he.update(O),
                        He = O.material;
                    if (ae && (O.boundingSphere !== void 0 ? (O.boundingSphere === null && O.computeBoundingSphere(), Me.copy(O.boundingSphere.center)) : (Re.boundingSphere === null && Re.computeBoundingSphere(), Me.copy(Re.boundingSphere.center)), Me.applyMatrix4(O.matrixWorld).applyMatrix4(ue)), Array.isArray(He)) {
                        const Ye = Re.groups;
                        for (let ze = 0, Oe = Ye.length; ze < Oe; ze++) {
                            const qe = Ye[ze],
                                Nt = He[qe.materialIndex];
                            Nt && Nt.visible && g.push(O, Re, Nt, oe, Me.z, qe)
                        }
                    } else He.visible && g.push(O, Re, He, oe, Me.z, null)
                }
            }
            const ye = O.children;
            for (let Re = 0, He = ye.length; Re < He; Re++) Ee(ye[Re], J, oe, ae)
        }

        function $e(O, J, oe, ae) {
            const ne = O.opaque,
                ye = O.transmissive,
                Re = O.transparent;
            A.setupLightsView(oe), K === !0 && me.setGlobalState(_.clippingPlanes, oe), ye.length > 0 && Qe(ne, ye, J, oe), ae && Y.viewport(y.copy(ae)), ne.length > 0 && je(ne, J, oe), ye.length > 0 && je(ye, J, oe), Re.length > 0 && je(Re, J, oe), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1)
        }

        function Qe(O, J, oe, ae) {
            if ((oe.isScene === !0 ? oe.overrideMaterial : null) !== null) return;
            if (A.state.transmissionRenderTarget === null) {
                A.state.transmissionRenderTarget = new mn(1, 1, {
                    generateMipmaps: !0,
                    type: N.has("EXT_color_buffer_half_float") || N.has("EXT_color_buffer_float") ? yi : hi,
                    minFilter: ys,
                    samples: 4,
                    stencilBuffer: r
                });
                const ze = M.get(A.state.transmissionRenderTarget);
                ze.__isTransmissionRenderTarget = !0
            }
            const ye = A.state.transmissionRenderTarget;
            _.getDrawingBufferSize(fe), ye.setSize(fe.x, fe.y);
            const Re = _.getRenderTarget();
            _.setRenderTarget(ye), _.getClearColor(R), D = _.getClearAlpha(), D < 1 && _.setClearColor(16777215, .5), _.clear();
            const He = _.toneMapping;
            _.toneMapping = _r, je(O, oe, ae), I.updateMultisampleRenderTarget(ye), I.updateRenderTargetMipmap(ye);
            let Ye = !1;
            for (let ze = 0, Oe = J.length; ze < Oe; ze++) {
                const qe = J[ze],
                    Nt = qe.object,
                    Hi = qe.geometry,
                    Gt = qe.material,
                    li = qe.group;
                if (Gt.side === Fs && Nt.layers.test(ae.layers)) {
                    const Ct = Gt.side;
                    Gt.side = Mn, Gt.needsUpdate = !0, ni(Nt, oe, ae, Hi, Gt, li), Gt.side = Ct, Gt.needsUpdate = !0, Ye = !0
                }
            }
            Ye === !0 && (I.updateMultisampleRenderTarget(ye), I.updateRenderTargetMipmap(ye)), _.setRenderTarget(Re), _.setClearColor(R, D), _.toneMapping = He
        }

        function je(O, J, oe) {
            const ae = J.isScene === !0 ? J.overrideMaterial : null;
            for (let ne = 0, ye = O.length; ne < ye; ne++) {
                const Re = O[ne],
                    He = Re.object,
                    Ye = Re.geometry,
                    ze = ae === null ? Re.material : ae,
                    Oe = Re.group;
                He.layers.test(oe.layers) && ni(He, J, oe, Ye, ze, Oe)
            }
        }

        function ni(O, J, oe, ae, ne, ye) {
            O.onBeforeRender(_, J, oe, ae, ne, ye), O.modelViewMatrix.multiplyMatrices(oe.matrixWorldInverse, O.matrixWorld), O.normalMatrix.getNormalMatrix(O.modelViewMatrix), ne.onBeforeRender(_, J, oe, ae, O, ye), ne.transparent === !0 && ne.side === Fs && ne.forceSinglePass === !1 ? (ne.side = Mn, ne.needsUpdate = !0, _.renderBufferDirect(oe, J, ae, ne, O, ye), ne.side = wr, ne.needsUpdate = !0, _.renderBufferDirect(oe, J, ae, ne, O, ye), ne.side = Fs) : _.renderBufferDirect(oe, J, ae, ne, O, ye), O.onAfterRender(_, J, oe, ae, ne, ye)
        }

        function rt(O, J, oe) {
            J.isScene !== !0 && (J = Be);
            const ae = M.get(O),
                ne = A.state.lights,
                ye = A.state.shadowsArray,
                Re = ne.state.version,
                He = re.getParameters(O, ne.state, ye, J, oe),
                Ye = re.getProgramCacheKey(He);
            let ze = ae.programs;
            ae.environment = O.isMeshStandardMaterial ? J.environment : null, ae.fog = J.fog, ae.envMap = (O.isMeshStandardMaterial ? V : H).get(O.envMap || ae.environment), ae.envMapRotation = ae.environment !== null && O.envMap === null ? J.environmentRotation : O.envMapRotation, ze === void 0 && (O.addEventListener("dispose", Se), ze = new Map, ae.programs = ze);
            let Oe = ze.get(Ye);
            if (Oe !== void 0) {
                if (ae.currentProgram === Oe && ae.lightsStateVersion === Re) return Ai(O, He), Oe
            } else He.uniforms = re.getUniforms(O), O.onBuild(oe, He, _), O.onBeforeCompile(He, _), Oe = re.acquireProgram(He, Ye), ze.set(Ye, Oe), ae.uniforms = He.uniforms;
            const qe = ae.uniforms;
            return (!O.isShaderMaterial && !O.isRawShaderMaterial || O.clipping === !0) && (qe.clippingPlanes = me.uniform), Ai(O, He), ae.needsLights = wt(O), ae.lightsStateVersion = Re, ae.needsLights && (qe.ambientLightColor.value = ne.state.ambient, qe.lightProbe.value = ne.state.probe, qe.directionalLights.value = ne.state.directional, qe.directionalLightShadows.value = ne.state.directionalShadow, qe.spotLights.value = ne.state.spot, qe.spotLightShadows.value = ne.state.spotShadow, qe.rectAreaLights.value = ne.state.rectArea, qe.ltc_1.value = ne.state.rectAreaLTC1, qe.ltc_2.value = ne.state.rectAreaLTC2, qe.pointLights.value = ne.state.point, qe.pointLightShadows.value = ne.state.pointShadow, qe.hemisphereLights.value = ne.state.hemi, qe.directionalShadowMap.value = ne.state.directionalShadowMap, qe.directionalShadowMatrix.value = ne.state.directionalShadowMatrix, qe.spotShadowMap.value = ne.state.spotShadowMap, qe.spotLightMatrix.value = ne.state.spotLightMatrix, qe.spotLightMap.value = ne.state.spotLightMap, qe.pointShadowMap.value = ne.state.pointShadowMap, qe.pointShadowMatrix.value = ne.state.pointShadowMatrix), ae.currentProgram = Oe, ae.uniformsList = null, Oe
        }

        function Qt(O) {
            if (O.uniformsList === null) {
                const J = O.currentProgram.getUniforms();
                O.uniformsList = Eh.seqWithValue(J.seq, O.uniforms)
            }
            return O.uniformsList
        }

        function Ai(O, J) {
            const oe = M.get(O);
            oe.outputColorSpace = J.outputColorSpace, oe.batching = J.batching, oe.instancing = J.instancing, oe.instancingColor = J.instancingColor, oe.instancingMorph = J.instancingMorph, oe.skinning = J.skinning, oe.morphTargets = J.morphTargets, oe.morphNormals = J.morphNormals, oe.morphColors = J.morphColors, oe.morphTargetsCount = J.morphTargetsCount, oe.numClippingPlanes = J.numClippingPlanes, oe.numIntersection = J.numClipIntersection, oe.vertexAlphas = J.vertexAlphas, oe.vertexTangents = J.vertexTangents, oe.toneMapping = J.toneMapping
        }

        function zt(O, J, oe, ae, ne) {
            J.isScene !== !0 && (J = Be), I.resetTextureUnits();
            const ye = J.fog,
                Re = ae.isMeshStandardMaterial ? J.environment : null,
                He = C === null ? _.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : gi,
                Ye = (ae.isMeshStandardMaterial ? V : H).get(ae.envMap || Re),
                ze = ae.vertexColors === !0 && !!oe.attributes.color && oe.attributes.color.itemSize === 4,
                Oe = !!oe.attributes.tangent && (!!ae.normalMap || ae.anisotropy > 0),
                qe = !!oe.morphAttributes.position,
                Nt = !!oe.morphAttributes.normal,
                Hi = !!oe.morphAttributes.color;
            let Gt = _r;
            ae.toneMapped && (C === null || C.isXRRenderTarget === !0) && (Gt = _.toneMapping);
            const li = oe.morphAttributes.position || oe.morphAttributes.normal || oe.morphAttributes.color,
                Ct = li !== void 0 ? li.length : 0,
                nt = M.get(ae),
                Ks = A.state.lights;
            if (K === !0 && (te === !0 || O !== x)) {
                const jn = O === x && ae.id === S;
                me.setState(ae, O, jn)
            }
            let Ht = !1;
            ae.version === nt.__version ? (nt.needsLights && nt.lightsStateVersion !== Ks.state.version || nt.outputColorSpace !== He || ne.isBatchedMesh && nt.batching === !1 || !ne.isBatchedMesh && nt.batching === !0 || ne.isInstancedMesh && nt.instancing === !1 || !ne.isInstancedMesh && nt.instancing === !0 || ne.isSkinnedMesh && nt.skinning === !1 || !ne.isSkinnedMesh && nt.skinning === !0 || ne.isInstancedMesh && nt.instancingColor === !0 && ne.instanceColor === null || ne.isInstancedMesh && nt.instancingColor === !1 && ne.instanceColor !== null || ne.isInstancedMesh && nt.instancingMorph === !0 && ne.morphTexture === null || ne.isInstancedMesh && nt.instancingMorph === !1 && ne.morphTexture !== null || nt.envMap !== Ye || ae.fog === !0 && nt.fog !== ye || nt.numClippingPlanes !== void 0 && (nt.numClippingPlanes !== me.numPlanes || nt.numIntersection !== me.numIntersection) || nt.vertexAlphas !== ze || nt.vertexTangents !== Oe || nt.morphTargets !== qe || nt.morphNormals !== Nt || nt.morphColors !== Hi || nt.toneMapping !== Gt || nt.morphTargetsCount !== Ct) && (Ht = !0) : (Ht = !0, nt.__version = ae.version);
            let Do = nt.currentProgram;
            Ht === !0 && (Do = rt(ae, J, ne));
            let k0 = !1,
                ac = !1,
                Kf = !1;
            const Vi = Do.getUniforms(),
                Ir = nt.uniforms;
            if (Y.useProgram(Do.program) && (k0 = !0, ac = !0, Kf = !0), ae.id !== S && (S = ae.id, ac = !0), k0 || x !== O) {
                Vi.setValue(Z, "projectionMatrix", O.projectionMatrix), Vi.setValue(Z, "viewMatrix", O.matrixWorldInverse);
                const jn = Vi.map.cameraPosition;
                jn !== void 0 && jn.setValue(Z, Me.setFromMatrixPosition(O.matrixWorld)), G.logarithmicDepthBuffer && Vi.setValue(Z, "logDepthBufFC", 2 / (Math.log(O.far + 1) / Math.LN2)), (ae.isMeshPhongMaterial || ae.isMeshToonMaterial || ae.isMeshLambertMaterial || ae.isMeshBasicMaterial || ae.isMeshStandardMaterial || ae.isShaderMaterial) && Vi.setValue(Z, "isOrthographic", O.isOrthographicCamera === !0), x !== O && (x = O, ac = !0, Kf = !0)
            }
            if (ne.isSkinnedMesh) {
                Vi.setOptional(Z, ne, "bindMatrix"), Vi.setOptional(Z, ne, "bindMatrixInverse");
                const jn = ne.skeleton;
                jn && (jn.boneTexture === null && jn.computeBoneTexture(), Vi.setValue(Z, "boneTexture", jn.boneTexture, I))
            }
            ne.isBatchedMesh && (Vi.setOptional(Z, ne, "batchingTexture"), Vi.setValue(Z, "batchingTexture", ne._matricesTexture, I));
            const Jf = oe.morphAttributes;
            if ((Jf.position !== void 0 || Jf.normal !== void 0 || Jf.color !== void 0) && we.update(ne, oe, Do), (ac || nt.receiveShadow !== ne.receiveShadow) && (nt.receiveShadow = ne.receiveShadow, Vi.setValue(Z, "receiveShadow", ne.receiveShadow)), ae.isMeshGouraudMaterial && ae.envMap !== null && (Ir.envMap.value = Ye, Ir.flipEnvMap.value = Ye.isCubeTexture && Ye.isRenderTargetTexture === !1 ? -1 : 1), ae.isMeshStandardMaterial && ae.envMap === null && J.environment !== null && (Ir.envMapIntensity.value = J.environmentIntensity), ac && (Vi.setValue(Z, "toneMappingExposure", _.toneMappingExposure), nt.needsLights && Dt(Ir, Kf), ye && ae.fog === !0 && de.refreshFogUniforms(Ir, ye), de.refreshMaterialUniforms(Ir, ae, F, Q, A.state.transmissionRenderTarget), Eh.upload(Z, Qt(nt), Ir, I)), ae.isShaderMaterial && ae.uniformsNeedUpdate === !0 && (Eh.upload(Z, Qt(nt), Ir, I), ae.uniformsNeedUpdate = !1), ae.isSpriteMaterial && Vi.setValue(Z, "center", ne.center), Vi.setValue(Z, "modelViewMatrix", ne.modelViewMatrix), Vi.setValue(Z, "normalMatrix", ne.normalMatrix), Vi.setValue(Z, "modelMatrix", ne.matrixWorld), ae.isShaderMaterial || ae.isRawShaderMaterial) {
                const jn = ae.uniformsGroups;
                for (let Zf = 0, TS = jn.length; Zf < TS; Zf++) {
                    const F0 = jn[Zf];
                    We.update(F0, Do), We.bind(F0, Do)
                }
            }
            return Do
        }

        function Dt(O, J) {
            O.ambientLightColor.needsUpdate = J, O.lightProbe.needsUpdate = J, O.directionalLights.needsUpdate = J, O.directionalLightShadows.needsUpdate = J, O.pointLights.needsUpdate = J, O.pointLightShadows.needsUpdate = J, O.spotLights.needsUpdate = J, O.spotLightShadows.needsUpdate = J, O.rectAreaLights.needsUpdate = J, O.hemisphereLights.needsUpdate = J
        }

        function wt(O) {
            return O.isMeshLambertMaterial || O.isMeshToonMaterial || O.isMeshPhongMaterial || O.isMeshStandardMaterial || O.isShadowMaterial || O.isShaderMaterial && O.lights === !0
        }
        this.getActiveCubeFace = function () {
            return w
        }, this.getActiveMipmapLevel = function () {
            return E
        }, this.getRenderTarget = function () {
            return C
        }, this.setRenderTargetTextures = function (O, J, oe) {
            M.get(O.texture).__webglTexture = J, M.get(O.depthTexture).__webglTexture = oe;
            const ae = M.get(O);
            ae.__hasExternalTextures = !0, ae.__autoAllocateDepthBuffer = oe === void 0, ae.__autoAllocateDepthBuffer || N.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ae.__useRenderToTexture = !1)
        }, this.setRenderTargetFramebuffer = function (O, J) {
            const oe = M.get(O);
            oe.__webglFramebuffer = J, oe.__useDefaultFramebuffer = J === void 0
        }, this.setRenderTarget = function (O, J = 0, oe = 0) {
            C = O, w = J, E = oe;
            let ae = !0,
                ne = null,
                ye = !1,
                Re = !1;
            if (O) {
                const Ye = M.get(O);
                Ye.__useDefaultFramebuffer !== void 0 ? (Y.bindFramebuffer(Z.FRAMEBUFFER, null), ae = !1) : Ye.__webglFramebuffer === void 0 ? I.setupRenderTarget(O) : Ye.__hasExternalTextures && I.rebindTextures(O, M.get(O.texture).__webglTexture, M.get(O.depthTexture).__webglTexture);
                const ze = O.texture;
                (ze.isData3DTexture || ze.isDataArrayTexture || ze.isCompressedArrayTexture) && (Re = !0);
                const Oe = M.get(O).__webglFramebuffer;
                O.isWebGLCubeRenderTarget ? (Array.isArray(Oe[J]) ? ne = Oe[J][oe] : ne = Oe[J], ye = !0) : O.samples > 0 && I.useMultisampledRTT(O) === !1 ? ne = M.get(O).__webglMultisampledFramebuffer : Array.isArray(Oe) ? ne = Oe[oe] : ne = Oe, y.copy(O.viewport), P.copy(O.scissor), T = O.scissorTest
            } else y.copy(k).multiplyScalar(F).floor(), P.copy($).multiplyScalar(F).floor(), T = X;
            if (Y.bindFramebuffer(Z.FRAMEBUFFER, ne) && ae && Y.drawBuffers(O, ne), Y.viewport(y), Y.scissor(P), Y.setScissorTest(T), ye) {
                const Ye = M.get(O.texture);
                Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ye.__webglTexture, oe)
            } else if (Re) {
                const Ye = M.get(O.texture),
                    ze = J || 0;
                Z.framebufferTextureLayer(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Ye.__webglTexture, oe || 0, ze)
            }
            S = -1
        }, this.readRenderTargetPixels = function (O, J, oe, ae, ne, ye, Re) {
            if (!(O && O.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let He = M.get(O).__webglFramebuffer;
            if (O.isWebGLCubeRenderTarget && Re !== void 0 && (He = He[Re]), He) {
                Y.bindFramebuffer(Z.FRAMEBUFFER, He);
                try {
                    const Ye = O.texture,
                        ze = Ye.format,
                        Oe = Ye.type;
                    if (ze !== Jt && Ve.convert(ze) !== Z.getParameter(Z.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const qe = Oe === yi && (N.has("EXT_color_buffer_half_float") || N.has("EXT_color_buffer_float"));
                    if (Oe !== hi && Ve.convert(Oe) !== Z.getParameter(Z.IMPLEMENTATION_COLOR_READ_TYPE) && Oe !== ei && !qe) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    J >= 0 && J <= O.width - ae && oe >= 0 && oe <= O.height - ne && Z.readPixels(J, oe, ae, ne, Ve.convert(ze), Ve.convert(Oe), ye)
                } finally {
                    const Ye = C !== null ? M.get(C).__webglFramebuffer : null;
                    Y.bindFramebuffer(Z.FRAMEBUFFER, Ye)
                }
            }
        }, this.copyFramebufferToTexture = function (O, J, oe = 0) {
            const ae = Math.pow(2, -oe),
                ne = Math.floor(J.image.width * ae),
                ye = Math.floor(J.image.height * ae);
            I.setTexture2D(J, 0), Z.copyTexSubImage2D(Z.TEXTURE_2D, oe, 0, 0, O.x, O.y, ne, ye), Y.unbindTexture()
        }, this.copyTextureToTexture = function (O, J, oe, ae = 0) {
            const ne = J.image.width,
                ye = J.image.height,
                Re = Ve.convert(oe.format),
                He = Ve.convert(oe.type);
            I.setTexture2D(oe, 0), Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, oe.flipY), Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, oe.premultiplyAlpha), Z.pixelStorei(Z.UNPACK_ALIGNMENT, oe.unpackAlignment), J.isDataTexture ? Z.texSubImage2D(Z.TEXTURE_2D, ae, O.x, O.y, ne, ye, Re, He, J.image.data) : J.isCompressedTexture ? Z.compressedTexSubImage2D(Z.TEXTURE_2D, ae, O.x, O.y, J.mipmaps[0].width, J.mipmaps[0].height, Re, J.mipmaps[0].data) : Z.texSubImage2D(Z.TEXTURE_2D, ae, O.x, O.y, Re, He, J.image), ae === 0 && oe.generateMipmaps && Z.generateMipmap(Z.TEXTURE_2D), Y.unbindTexture()
        }, this.copyTextureToTexture3D = function (O, J, oe, ae, ne = 0) {
            const ye = Math.round(O.max.x - O.min.x),
                Re = Math.round(O.max.y - O.min.y),
                He = O.max.z - O.min.z + 1,
                Ye = Ve.convert(ae.format),
                ze = Ve.convert(ae.type);
            let Oe;
            if (ae.isData3DTexture) I.setTexture3D(ae, 0), Oe = Z.TEXTURE_3D;
            else if (ae.isDataArrayTexture || ae.isCompressedArrayTexture) I.setTexture2DArray(ae, 0), Oe = Z.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, ae.flipY), Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ae.premultiplyAlpha), Z.pixelStorei(Z.UNPACK_ALIGNMENT, ae.unpackAlignment);
            const qe = Z.getParameter(Z.UNPACK_ROW_LENGTH),
                Nt = Z.getParameter(Z.UNPACK_IMAGE_HEIGHT),
                Hi = Z.getParameter(Z.UNPACK_SKIP_PIXELS),
                Gt = Z.getParameter(Z.UNPACK_SKIP_ROWS),
                li = Z.getParameter(Z.UNPACK_SKIP_IMAGES),
                Ct = oe.isCompressedTexture ? oe.mipmaps[ne] : oe.image;
            Z.pixelStorei(Z.UNPACK_ROW_LENGTH, Ct.width), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Ct.height), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, O.min.x), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, O.min.y), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, O.min.z), oe.isDataTexture || oe.isData3DTexture ? Z.texSubImage3D(Oe, ne, J.x, J.y, J.z, ye, Re, He, Ye, ze, Ct.data) : ae.isCompressedArrayTexture ? Z.compressedTexSubImage3D(Oe, ne, J.x, J.y, J.z, ye, Re, He, Ye, Ct.data) : Z.texSubImage3D(Oe, ne, J.x, J.y, J.z, ye, Re, He, Ye, ze, Ct), Z.pixelStorei(Z.UNPACK_ROW_LENGTH, qe), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Nt), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, Hi), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, Gt), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, li), ne === 0 && ae.generateMipmaps && Z.generateMipmap(Oe), Y.unbindTexture()
        }, this.initTexture = function (O) {
            O.isCubeTexture ? I.setTextureCube(O, 0) : O.isData3DTexture ? I.setTexture3D(O, 0) : O.isDataArrayTexture || O.isCompressedArrayTexture ? I.setTexture2DArray(O, 0) : I.setTexture2D(O, 0), Y.unbindTexture()
        }, this.resetState = function () {
            w = 0, E = 0, C = null, Y.reset(), Le.reset()
        }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    get coordinateSystem() {
        return fr
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === Uf ? "display-p3" : "srgb", t.unpackColorSpace = vt.workingColorSpace === Vu ? "display-p3" : "srgb"
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
    }
    set useLegacyLights(e) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
    }
}
class d0 extends Ft {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Cs, this.environmentIntensity = 1, this.environmentRotation = new Cs, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
    }
}
class h0 {
    constructor(e, t) {
        this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = yg, this._updateRange = {
            offset: 0,
            count: -1
        }, this.updateRanges = [], this.version = 0, this.uuid = us()
    }
    onUploadCallback() { }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return fw("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(e) {
        return this.usage = e, this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
    }
    copyAt(e, t, i) {
        e *= this.stride, i *= t.stride;
        for (let s = 0, r = this.stride; s < r; s++) this.array[e + s] = t.array[i + s];
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = us()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            i = new this.constructor(t, this.stride);
        return i.setUsage(this.usage), i
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = us()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const Zi = new z;
class $l {
    constructor(e, t, i, s = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = s
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++) Zi.fromBufferAttribute(this, t), Zi.applyMatrix4(e), this.setXYZ(t, Zi.x, Zi.y, Zi.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) Zi.fromBufferAttribute(this, t), Zi.applyNormalMatrix(e), this.setXYZ(t, Zi.x, Zi.y, Zi.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) Zi.fromBufferAttribute(this, t), Zi.transformDirection(e), this.setXYZ(t, Zi.x, Zi.y, Zi.z);
        return this
    }
    getComponent(e, t) {
        let i = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (i = vs(i, this.array)), i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = St(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this
    }
    setX(e, t) {
        return this.normalized && (t = St(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
    }
    setY(e, t) {
        return this.normalized && (t = St(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
    }
    setZ(e, t) {
        return this.normalized && (t = St(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
    }
    setW(e, t) {
        return this.normalized && (t = St(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = vs(t, this.array)), t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = vs(t, this.array)), t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = vs(t, this.array)), t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = vs(t, this.array)), t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = St(t, this.array), i = St(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
    }
    setXYZ(e, t, i, s) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = St(t, this.array), i = St(i, this.array), s = St(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = s, this
    }
    setXYZW(e, t, i, s, r) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = St(t, this.array), i = St(i, this.array), s = St(s, this.array), r = St(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = s, this.data.array[e + 3] = r, this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const s = i * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r])
            }
            return new pi(new this.array.constructor(t), this.itemSize, this.normalized)
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new $l(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const s = i * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
class Tw extends In {
    constructor(e) {
        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Ue(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
let Za;
const pc = new z,
    el = new z,
    tl = new z,
    il = new _e,
    mc = new _e,
    Iw = new Xe,
    Bd = new z,
    gc = new z,
    Rd = new z,
    Jv = new _e,
    $p = new _e,
    Zv = new _e;
class gF extends Ft {
    constructor(e = new Tw) {
        if (super(), this.isSprite = !0, this.type = "Sprite", Za === void 0) {
            Za = new Gi;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                i = new h0(t, 5);
            Za.setIndex([0, 1, 2, 0, 2, 3]), Za.setAttribute("position", new $l(i, 3, 0, !1)), Za.setAttribute("uv", new $l(i, 2, 3, !1))
        }
        this.geometry = Za, this.material = e, this.center = new _e(.5, .5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), el.setFromMatrixScale(this.matrixWorld), Iw.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), tl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && el.multiplyScalar(-tl.z);
        const i = this.material.rotation;
        let s, r;
        i !== 0 && (r = Math.cos(i), s = Math.sin(i));
        const o = this.center;
        Pd(Bd.set(-.5, -.5, 0), tl, o, el, s, r), Pd(gc.set(.5, -.5, 0), tl, o, el, s, r), Pd(Rd.set(.5, .5, 0), tl, o, el, s, r), Jv.set(0, 0), $p.set(1, 0), Zv.set(1, 1);
        let a = e.ray.intersectTriangle(Bd, gc, Rd, !1, pc);
        if (a === null && (Pd(gc.set(-.5, .5, 0), tl, o, el, s, r), $p.set(0, 1), a = e.ray.intersectTriangle(Bd, Rd, gc, !1, pc), a === null)) return;
        const l = e.ray.origin.distanceTo(pc);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: pc.clone(),
            uv: bs.getInterpolation(pc, Bd, gc, Rd, Jv, $p, Zv, new _e),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
    }
}

function Pd(n, e, t, i, s, r) {
    il.subVectors(n, t).addScalar(.5).multiply(i), s !== void 0 ? (mc.x = r * il.x - s * il.y, mc.y = s * il.x + r * il.y) : mc.copy(il), n.copy(e), n.x += mc.x, n.y += mc.y, n.applyMatrix4(Iw)
}
const eb = new z,
    tb = new Rt,
    ib = new Rt,
    AF = new z,
    nb = new Xe,
    Dd = new z,
    jp = new js,
    sb = new Xe,
    Yp = new Wu;
class _F extends Ri {
    constructor(e, t) {
        super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = G_, this.bindMatrix = new Xe, this.bindMatrixInverse = new Xe, this.boundingBox = null, this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Sr), this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Dd), this.boundingBox.expandByPoint(Dd)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new js), this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Dd), this.boundingSphere.expandByPoint(Dd)
    }
    copy(e, t) {
        return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    raycast(e, t) {
        const i = this.material,
            s = this.matrixWorld;
        i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), jp.copy(this.boundingSphere), jp.applyMatrix4(s), e.ray.intersectsSphere(jp) !== !1 && (sb.copy(s).invert(), Yp.copy(e.ray).applyMatrix4(sb), !(this.boundingBox !== null && Yp.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Yp)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
    }
    bind(e, t) {
        this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Rt,
            t = this.geometry.attributes.skinWeight;
        for (let i = 0, s = t.count; i < s; i++) {
            e.fromBufferAttribute(t, i);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.bindMode === G_ ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === yR ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton,
            s = this.geometry;
        tb.fromBufferAttribute(s.attributes.skinIndex, e), ib.fromBufferAttribute(s.attributes.skinWeight, e), eb.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
        for (let r = 0; r < 4; r++) {
            const o = ib.getComponent(r);
            if (o !== 0) {
                const a = tb.getComponent(r);
                nb.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(AF.copy(eb).applyMatrix4(nb), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class Bw extends Ft {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}
class Bo extends oi {
    constructor(e = null, t = 1, i = 1, s, r, o, a, l, c = Kt, u = Kt, d, h) {
        super(null, o, a, l, c, u, s, r, d, h), this.isDataTexture = !0, this.image = {
            data: e,
            width: t,
            height: i
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
const rb = new Xe,
    vF = new Xe;
class f0 {
    constructor(e = [], t = []) {
        this.uuid = us(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
    }
    init() {
        const e = this.bones,
            t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let i = 0, s = this.bones.length; i < s; i++) this.boneInverses.push(new Xe)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new Xe;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones,
            t = this.boneInverses,
            i = this.boneMatrices,
            s = this.boneTexture;
        for (let r = 0, o = e.length; r < o; r++) {
            const a = e[r] ? e[r].matrixWorld : vF;
            rb.multiplyMatrices(a, t[r]), rb.toArray(i, r * 16)
        }
        s !== null && (s.needsUpdate = !0)
    }
    clone() {
        return new f0(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Bo(t, e, e, Jt, ei);
        return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const s = this.bones[t];
            if (s.name === e) return s
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, s = e.bones.length; i < s; i++) {
            const r = e.bones[i];
            let o = t[r];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new Bw), this.bones.push(o), this.boneInverses.push(new Xe().fromArray(e.boneInverses[i]))
        }
        return this.init(), this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones,
            i = this.boneInverses;
        for (let s = 0, r = t.length; s < r; s++) {
            const o = t[s];
            e.bones.push(o.uuid);
            const a = i[s];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class wg extends pi {
    constructor(e, t, i, s = 1) {
        super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
    }
}
const nl = new Xe,
    ob = new Xe,
    Ld = [],
    ab = new Sr,
    bF = new Xe,
    Ac = new Ri,
    _c = new js;
class xF extends Ri {
    constructor(e, t, i) {
        super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new wg(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
        for (let s = 0; s < i; s++) this.setMatrixAt(s, bF)
    }
    computeBoundingBox() {
        const e = this.geometry,
            t = this.count;
        this.boundingBox === null && (this.boundingBox = new Sr), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++) this.getMatrixAt(i, nl), ab.copy(e.boundingBox).applyMatrix4(nl), this.boundingBox.union(ab)
    }
    computeBoundingSphere() {
        const e = this.geometry,
            t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new js), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++) this.getMatrixAt(i, nl), _c.copy(e.boundingSphere).applyMatrix4(nl), this.boundingSphere.union(_c)
    }
    copy(e, t) {
        return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const i = t.morphTargetInfluences,
            s = this.morphTexture.source.data.data,
            r = i.length + 1,
            o = e * r + 1;
        for (let a = 0; a < i.length; a++) i[a] = s[o + a]
    }
    raycast(e, t) {
        const i = this.matrixWorld,
            s = this.count;
        if (Ac.geometry = this.geometry, Ac.material = this.material, Ac.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _c.copy(this.boundingSphere), _c.applyMatrix4(i), e.ray.intersectsSphere(_c) !== !1))
            for (let r = 0; r < s; r++) {
                this.getMatrixAt(r, nl), ob.multiplyMatrices(i, nl), Ac.matrixWorld = ob, Ac.raycast(e, Ld);
                for (let o = 0, a = Ld.length; o < a; o++) {
                    const l = Ld[o];
                    l.instanceId = r, l.object = this, t.push(l)
                }
                Ld.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new wg(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const i = t.morphTargetInfluences,
            s = i.length + 1;
        this.morphTexture === null && (this.morphTexture = new Bo(new Float32Array(s * this.count), s, this.count, ra, ei));
        const r = this.morphTexture.source.data.data;
        let o = 0;
        for (let c = 0; c < i.length; c++) o += i[c];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
            l = s * e;
        r[l] = a, r.set(i, l + 1)
    }
    updateMorphTargets() { }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this
    }
}
class Rl extends In {
    constructor(e) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Ue(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
    }
}
const lb = new z,
    cb = new z,
    ub = new Xe,
    Xp = new Wu,
    kd = new js;
class p0 extends Ft {
    constructor(e = new Gi, t = new Rl) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [0];
            for (let s = 1, r = t.count; s < r; s++) lb.fromBufferAttribute(t, s - 1), cb.fromBufferAttribute(t, s), i[s] = i[s - 1], i[s] += lb.distanceTo(cb);
            e.setAttribute("lineDistance", new xi(i, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry,
            s = this.matrixWorld,
            r = e.params.Line.threshold,
            o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), kd.copy(i.boundingSphere), kd.applyMatrix4(s), kd.radius += r, e.ray.intersectsSphere(kd) === !1) return;
        ub.copy(s).invert(), Xp.copy(e.ray).applyMatrix4(ub);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new z,
            u = new z,
            d = new z,
            h = new z,
            f = this.isLineSegments ? 2 : 1,
            m = i.index,
            A = i.attributes.position;
        if (m !== null) {
            const p = Math.max(0, o.start),
                v = Math.min(m.count, o.start + o.count);
            for (let _ = p, b = v - 1; _ < b; _ += f) {
                const w = m.getX(_),
                    E = m.getX(_ + 1);
                if (c.fromBufferAttribute(A, w), u.fromBufferAttribute(A, E), Xp.distanceSqToSegment(c, u, h, d) > l) continue;
                h.applyMatrix4(this.matrixWorld);
                const S = e.ray.origin.distanceTo(h);
                S < e.near || S > e.far || t.push({
                    distance: S,
                    point: d.clone().applyMatrix4(this.matrixWorld),
                    index: _,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const p = Math.max(0, o.start),
                v = Math.min(A.count, o.start + o.count);
            for (let _ = p, b = v - 1; _ < b; _ += f) {
                if (c.fromBufferAttribute(A, _), u.fromBufferAttribute(A, _ + 1), Xp.distanceSqToSegment(c, u, h, d) > l) continue;
                h.applyMatrix4(this.matrixWorld);
                const E = e.ray.origin.distanceTo(h);
                E < e.near || E > e.far || t.push({
                    distance: E,
                    point: d.clone().applyMatrix4(this.matrixWorld),
                    index: _,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const s = t[i[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let r = 0, o = s.length; r < o; r++) {
                    const a = s[r].name || String(r);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}
const db = new z,
    hb = new z;
class lf extends p0 {
    constructor(e, t) {
        super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [];
            for (let s = 0, r = t.count; s < r; s += 2) db.fromBufferAttribute(t, s), hb.fromBufferAttribute(t, s + 1), i[s] = s === 0 ? 0 : i[s - 1], i[s + 1] = i[s] + db.distanceTo(hb);
            e.setAttribute("lineDistance", new xi(i, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class yF extends p0 {
    constructor(e, t) {
        super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
    }
}
class gl extends In {
    constructor(e) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Ue(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
const fb = new Xe,
    Cg = new Wu,
    Fd = new js,
    Nd = new z;
class Kc extends Ft {
    constructor(e = new Gi, t = new gl) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    raycast(e, t) {
        const i = this.geometry,
            s = this.matrixWorld,
            r = e.params.Points.threshold,
            o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), Fd.copy(i.boundingSphere), Fd.applyMatrix4(s), Fd.radius += r, e.ray.intersectsSphere(Fd) === !1) return;
        fb.copy(s).invert(), Cg.copy(e.ray).applyMatrix4(fb);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = i.index,
            d = i.attributes.position;
        if (c !== null) {
            const h = Math.max(0, o.start),
                f = Math.min(c.count, o.start + o.count);
            for (let m = h, g = f; m < g; m++) {
                const A = c.getX(m);
                Nd.fromBufferAttribute(d, A), pb(Nd, A, l, s, e, t, this)
            }
        } else {
            const h = Math.max(0, o.start),
                f = Math.min(d.count, o.start + o.count);
            for (let m = h, g = f; m < g; m++) Nd.fromBufferAttribute(d, m), pb(Nd, m, l, s, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const s = t[i[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let r = 0, o = s.length; r < o; r++) {
                    const a = s[r].name || String(r);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}

function pb(n, e, t, i, s, r, o) {
    const a = Cg.distanceSqToPoint(n);
    if (a < t) {
        const l = new z;
        Cg.closestPointToPoint(n, l), l.applyMatrix4(i);
        const c = s.ray.origin.distanceTo(l);
        if (c < s.near || c > s.far) return;
        r.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class EF extends oi {
    constructor(e, t, i, s, r, o, a, l, c) {
        super(e, t, i, s, r, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Pt, this.magFilter = r !== void 0 ? r : Pt, this.generateMipmaps = !1;
        const u = this;

        function d() {
            u.needsUpdate = !0, e.requestVideoFrameCallback(d)
        }
        "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class Gf extends oi {
    constructor(e, t, i, s, r, o, a, l, c, u, d, h) {
        super(null, o, a, l, c, u, s, r, d, h), this.isCompressedTexture = !0, this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }
}
class wF extends Gf {
    constructor(e, t, i, s, r, o) {
        super(e, t, i, r, o), this.isCompressedArrayTexture = !0, this.image.depth = s, this.wrapR = pn
    }
}
class CF extends Gf {
    constructor(e, t, i) {
        super(void 0, e[0].width, e[0].height, t, i, ya), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
    }
}
class SF extends oi {
    constructor(e, t, i, s, r, o, a, l, c) {
        super(e, t, i, s, r, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}
class Ys {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, s = this.getPoint(0),
            r = 0;
        t.push(0);
        for (let o = 1; o <= e; o++) i = this.getPoint(o / e), r += i.distanceTo(s), t.push(r), s = i;
        return this.cacheArcLengths = t, t
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let s = 0;
        const r = i.length;
        let o;
        t ? o = t : o = e * i[r - 1];
        let a = 0,
            l = r - 1,
            c;
        for (; a <= l;)
            if (s = Math.floor(a + (l - a) / 2), c = i[s] - o, c < 0) a = s + 1;
            else if (c > 0) l = s - 1;
            else {
                l = s;
                break
            }
        if (s = l, i[s] === o) return s / (r - 1);
        const u = i[s],
            h = i[s + 1] - u,
            f = (o - u) / h;
        return (s + f) / (r - 1)
    }
    getTangent(e, t) {
        let s = e - 1e-4,
            r = e + 1e-4;
        s < 0 && (s = 0), r > 1 && (r = 1);
        const o = this.getPoint(s),
            a = this.getPoint(r),
            l = t || (o.isVector2 ? new _e : new z);
        return l.copy(a).sub(o).normalize(), l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new z,
            s = [],
            r = [],
            o = [],
            a = new z,
            l = new Xe;
        for (let f = 0; f <= e; f++) {
            const m = f / e;
            s[f] = this.getTangentAt(m, new z)
        }
        r[0] = new z, o[0] = new z;
        let c = Number.MAX_VALUE;
        const u = Math.abs(s[0].x),
            d = Math.abs(s[0].y),
            h = Math.abs(s[0].z);
        u <= c && (c = u, i.set(1, 0, 0)), d <= c && (c = d, i.set(0, 1, 0)), h <= c && i.set(0, 0, 1), a.crossVectors(s[0], i).normalize(), r[0].crossVectors(s[0], a), o[0].crossVectors(s[0], r[0]);
        for (let f = 1; f <= e; f++) {
            if (r[f] = r[f - 1].clone(), o[f] = o[f - 1].clone(), a.crossVectors(s[f - 1], s[f]), a.length() > Number.EPSILON) {
                a.normalize();
                const m = Math.acos(fi(s[f - 1].dot(s[f]), -1, 1));
                r[f].applyMatrix4(l.makeRotationAxis(a, m))
            }
            o[f].crossVectors(s[f], r[f])
        }
        if (t === !0) {
            let f = Math.acos(fi(r[0].dot(r[e]), -1, 1));
            f /= e, s[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let m = 1; m <= e; m++) r[m].applyMatrix4(l.makeRotationAxis(s[m], f * m)), o[m].crossVectors(s[m], r[m])
        }
        return {
            tangents: s,
            normals: r,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
}
class m0 extends Ys {
    constructor(e = 0, t = 0, i = 1, s = 1, r = 0, o = Math.PI * 2, a = !1, l = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = s, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
    }
    getPoint(e, t = new _e) {
        const i = t,
            s = Math.PI * 2;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0;) r += s;
        for (; r > s;) r -= s;
        r < Number.EPSILON && (o ? r = 0 : r = s), this.aClockwise === !0 && !o && (r === s ? r = -s : r = r - s);
        const a = this.aStartAngle + e * r;
        let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation),
                d = Math.sin(this.aRotation),
                h = l - this.aX,
                f = c - this.aY;
            l = h * u - f * d + this.aX, c = h * d + f * u + this.aY
        }
        return i.set(l, c)
    }
    copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
}
class MF extends m0 {
    constructor(e, t, i, s, r, o) {
        super(e, t, i, i, s, r, o), this.isArcCurve = !0, this.type = "ArcCurve"
    }
}

function g0() {
    let n = 0,
        e = 0,
        t = 0,
        i = 0;

    function s(r, o, a, l) {
        n = r, e = a, t = -3 * r + 3 * o - 2 * a - l, i = 2 * r - 2 * o + a + l
    }
    return {
        initCatmullRom: function (r, o, a, l, c) {
            s(o, a, c * (a - r), c * (l - o))
        },
        initNonuniformCatmullRom: function (r, o, a, l, c, u, d) {
            let h = (o - r) / c - (a - r) / (c + u) + (a - o) / u,
                f = (a - o) / u - (l - o) / (u + d) + (l - a) / d;
            h *= u, f *= u, s(o, a, h, f)
        },
        calc: function (r) {
            const o = r * r,
                a = o * r;
            return n + e * r + t * o + i * a
        }
    }
}
const Od = new z,
    Kp = new g0,
    Jp = new g0,
    Zp = new g0;
class TF extends Ys {
    constructor(e = [], t = !1, i = "centripetal", s = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = s
    }
    getPoint(e, t = new z) {
        const i = t,
            s = this.points,
            r = s.length,
            o = (r - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o),
            l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
        let c, u;
        this.closed || a > 0 ? c = s[(a - 1) % r] : (Od.subVectors(s[0], s[1]).add(s[0]), c = Od);
        const d = s[a % r],
            h = s[(a + 1) % r];
        if (this.closed || a + 2 < r ? u = s[(a + 2) % r] : (Od.subVectors(s[r - 1], s[r - 2]).add(s[r - 1]), u = Od), this.curveType === "centripetal" || this.curveType === "chordal") {
            const f = this.curveType === "chordal" ? .5 : .25;
            let m = Math.pow(c.distanceToSquared(d), f),
                g = Math.pow(d.distanceToSquared(h), f),
                A = Math.pow(h.distanceToSquared(u), f);
            g < 1e-4 && (g = 1), m < 1e-4 && (m = g), A < 1e-4 && (A = g), Kp.initNonuniformCatmullRom(c.x, d.x, h.x, u.x, m, g, A), Jp.initNonuniformCatmullRom(c.y, d.y, h.y, u.y, m, g, A), Zp.initNonuniformCatmullRom(c.z, d.z, h.z, u.z, m, g, A)
        } else this.curveType === "catmullrom" && (Kp.initCatmullRom(c.x, d.x, h.x, u.x, this.tension), Jp.initCatmullRom(c.y, d.y, h.y, u.y, this.tension), Zp.initCatmullRom(c.z, d.z, h.z, u.z, this.tension));
        return i.set(Kp.calc(l), Jp.calc(l), Zp.calc(l)), i
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const s = e.points[t];
            this.points.push(s.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const s = this.points[t];
            e.points.push(s.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const s = e.points[t];
            this.points.push(new z().fromArray(s))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
}

function mb(n, e, t, i, s) {
    const r = (i - e) * .5,
        o = (s - t) * .5,
        a = n * n,
        l = n * a;
    return (2 * t - 2 * i + r + o) * l + (-3 * t + 3 * i - 2 * r - o) * a + r * n + t
}

function IF(n, e) {
    const t = 1 - n;
    return t * t * e
}

function BF(n, e) {
    return 2 * (1 - n) * n * e
}

function RF(n, e) {
    return n * n * e
}

function Jc(n, e, t, i) {
    return IF(n, e) + BF(n, t) + RF(n, i)
}

function PF(n, e) {
    const t = 1 - n;
    return t * t * t * e
}

function DF(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}

function LF(n, e) {
    return 3 * (1 - n) * n * n * e
}

function kF(n, e) {
    return n * n * n * e
}

function Zc(n, e, t, i, s) {
    return PF(n, e) + DF(n, t) + LF(n, i) + kF(n, s)
}
class Rw extends Ys {
    constructor(e = new _e, t = new _e, i = new _e, s = new _e) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = s
    }
    getPoint(e, t = new _e) {
        const i = t,
            s = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(Zc(e, s.x, r.x, o.x, a.x), Zc(e, s.y, r.y, o.y, a.y)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class FF extends Ys {
    constructor(e = new z, t = new z, i = new z, s = new z) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = s
    }
    getPoint(e, t = new z) {
        const i = t,
            s = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(Zc(e, s.x, r.x, o.x, a.x), Zc(e, s.y, r.y, o.y, a.y), Zc(e, s.z, r.z, o.z, a.z)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class Pw extends Ys {
    constructor(e = new _e, t = new _e) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new _e) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t = new _e) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class NF extends Ys {
    constructor(e = new z, t = new z) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new z) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t = new z) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class Dw extends Ys {
    constructor(e = new _e, t = new _e, i = new _e) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i
    }
    getPoint(e, t = new _e) {
        const i = t,
            s = this.v0,
            r = this.v1,
            o = this.v2;
        return i.set(Jc(e, s.x, r.x, o.x), Jc(e, s.y, r.y, o.y)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class OF extends Ys {
    constructor(e = new z, t = new z, i = new z) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i
    }
    getPoint(e, t = new z) {
        const i = t,
            s = this.v0,
            r = this.v1,
            o = this.v2;
        return i.set(Jc(e, s.x, r.x, o.x), Jc(e, s.y, r.y, o.y), Jc(e, s.z, r.z, o.z)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class Lw extends Ys {
    constructor(e = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
    }
    getPoint(e, t = new _e) {
        const i = t,
            s = this.points,
            r = (s.length - 1) * e,
            o = Math.floor(r),
            a = r - o,
            l = s[o === 0 ? o : o - 1],
            c = s[o],
            u = s[o > s.length - 2 ? s.length - 1 : o + 1],
            d = s[o > s.length - 3 ? s.length - 1 : o + 2];
        return i.set(mb(a, l.x, c.x, u.x, d.x), mb(a, l.y, c.y, u.y, d.y)), i
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const s = e.points[t];
            this.points.push(s.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const s = this.points[t];
            e.points.push(s.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const s = e.points[t];
            this.points.push(new _e().fromArray(s))
        }
        return this
    }
}
var gb = Object.freeze({
    __proto__: null,
    ArcCurve: MF,
    CatmullRomCurve3: TF,
    CubicBezierCurve: Rw,
    CubicBezierCurve3: FF,
    EllipseCurve: m0,
    LineCurve: Pw,
    LineCurve3: NF,
    QuadraticBezierCurve: Dw,
    QuadraticBezierCurve3: OF,
    SplineCurve: Lw
});
class UF extends Ys {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new gb[i](t, e))
        }
        return this
    }
    getPoint(e, t) {
        const i = e * this.getLength(),
            s = this.getCurveLengths();
        let r = 0;
        for (; r < s.length;) {
            if (s[r] >= i) {
                const o = s[r] - i,
                    a = this.curves[r],
                    l = a.getLength(),
                    c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            r++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, s = this.curves.length; i < s; i++) t += this.curves[i].getLength(), e.push(t);
        return this.cacheLengths = e, e
    }
    getSpacedPoints(e = 40) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]), t
    }
    getPoints(e = 12) {
        const t = [];
        let i;
        for (let s = 0, r = this.curves; s < r.length; s++) {
            const o = r[s],
                a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
                l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const u = l[c];
                i && i.equals(u) || (t.push(u), i = u)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
    }
    copy(e) {
        super.copy(e), this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const s = e.curves[t];
            this.curves.push(s.clone())
        }
        return this.autoClose = e.autoClose, this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const s = this.curves[t];
            e.curves.push(s.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const s = e.curves[t];
            this.curves.push(new gb[s.type]().fromJSON(s))
        }
        return this
    }
}
class Sg extends UF {
    constructor(e) {
        super(), this.type = "Path", this.currentPoint = new _e, e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t), this
    }
    lineTo(e, t) {
        const i = new Pw(this.currentPoint.clone(), new _e(e, t));
        return this.curves.push(i), this.currentPoint.set(e, t), this
    }
    quadraticCurveTo(e, t, i, s) {
        const r = new Dw(this.currentPoint.clone(), new _e(e, t), new _e(i, s));
        return this.curves.push(r), this.currentPoint.set(i, s), this
    }
    bezierCurveTo(e, t, i, s, r, o) {
        const a = new Rw(this.currentPoint.clone(), new _e(e, t), new _e(i, s), new _e(r, o));
        return this.curves.push(a), this.currentPoint.set(r, o), this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
            i = new Lw(t);
        return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
    }
    arc(e, t, i, s, r, o) {
        const a = this.currentPoint.x,
            l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, s, r, o), this
    }
    absarc(e, t, i, s, r, o) {
        return this.absellipse(e, t, i, i, s, r, o), this
    }
    ellipse(e, t, i, s, r, o, a, l) {
        const c = this.currentPoint.x,
            u = this.currentPoint.y;
        return this.absellipse(e + c, t + u, i, s, r, o, a, l), this
    }
    absellipse(e, t, i, s, r, o, a, l) {
        const c = new m0(e, t, i, s, r, o, a, l);
        if (this.curves.length > 0) {
            const d = c.getPoint(0);
            d.equals(this.currentPoint) || this.lineTo(d.x, d.y)
        }
        this.curves.push(c);
        const u = c.getPoint(1);
        return this.currentPoint.copy(u), this
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
    }
}
class em extends Sg {
    constructor(e) {
        super(e), this.uuid = us(), this.type = "Shape", this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, s = this.holes.length; i < s; i++) t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e), this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const s = e.holes[t];
            this.holes.push(s.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const s = this.holes[t];
            e.holes.push(s.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const s = e.holes[t];
            this.holes.push(new Sg().fromJSON(s))
        }
        return this
    }
}
const QF = {
    triangulate: function (n, e, t = 2) {
        const i = e && e.length,
            s = i ? e[0] * t : n.length;
        let r = kw(n, 0, s, t, !0);
        const o = [];
        if (!r || r.next === r.prev) return o;
        let a, l, c, u, d, h, f;
        if (i && (r = WF(n, e, r, t)), n.length > 80 * t) {
            a = c = n[0], l = u = n[1];
            for (let m = t; m < s; m += t) d = n[m], h = n[m + 1], d < a && (a = d), h < l && (l = h), d > c && (c = d), h > u && (u = h);
            f = Math.max(c - a, u - l), f = f !== 0 ? 32767 / f : 0
        }
        return Tu(r, o, t, a, l, f, 0), o
    }
};

function kw(n, e, t, i, s) {
    let r, o;
    if (s === iN(n, e, t, i) > 0)
        for (r = e; r < t; r += i) o = Ab(r, n[r], n[r + 1], o);
    else
        for (r = t - i; r >= e; r -= i) o = Ab(r, n[r], n[r + 1], o);
    return o && Hf(o, o.next) && (Bu(o), o = o.next), o
}

function Ea(n, e) {
    if (!n) return n;
    e || (e = n);
    let t = n,
        i;
    do
        if (i = !1, !t.steiner && (Hf(t, t.next) || Xt(t.prev, t, t.next) === 0)) {
            if (Bu(t), t = e = t.prev, t === t.next) break;
            i = !0
        } else t = t.next; while (i || t !== e);
    return e
}

function Tu(n, e, t, i, s, r, o) {
    if (!n) return;
    !o && r && XF(n, i, s, r);
    let a = n,
        l, c;
    for (; n.prev !== n.next;) {
        if (l = n.prev, c = n.next, r ? GF(n, i, s, r) : zF(n)) {
            e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(c.i / t | 0), Bu(n), n = c.next, a = c.next;
            continue
        }
        if (n = c, n === a) {
            o ? o === 1 ? (n = HF(Ea(n), e, t), Tu(n, e, t, i, s, r, 2)) : o === 2 && VF(n, e, t, i, s, r) : Tu(Ea(n), e, t, i, s, r, 1);
            break
        }
    }
}

function zF(n) {
    const e = n.prev,
        t = n,
        i = n.next;
    if (Xt(e, t, i) >= 0) return !1;
    const s = e.x,
        r = t.x,
        o = i.x,
        a = e.y,
        l = t.y,
        c = i.y,
        u = s < r ? s < o ? s : o : r < o ? r : o,
        d = a < l ? a < c ? a : c : l < c ? l : c,
        h = s > r ? s > o ? s : o : r > o ? r : o,
        f = a > l ? a > c ? a : c : l > c ? l : c;
    let m = i.next;
    for (; m !== e;) {
        if (m.x >= u && m.x <= h && m.y >= d && m.y <= f && Al(s, a, r, l, o, c, m.x, m.y) && Xt(m.prev, m, m.next) >= 0) return !1;
        m = m.next
    }
    return !0
}

function GF(n, e, t, i) {
    const s = n.prev,
        r = n,
        o = n.next;
    if (Xt(s, r, o) >= 0) return !1;
    const a = s.x,
        l = r.x,
        c = o.x,
        u = s.y,
        d = r.y,
        h = o.y,
        f = a < l ? a < c ? a : c : l < c ? l : c,
        m = u < d ? u < h ? u : h : d < h ? d : h,
        g = a > l ? a > c ? a : c : l > c ? l : c,
        A = u > d ? u > h ? u : h : d > h ? d : h,
        p = Mg(f, m, e, t, i),
        v = Mg(g, A, e, t, i);
    let _ = n.prevZ,
        b = n.nextZ;
    for (; _ && _.z >= p && b && b.z <= v;) {
        if (_.x >= f && _.x <= g && _.y >= m && _.y <= A && _ !== s && _ !== o && Al(a, u, l, d, c, h, _.x, _.y) && Xt(_.prev, _, _.next) >= 0 || (_ = _.prevZ, b.x >= f && b.x <= g && b.y >= m && b.y <= A && b !== s && b !== o && Al(a, u, l, d, c, h, b.x, b.y) && Xt(b.prev, b, b.next) >= 0)) return !1;
        b = b.nextZ
    }
    for (; _ && _.z >= p;) {
        if (_.x >= f && _.x <= g && _.y >= m && _.y <= A && _ !== s && _ !== o && Al(a, u, l, d, c, h, _.x, _.y) && Xt(_.prev, _, _.next) >= 0) return !1;
        _ = _.prevZ
    }
    for (; b && b.z <= v;) {
        if (b.x >= f && b.x <= g && b.y >= m && b.y <= A && b !== s && b !== o && Al(a, u, l, d, c, h, b.x, b.y) && Xt(b.prev, b, b.next) >= 0) return !1;
        b = b.nextZ
    }
    return !0
}

function HF(n, e, t) {
    let i = n;
    do {
        const s = i.prev,
            r = i.next.next;
        !Hf(s, r) && Fw(s, i, i.next, r) && Iu(s, r) && Iu(r, s) && (e.push(s.i / t | 0), e.push(i.i / t | 0), e.push(r.i / t | 0), Bu(i), Bu(i.next), i = n = r), i = i.next
    } while (i !== n);
    return Ea(i)
}

function VF(n, e, t, i, s, r) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev;) {
            if (o.i !== a.i && ZF(o, a)) {
                let l = Nw(o, a);
                o = Ea(o, o.next), l = Ea(l, l.next), Tu(o, e, t, i, s, r, 0), Tu(l, e, t, i, s, r, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}

function WF(n, e, t, i) {
    const s = [];
    let r, o, a, l, c;
    for (r = 0, o = e.length; r < o; r++) a = e[r] * i, l = r < o - 1 ? e[r + 1] * i : n.length, c = kw(n, a, l, i, !1), c === c.next && (c.steiner = !0), s.push(JF(c));
    for (s.sort(qF), r = 0; r < s.length; r++) t = $F(s[r], t);
    return t
}

function qF(n, e) {
    return n.x - e.x
}

function $F(n, e) {
    const t = jF(n, e);
    if (!t) return e;
    const i = Nw(t, n);
    return Ea(i, i.next), Ea(t, t.next)
}

function jF(n, e) {
    let t = e,
        i = -1 / 0,
        s;
    const r = n.x,
        o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const h = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (h <= r && h > i && (i = h, s = t.x < t.next.x ? t : t.next, h === r)) return s
        }
        t = t.next
    } while (t !== e);
    if (!s) return null;
    const a = s,
        l = s.x,
        c = s.y;
    let u = 1 / 0,
        d;
    t = s;
    do r >= t.x && t.x >= l && r !== t.x && Al(o < c ? r : i, o, l, c, o < c ? i : r, o, t.x, t.y) && (d = Math.abs(o - t.y) / (r - t.x), Iu(t, n) && (d < u || d === u && (t.x > s.x || t.x === s.x && YF(s, t))) && (s = t, u = d)), t = t.next; while (t !== a);
    return s
}

function YF(n, e) {
    return Xt(n.prev, n, e.prev) < 0 && Xt(e.next, n, n.next) < 0
}

function XF(n, e, t, i) {
    let s = n;
    do s.z === 0 && (s.z = Mg(s.x, s.y, e, t, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; while (s !== n);
    s.prevZ.nextZ = null, s.prevZ = null, KF(s)
}

function KF(n) {
    let e, t, i, s, r, o, a, l, c = 1;
    do {
        for (t = n, n = null, r = null, o = 0; t;) {
            for (o++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++);
            for (l = c; a > 0 || l > 0 && i;) a !== 0 && (l === 0 || !i || t.z <= i.z) ? (s = t, t = t.nextZ, a--) : (s = i, i = i.nextZ, l--), r ? r.nextZ = s : n = s, s.prevZ = r, r = s;
            t = i
        }
        r.nextZ = null, c *= 2
    } while (o > 1);
    return n
}

function Mg(n, e, t, i, s) {
    return n = (n - t) * s | 0, e = (e - i) * s | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1
}

function JF(n) {
    let e = n,
        t = n;
    do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n);
    return t
}

function Al(n, e, t, i, s, r, o, a) {
    return (s - o) * (e - a) >= (n - o) * (r - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (s - o) * (i - a)
}

function ZF(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !eN(n, e) && (Iu(n, e) && Iu(e, n) && tN(n, e) && (Xt(n.prev, n, e.prev) || Xt(n, e.prev, e)) || Hf(n, e) && Xt(n.prev, n, n.next) > 0 && Xt(e.prev, e, e.next) > 0)
}

function Xt(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}

function Hf(n, e) {
    return n.x === e.x && n.y === e.y
}

function Fw(n, e, t, i) {
    const s = Qd(Xt(n, e, t)),
        r = Qd(Xt(n, e, i)),
        o = Qd(Xt(t, i, n)),
        a = Qd(Xt(t, i, e));
    return !!(s !== r && o !== a || s === 0 && Ud(n, t, e) || r === 0 && Ud(n, i, e) || o === 0 && Ud(t, n, i) || a === 0 && Ud(t, e, i))
}

function Ud(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}

function Qd(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}

function eN(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && Fw(t, t.next, n, e)) return !0;
        t = t.next
    } while (t !== n);
    return !1
}

function Iu(n, e) {
    return Xt(n.prev, n, n.next) < 0 ? Xt(n, e, n.next) >= 0 && Xt(n, n.prev, e) >= 0 : Xt(n, e, n.prev) < 0 || Xt(n, n.next, e) < 0
}

function tN(n, e) {
    let t = n,
        i = !1;
    const s = (n.x + e.x) / 2,
        r = (n.y + e.y) / 2;
    do t.y > r != t.next.y > r && t.next.y !== t.y && s < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next; while (t !== n);
    return i
}

function Nw(n, e) {
    const t = new Tg(n.i, n.x, n.y),
        i = new Tg(e.i, e.x, e.y),
        s = n.next,
        r = e.prev;
    return n.next = e, e.prev = n, t.next = s, s.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i
}

function Ab(n, e, t, i) {
    const s = new Tg(n, e, t);
    return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s
}

function Bu(n) {
    n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
}

function Tg(n, e, t) {
    this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function iN(n, e, t, i) {
    let s = 0;
    for (let r = e, o = t - i; r < t; r += i) s += (n[o] - n[r]) * (n[r + 1] + n[o + 1]), o = r;
    return s
}
class A0 {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let s = t - 1, r = 0; r < t; s = r++) i += e[s].x * e[r].y - e[r].x * e[s].y;
        return i * .5
    }
    static isClockWise(e) {
        return A0.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = [],
            s = [],
            r = [];
        _b(e), vb(i, e);
        let o = e.length;
        t.forEach(_b);
        for (let l = 0; l < t.length; l++) s.push(o), o += t[l].length, vb(i, t[l]);
        const a = QF.triangulate(i, s);
        for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
        return r
    }
}

function _b(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}

function vb(n, e) {
    for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y)
}
class nN extends ti {
    constructor(e) {
        super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
    }
}
class _0 extends In {
    constructor(e) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Ue(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = s0, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Cs, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class Mr extends _0 {
    constructor(e) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new _e(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function () {
                return fi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function (t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ue(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ue(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ue(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
    }
}
class sN extends In {
    constructor(e) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Ue(16777215), this.specular = new Ue(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = s0, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Cs, this.combine = XA, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}

function zd(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}

function rN(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}

function oN(n) {
    function e(s, r) {
        return n[s] - n[r]
    }
    const t = n.length,
        i = new Array(t);
    for (let s = 0; s !== t; ++s) i[s] = s;
    return i.sort(e), i
}

function bb(n, e, t) {
    const i = n.length,
        s = new n.constructor(i);
    for (let r = 0, o = 0; o !== i; ++r) {
        const a = t[r] * e;
        for (let l = 0; l !== e; ++l) s[o++] = n[a + l]
    }
    return s
}

function Ow(n, e, t, i) {
    let s = 1,
        r = n[0];
    for (; r !== void 0 && r[i] === void 0;) r = n[s++];
    if (r === void 0) return;
    let o = r[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do o = r[i], o !== void 0 && (e.push(r.time), t.push.apply(t, o)), r = n[s++]; while (r !== void 0);
        else if (o.toArray !== void 0)
            do o = r[i], o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), r = n[s++]; while (r !== void 0);
        else
            do o = r[i], o !== void 0 && (e.push(r.time), t.push(o)), r = n[s++]; while (r !== void 0)
}
class Yu {
    constructor(e, t, i, s) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex,
            s = t[i],
            r = t[i - 1];
        e: {
            t: {
                let o; i: {
                    n: if (!(e < s)) {
                        for (let a = i + 2; ;) {
                            if (s === void 0) {
                                if (e < r) break n;
                                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                            }
                            if (i === a) break;
                            if (r = s, s = t[++i], e < s) break t
                        }
                        o = t.length;
                        break i
                    } if (!(e >= r)) {
                        const a = t[1];
                        e < a && (i = 2, r = a);
                        for (let l = i - 2; ;) {
                            if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (i === l) break;
                            if (s = r, r = t[--i - 1], e >= r) break t
                        }
                        o = i, i = 0;
                        break i
                    }
                    break e
                }
                for (; i < o;) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (s = t[i], r = t[i - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (s === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
                this.intervalChanged_(i, r, s)
        }
        return this.interpolate_(i, r, e, s)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            i = this.sampleValues,
            s = this.valueSize,
            r = e * s;
        for (let o = 0; o !== s; ++o) t[o] = i[r + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() { }
}
class aN extends Yu {
    constructor(e, t, i, s) {
        super(e, t, i, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: fl,
            endingEnd: fl
        }
    }
    intervalChanged_(e, t, i) {
        const s = this.parameterPositions;
        let r = e - 2,
            o = e + 1,
            a = s[r],
            l = s[o];
        if (a === void 0) switch (this.getSettings_().endingStart) {
            case pl:
                r = e, a = 2 * t - i;
                break;
            case nf:
                r = s.length - 2, a = t + s[r] - s[r + 1];
                break;
            default:
                r = e, a = i
        }
        if (l === void 0) switch (this.getSettings_().endingEnd) {
            case pl:
                o = e, l = 2 * i - t;
                break;
            case nf:
                o = 1, l = i + s[1] - s[0];
                break;
            default:
                o = e - 1, l = t
        }
        const c = (i - t) * .5,
            u = this.valueSize;
        this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = r * u, this._offsetNext = o * u
    }
    interpolate_(e, t, i, s) {
        const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = this._offsetPrev,
            d = this._offsetNext,
            h = this._weightPrev,
            f = this._weightNext,
            m = (i - t) / (s - t),
            g = m * m,
            A = g * m,
            p = -h * A + 2 * h * g - h * m,
            v = (1 + h) * A + (-1.5 - 2 * h) * g + (-.5 + h) * m + 1,
            _ = (-1 - f) * A + (1.5 + f) * g + .5 * m,
            b = f * A - f * g;
        for (let w = 0; w !== a; ++w) r[w] = p * o[u + w] + v * o[c + w] + _ * o[l + w] + b * o[d + w];
        return r
    }
}
class Uw extends Yu {
    constructor(e, t, i, s) {
        super(e, t, i, s)
    }
    interpolate_(e, t, i, s) {
        const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = (i - t) / (s - t),
            d = 1 - u;
        for (let h = 0; h !== a; ++h) r[h] = o[c + h] * d + o[l + h] * u;
        return r
    }
}
class lN extends Yu {
    constructor(e, t, i, s) {
        super(e, t, i, s)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class Xs {
    constructor(e, t, i, s) {
        if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = zd(t, this.TimeBufferType), this.values = zd(i, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: zd(e.times, Array),
                values: zd(e.values, Array)
            };
            const s = e.getInterpolation();
            s !== e.DefaultInterpolation && (i.interpolation = s)
        }
        return i.type = e.ValueTypeName, i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new lN(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new Uw(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new aN(this.times, this.values, this.getValueSize(), e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
            case Su:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case Vl:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case xp:
                t = this.InterpolantFactoryMethodSmooth;
                break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i), this
        }
        return this.createInterpolant = t, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return Su;
            case this.InterpolantFactoryMethodLinear:
                return Vl;
            case this.InterpolantFactoryMethodSmooth:
                return xp
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, s = t.length; i !== s; ++i) t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, s = t.length; i !== s; ++i) t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times,
            s = i.length;
        let r = 0,
            o = s - 1;
        for (; r !== s && i[r] < e;) ++r;
        for (; o !== -1 && i[o] > t;) --o;
        if (++o, r !== 0 || o !== s) {
            r >= o && (o = Math.max(o, 1), r = o - 1);
            const a = this.getValueSize();
            this.times = i.slice(r, o), this.values = this.values.slice(r * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
        const i = this.times,
            s = this.values,
            r = i.length;
        r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
        let o = null;
        for (let a = 0; a !== r; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
                break
            }
            o = l
        }
        if (s !== void 0 && rN(s))
            for (let a = 0, l = s.length; a !== l; ++a) {
                const c = s[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice(),
            t = this.values.slice(),
            i = this.getValueSize(),
            s = this.getInterpolation() === xp,
            r = e.length - 1;
        let o = 1;
        for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = e[a],
                u = e[a + 1];
            if (c !== u && (a !== 1 || c !== e[0]))
                if (s) l = !0;
                else {
                    const d = a * i,
                        h = d - i,
                        f = d + i;
                    for (let m = 0; m !== i; ++m) {
                        const g = t[d + m];
                        if (g !== t[h + m] || g !== t[f + m]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const d = a * i,
                        h = o * i;
                    for (let f = 0; f !== i; ++f) t[h + f] = t[d + f]
                } ++o
            }
        }
        if (r > 0) {
            e[o] = e[r];
            for (let a = r * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * i)) : (this.times = e, this.values = t), this
    }
    clone() {
        const e = this.times.slice(),
            t = this.values.slice(),
            i = this.constructor,
            s = new i(this.name, e, t);
        return s.createInterpolant = this.createInterpolant, s
    }
}
Xs.prototype.TimeBufferType = Float32Array;
Xs.prototype.ValueBufferType = Float32Array;
Xs.prototype.DefaultInterpolation = Vl;
class ic extends Xs { }
ic.prototype.ValueTypeName = "bool";
ic.prototype.ValueBufferType = Array;
ic.prototype.DefaultInterpolation = Su;
ic.prototype.InterpolantFactoryMethodLinear = void 0;
ic.prototype.InterpolantFactoryMethodSmooth = void 0;
class Qw extends Xs { }
Qw.prototype.ValueTypeName = "color";
class jl extends Xs { }
jl.prototype.ValueTypeName = "number";
class cN extends Yu {
    constructor(e, t, i, s) {
        super(e, t, i, s)
    }
    interpolate_(e, t, i, s) {
        const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (i - t) / (s - t);
        let c = e * a;
        for (let u = c + a; c !== u; c += 4) Tn.slerpFlat(r, 0, o, c - a, o, c, l);
        return r
    }
}
class wa extends Xs {
    InterpolantFactoryMethodLinear(e) {
        return new cN(this.times, this.values, this.getValueSize(), e)
    }
}
wa.prototype.ValueTypeName = "quaternion";
wa.prototype.DefaultInterpolation = Vl;
wa.prototype.InterpolantFactoryMethodSmooth = void 0;
class nc extends Xs { }
nc.prototype.ValueTypeName = "string";
nc.prototype.ValueBufferType = Array;
nc.prototype.DefaultInterpolation = Su;
nc.prototype.InterpolantFactoryMethodLinear = void 0;
nc.prototype.InterpolantFactoryMethodSmooth = void 0;
class Yl extends Xs { }
Yl.prototype.ValueTypeName = "vector";
class Ig {
    constructor(e = "", t = -1, i = [], s = n0) {
        this.name = e, this.tracks = i, this.duration = t, this.blendMode = s, this.uuid = us(), this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = [],
            i = e.tracks,
            s = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o) t.push(dN(i[o]).scale(s));
        const r = new this(e.name, e.duration, t, e.blendMode);
        return r.uuid = e.uuid, r
    }
    static toJSON(e) {
        const t = [],
            i = e.tracks,
            s = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
        for (let r = 0, o = i.length; r !== o; ++r) t.push(Xs.toJSON(i[r]));
        return s
    }
    static CreateFromMorphTargetSequence(e, t, i, s) {
        const r = t.length,
            o = [];
        for (let a = 0; a < r; a++) {
            let l = [],
                c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
            const u = oN(l);
            l = bb(l, 1, u), c = bb(c, 1, u), !s && l[0] === 0 && (l.push(r), c.push(c[0])), o.push(new jl(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / i))
        }
        return new this(e, -1, o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const s = e;
            i = s.geometry && s.geometry.animations || s.animations
        }
        for (let s = 0; s < i.length; s++)
            if (i[s].name === t) return i[s];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const s = {},
            r = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
                u = c.name.match(r);
            if (u && u.length > 1) {
                const d = u[1];
                let h = s[d];
                h || (s[d] = h = []), h.push(c)
            }
        }
        const o = [];
        for (const a in s) o.push(this.CreateFromMorphTargetSequence(a, s[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const i = function (d, h, f, m, g) {
            if (f.length !== 0) {
                const A = [],
                    p = [];
                Ow(f, A, p, m), A.length !== 0 && g.push(new d(h, A, p))
            }
        },
            s = [],
            r = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let d = 0; d < c.length; d++) {
            const h = c[d].keys;
            if (!(!h || h.length === 0))
                if (h[0].morphTargets) {
                    const f = {};
                    let m;
                    for (m = 0; m < h.length; m++)
                        if (h[m].morphTargets)
                            for (let g = 0; g < h[m].morphTargets.length; g++) f[h[m].morphTargets[g]] = -1;
                    for (const g in f) {
                        const A = [],
                            p = [];
                        for (let v = 0; v !== h[m].morphTargets.length; ++v) {
                            const _ = h[m];
                            A.push(_.time), p.push(_.morphTarget === g ? 1 : 0)
                        }
                        s.push(new jl(".morphTargetInfluence[" + g + "]", A, p))
                    }
                    l = f.length * o
                } else {
                    const f = ".bones[" + t[d].name + "]";
                    i(Yl, f + ".position", h, "pos", s), i(wa, f + ".quaternion", h, "rot", s), i(Yl, f + ".scale", h, "scl", s)
                }
        }
        return s.length === 0 ? null : new this(r, l, s, a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, s = e.length; i !== s; ++i) {
            const r = this.tracks[i];
            t = Math.max(t, r.times[r.times.length - 1])
        }
        return this.duration = t, this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function uN(n) {
    switch (n.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return jl;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return Yl;
        case "color":
            return Qw;
        case "quaternion":
            return wa;
        case "bool":
        case "boolean":
            return ic;
        case "string":
            return nc
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}

function dN(n) {
    if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = uN(n.type);
    if (n.times === void 0) {
        const t = [],
            i = [];
        Ow(n.keys, t, i, "value"), n.times = t, n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation)
}
const ao = {
    enabled: !1,
    files: {},
    add: function (n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function (n) {
        if (this.enabled !== !1) return this.files[n]
    },
    remove: function (n) {
        delete this.files[n]
    },
    clear: function () {
        this.files = {}
    }
};
class hN {
    constructor(e, t, i) {
        const s = this;
        let r = !1,
            o = 0,
            a = 0,
            l;
        const c = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (u) {
            a++, r === !1 && s.onStart !== void 0 && s.onStart(u, o, a), r = !0
        }, this.itemEnd = function (u) {
            o++, s.onProgress !== void 0 && s.onProgress(u, o, a), o === a && (r = !1, s.onLoad !== void 0 && s.onLoad())
        }, this.itemError = function (u) {
            s.onError !== void 0 && s.onError(u)
        }, this.resolveURL = function (u) {
            return l ? l(u) : u
        }, this.setURLModifier = function (u) {
            return l = u, this
        }, this.addHandler = function (u, d) {
            return c.push(u, d), this
        }, this.removeHandler = function (u) {
            const d = c.indexOf(u);
            return d !== -1 && c.splice(d, 2), this
        }, this.getHandler = function (u) {
            for (let d = 0, h = c.length; d < h; d += 2) {
                const f = c[d],
                    m = c[d + 1];
                if (f.global && (f.lastIndex = 0), f.test(u)) return m
            }
            return null
        }
    }
}
const fN = new hN;
class $n {
    constructor(e) {
        this.manager = e !== void 0 ? e : fN, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() { }
    loadAsync(e, t) {
        const i = this;
        return new Promise(function (s, r) {
            i.load(e, s, t, r)
        })
    }
    parse() { }
    setCrossOrigin(e) {
        return this.crossOrigin = e, this
    }
    setWithCredentials(e) {
        return this.withCredentials = e, this
    }
    setPath(e) {
        return this.path = e, this
    }
    setResourcePath(e) {
        return this.resourcePath = e, this
    }
    setRequestHeader(e) {
        return this.requestHeader = e, this
    }
}
$n.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const nr = {};
class pN extends Error {
    constructor(e, t) {
        super(e), this.response = t
    }
}
class ws extends $n {
    constructor(e) {
        super(e)
    }
    load(e, t, i, s) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const r = ao.get(e);
        if (r !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            t && t(r), this.manager.itemEnd(e)
        }, 0), r;
        if (nr[e] !== void 0) {
            nr[e].push({
                onLoad: t,
                onProgress: i,
                onError: s
            });
            return
        }
        nr[e] = [], nr[e].push({
            onLoad: t,
            onProgress: i,
            onError: s
        });
        const o = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        }),
            a = this.mimeType,
            l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
                const u = nr[e],
                    d = c.body.getReader(),
                    h = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
                    f = h ? parseInt(h) : 0,
                    m = f !== 0;
                let g = 0;
                const A = new ReadableStream({
                    start(p) {
                        v();

                        function v() {
                            d.read().then(({
                                done: _,
                                value: b
                            }) => {
                                if (_) p.close();
                                else {
                                    g += b.byteLength;
                                    const w = new ProgressEvent("progress", {
                                        lengthComputable: m,
                                        loaded: g,
                                        total: f
                                    });
                                    for (let E = 0, C = u.length; E < C; E++) {
                                        const S = u[E];
                                        S.onProgress && S.onProgress(w)
                                    }
                                    p.enqueue(b), v()
                                }
                            })
                        }
                    }
                });
                return new Response(A)
            } else throw new pN(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
        }).then(c => {
            switch (l) {
                case "arraybuffer":
                    return c.arrayBuffer();
                case "blob":
                    return c.blob();
                case "document":
                    return c.text().then(u => new DOMParser().parseFromString(u, a));
                case "json":
                    return c.json();
                default:
                    if (a === void 0) return c.text(); {
                        const d = /charset="?([^;"\s]*)"?/i.exec(a),
                            h = d && d[1] ? d[1].toLowerCase() : void 0,
                            f = new TextDecoder(h);
                        return c.arrayBuffer().then(m => f.decode(m))
                    }
            }
        }).then(c => {
            ao.add(e, c);
            const u = nr[e];
            delete nr[e];
            for (let d = 0, h = u.length; d < h; d++) {
                const f = u[d];
                f.onLoad && f.onLoad(c)
            }
        }).catch(c => {
            const u = nr[e];
            if (u === void 0) throw this.manager.itemError(e), c;
            delete nr[e];
            for (let d = 0, h = u.length; d < h; d++) {
                const f = u[d];
                f.onError && f.onError(c)
            }
            this.manager.itemError(e)
        }).finally(() => {
            this.manager.itemEnd(e)
        }), this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e, this
    }
    setMimeType(e) {
        return this.mimeType = e, this
    }
}
class zw extends $n {
    constructor(e) {
        super(e)
    }
    load(e, t, i, s) {
        this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const r = this,
            o = ao.get(e);
        if (o !== void 0) return r.manager.itemStart(e), setTimeout(function () {
            t && t(o), r.manager.itemEnd(e)
        }, 0), o;
        const a = Mu("img");

        function l() {
            u(), ao.add(e, this), t && t(this), r.manager.itemEnd(e)
        }

        function c(d) {
            u(), s && s(d), r.manager.itemError(e), r.manager.itemEnd(e)
        }

        function u() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a
    }
}
class mN extends $n {
    constructor(e) {
        super(e)
    }
    load(e, t, i, s) {
        const r = new l0;
        r.colorSpace = Wt;
        const o = new zw(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;

        function l(c) {
            o.load(e[c], function (u) {
                r.images[c] = u, a++, a === 6 && (r.needsUpdate = !0, t && t(r))
            }, void 0, s)
        }
        for (let c = 0; c < e.length; ++c) l(c);
        return r
    }
}
class gN extends $n {
    constructor(e) {
        super(e)
    }
    load(e, t, i, s) {
        const r = this,
            o = new Bo,
            a = new ws(this.manager);
        return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, function (l) {
            let c;
            try {
                c = r.parse(l)
            } catch (u) {
                if (s !== void 0) s(u);
                else {
                    console.error(u);
                    return
                }
            }
            c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : pn, o.wrapT = c.wrapT !== void 0 ? c.wrapT : pn, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Pt, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Pt, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = ys), c.mipmapCount === 1 && (o.minFilter = Pt), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c)
        }, i, s), o
    }
}
class Gw extends $n {
    constructor(e) {
        super(e)
    }
    load(e, t, i, s) {
        const r = new oi,
            o = new zw(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) {
            r.image = a, r.needsUpdate = !0, t !== void 0 && t(r)
        }, i, s), r
    }
}
class Vf extends Ft {
    constructor(e, t = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new Ue(e), this.intensity = t
    }
    dispose() { }
    copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t
    }
}
const tm = new Xe,
    xb = new z,
    yb = new z;
class v0 {
    constructor(e) {
        this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new _e(512, 512), this.map = null, this.mapPass = null, this.matrix = new Xe, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Qf, this._frameExtents = new _e(1, 1), this._viewportCount = 1, this._viewports = [new Rt(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera,
            i = this.matrix;
        xb.setFromMatrixPosition(e.matrixWorld), t.position.copy(xb), yb.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(yb), t.updateMatrixWorld(), tm.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(tm), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(tm)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
    }
}
class AN extends v0 {
    constructor() {
        super(new cn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera,
            i = Wl * 2 * e.angle * this.focus,
            s = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
        (i !== t.fov || s !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = s, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e), this.focus = e.focus, this
    }
}
class _N extends Vf {
    constructor(e, t, i = 0, s = Math.PI / 3, r = 0, o = 2) {
        super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ft.DEFAULT_UP), this.updateMatrix(), this.target = new Ft, this.distance = i, this.angle = s, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new AN
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
const Eb = new Xe,
    vc = new z,
    im = new z;
class vN extends v0 {
    constructor() {
        super(new cn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new _e(4, 2), this._viewportCount = 6, this._viewports = [new Rt(2, 1, 1, 1), new Rt(0, 1, 1, 1), new Rt(3, 1, 1, 1), new Rt(1, 1, 1, 1), new Rt(3, 0, 1, 1), new Rt(1, 0, 1, 1)], this._cubeDirections = [new z(1, 0, 0), new z(-1, 0, 0), new z(0, 0, 1), new z(0, 0, -1), new z(0, 1, 0), new z(0, -1, 0)], this._cubeUps = [new z(0, 1, 0), new z(0, 1, 0), new z(0, 1, 0), new z(0, 1, 0), new z(0, 0, 1), new z(0, 0, -1)]
    }
    updateMatrices(e, t = 0) {
        const i = this.camera,
            s = this.matrix,
            r = e.distance || i.far;
        r !== i.far && (i.far = r, i.updateProjectionMatrix()), vc.setFromMatrixPosition(e.matrixWorld), i.position.copy(vc), im.copy(i.position), im.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(im), i.updateMatrixWorld(), s.makeTranslation(-vc.x, -vc.y, -vc.z), Eb.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Eb)
    }
}
class bN extends Vf {
    constructor(e, t, i = 0, s = 2) {
        super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = s, this.shadow = new vN
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
    }
}
class xN extends v0 {
    constructor() {
        super(new ju(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}
class Hw extends Vf {
    constructor(e, t) {
        super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ft.DEFAULT_UP), this.updateMatrix(), this.target = new Ft, this.shadow = new xN
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
class yN extends Vf {
    constructor(e, t) {
        super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}
class eu {
    static decodeText(e) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, s = e.length; i < s; i++) t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class EN extends $n {
    constructor(e) {
        super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e, this
    }
    load(e, t, i, s) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const r = this,
            o = ao.get(e);
        if (o !== void 0) {
            if (r.manager.itemStart(e), o.then) {
                o.then(c => {
                    t && t(c), r.manager.itemEnd(e)
                }).catch(c => {
                    s && s(c)
                });
                return
            }
            return setTimeout(function () {
                t && t(o), r.manager.itemEnd(e)
            }, 0), o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
        const l = fetch(e, a).then(function (c) {
            return c.blob()
        }).then(function (c) {
            return createImageBitmap(c, Object.assign(r.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function (c) {
            return ao.add(e, c), t && t(c), r.manager.itemEnd(e), c
        }).catch(function (c) {
            s && s(c), ao.remove(e), r.manager.itemError(e), r.manager.itemEnd(e)
        });
        ao.add(e, l), r.manager.itemStart(e)
    }
}
let Gd;
class Vw {
    static getContext() {
        return Gd === void 0 && (Gd = new (window.AudioContext || window.webkitAudioContext)), Gd
    }
    static setContext(e) {
        Gd = e
    }
}
class wN extends $n {
    constructor(e) {
        super(e)
    }
    load(e, t, i, s) {
        const r = this,
            o = new ws(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (l) {
            try {
                const c = l.slice(0);
                Vw.getContext().decodeAudioData(c, function (d) {
                    t(d)
                }).catch(a)
            } catch (c) {
                a(c)
            }
        }, i, s);

        function a(l) {
            s ? s(l) : console.error(l), r.manager.itemError(e)
        }
    }
}
class Ww {
    constructor(e = !0) {
        this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    start() {
        this.startTime = wb(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }
    stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const t = wb();
            e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
        }
        return e
    }
}

function wb() {
    return (typeof performance > "u" ? Date : performance).now()
}
const qo = new z,
    Cb = new Tn,
    CN = new z,
    $o = new z;
class SN extends Ft {
    constructor() {
        super(), this.type = "AudioListener", this.context = Vw.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Ww
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener,
            i = this.up;
        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(qo, Cb, CN), $o.set(0, 0, -1).applyQuaternion(Cb), t.positionX) {
            const s = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(qo.x, s), t.positionY.linearRampToValueAtTime(qo.y, s), t.positionZ.linearRampToValueAtTime(qo.z, s), t.forwardX.linearRampToValueAtTime($o.x, s), t.forwardY.linearRampToValueAtTime($o.y, s), t.forwardZ.linearRampToValueAtTime($o.z, s), t.upX.linearRampToValueAtTime(i.x, s), t.upY.linearRampToValueAtTime(i.y, s), t.upZ.linearRampToValueAtTime(i.z, s)
        } else t.setPosition(qo.x, qo.y, qo.z), t.setOrientation($o.x, $o.y, $o.z, i.x, i.y, i.z)
    }
}
class MN extends Ft {
    constructor(e) {
        super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
    }
    setBuffer(e) {
        return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
    }
    play(e = 0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this._connected = !1, this
        }
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
    }
    setDetune(e) {
        return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
    }
    setLoopStart(e) {
        return this.loopStart = e, this
    }
    setLoopEnd(e) {
        return this.loopEnd = e, this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
}
class TN {
    constructor(e, t, i) {
        this.binding = e, this.valueSize = i;
        let s, r, o;
        switch (t) {
            case "quaternion":
                s = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                s = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
                break;
            default:
                s = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = s, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer,
            s = this.valueSize,
            r = e * s + s;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== s; ++a) i[r + a] = i[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, r, 0, a, s)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer,
            i = this.valueSize,
            s = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, s, 0, e, i), this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize,
            i = this.buffer,
            s = e * t + t,
            r = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(i, s, l, 1 - r, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, s, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
            if (i[l] !== i[l + t]) {
                a.setValue(i, s);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding,
            t = this.buffer,
            i = this.valueSize,
            s = i * this._origIndex;
        e.getValue(t, s);
        for (let r = i, o = s; r !== o; ++r) t[r] = t[s + r % i];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
        for (let i = e; i < t; i++) this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, s, r) {
        if (s >= .5)
            for (let o = 0; o !== r; ++o) e[t + o] = e[i + o]
    }
    _slerp(e, t, i, s) {
        Tn.slerpFlat(e, t, e, t, e, i, s)
    }
    _slerpAdditive(e, t, i, s, r) {
        const o = this._workIndex * r;
        Tn.multiplyQuaternionsFlat(e, o, e, t, e, i), Tn.slerpFlat(e, t, e, t, e, o, s)
    }
    _lerp(e, t, i, s, r) {
        const o = 1 - s;
        for (let a = 0; a !== r; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[i + a] * s
        }
    }
    _lerpAdditive(e, t, i, s, r) {
        for (let o = 0; o !== r; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * s
        }
    }
}
const b0 = "\\[\\]\\.:\\/",
    IN = new RegExp("[" + b0 + "]", "g"),
    x0 = "[^" + b0 + "]",
    BN = "[^" + b0.replace("\\.", "") + "]",
    RN = /((?:WC+[\/:])*)/.source.replace("WC", x0),
    PN = /(WCOD+)?/.source.replace("WCOD", BN),
    DN = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", x0),
    LN = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", x0),
    kN = new RegExp("^" + RN + PN + DN + LN + "$"),
    FN = ["material", "materials", "bones", "map"];
class NN {
    constructor(e, t, i) {
        const s = i || Et.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, s)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_,
            s = this._bindings[i];
        s !== void 0 && s.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let s = this._targetGroup.nCachedObjects_, r = i.length; s !== r; ++s) i[s].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
    }
}
class Et {
    constructor(e, t, i) {
        this.path = t, this.parsedPath = i || Et.parseTrackName(t), this.node = Et.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new Et.Composite(e, t, i) : new Et(e, t, i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(IN, "")
    }
    static parseTrackName(e) {
        const t = kN.exec(e);
        if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        },
            s = i.nodeName && i.nodeName.lastIndexOf(".");
        if (s !== void 0 && s !== -1) {
            const r = i.nodeName.substring(s + 1);
            FN.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, s), i.objectName = r)
        }
        if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0) return i
        }
        if (e.children) {
            const i = function (r) {
                for (let o = 0; o < r.length; o++) {
                    const a = r[o];
                    if (a.name === t || a.uuid === t) return a;
                    const l = i(a.children);
                    if (l) return l
                }
                return null
            },
                s = i(e.children);
            if (s) return s
        }
        return null
    }
    _getValue_unavailable() { }
    _setValue_unavailable() { }
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let s = 0, r = i.length; s !== r; ++s) e[t++] = i[s]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath,
            i = t.objectName,
            s = t.propertyName;
        let r = t.propertyIndex;
        if (e || (e = Et.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (i) {
            let c = t.objectIndex;
            switch (i) {
                case "materials":
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    e = e.skeleton.bones;
                    for (let u = 0; u < e.length; u++)
                        if (e[u].name === c) {
                            c = u;
                            break
                        }
                    break;
                case "map":
                    if ("map" in e) {
                        e = e.map;
                        break
                    }
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    e = e.material.map;
                    break;
                default:
                    if (e[i] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    e = e[i]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[s];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + s + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (r !== void 0) {
            if (s === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r])
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
        } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = s;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
Et.Composite = NN;
Et.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Et.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Et.prototype.GetterByBindingType = [Et.prototype._getValue_direct, Et.prototype._getValue_array, Et.prototype._getValue_arrayElement, Et.prototype._getValue_toArray];
Et.prototype.SetterByBindingTypeAndVersioning = [
    [Et.prototype._setValue_direct, Et.prototype._setValue_direct_setNeedsUpdate, Et.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [Et.prototype._setValue_array, Et.prototype._setValue_array_setNeedsUpdate, Et.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [Et.prototype._setValue_arrayElement, Et.prototype._setValue_arrayElement_setNeedsUpdate, Et.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [Et.prototype._setValue_fromArray, Et.prototype._setValue_fromArray_setNeedsUpdate, Et.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class ON {
    constructor(e, t, i = null, s = t.blendMode) {
        this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = s;
        const r = t.tracks,
            o = r.length,
            a = new Array(o),
            l = {
                endingStart: fl,
                endingEnd: fl
            };
        for (let c = 0; c !== o; ++c) {
            const u = r[c].createInterpolant(null);
            a[c] = u, u.settings = l
        }
        this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = PR, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this), this
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset()
    }
    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e, this
    }
    setLoop(e, t) {
        return this.loop = e, this.repetitions = t, this
    }
    setEffectiveWeight(e) {
        return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t), this.fadeIn(t), i) {
            const s = this._clip.duration,
                r = e._clip.duration,
                o = r / s,
                a = s / r;
            e.warp(1, o, t), this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e, this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const s = this._mixer,
            r = s.time,
            o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = s._lendControlInterpolant(), this._timeScaleInterpolant = a);
        const l = a.parameterPositions,
            c = a.sampleValues;
        return l[0] = r, l[1] = r + i, c[0] = e / o, c[1] = t / o, this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, s) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const r = this._startTime;
        if (r !== null) {
            const l = (e - r) * i;
            l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t),
            a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants,
                c = this._propertyBindings;
            switch (this.blendMode) {
                case LR:
                    for (let u = 0, d = l.length; u !== d; ++u) l[u].evaluate(o), c[u].accumulateAdditive(a);
                    break;
                case n0:
                default:
                    for (let u = 0, d = l.length; u !== d; ++u) l[u].evaluate(o), c[u].accumulate(s, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const s = i.evaluate(e)[0];
                t *= s, e > i.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t, t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const s = i.evaluate(e)[0];
                t *= s, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t, t
    }
    _updateTime(e) {
        const t = this._clip.duration,
            i = this.loop;
        let s = this.time + e,
            r = this._loopCount;
        const o = i === DR;
        if (e === 0) return r === -1 ? s : o && (r & 1) === 1 ? t - s : s;
        if (i === RR) {
            r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            e: {
                if (s >= t) s = t;
                else if (s < 0) s = 0;
                else {
                    this.time = s;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = s,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
            }
        } else {
            if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), s >= t || s < 0) {
                const a = Math.floor(s / t);
                s -= t * a, r += Math.abs(a);
                const l = this.repetitions - r;
                if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? t : 0, this.time = s, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1
                });
                else {
                    if (l === 1) {
                        const c = e < 0;
                        this._setEndings(c, !c, o)
                    } else this._setEndings(!1, !1, o);
                    this._loopCount = r, this.time = s, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else this.time = s;
            if (o && (r & 1) === 1) return t - s
        }
        return s
    }
    _setEndings(e, t, i) {
        const s = this._interpolantSettings;
        i ? (s.endingStart = pl, s.endingEnd = pl) : (e ? s.endingStart = this.zeroSlopeAtStart ? pl : fl : s.endingStart = nf, t ? s.endingEnd = this.zeroSlopeAtEnd ? pl : fl : s.endingEnd = nf)
    }
    _scheduleFading(e, t, i) {
        const s = this._mixer,
            r = s.time;
        let o = this._weightInterpolant;
        o === null && (o = s._lendControlInterpolant(), this._weightInterpolant = o);
        const a = o.parameterPositions,
            l = o.sampleValues;
        return a[0] = r, l[0] = t, a[1] = r + e, l[1] = i, this
    }
}
const UN = new Float32Array(1);
class QN extends Io {
    constructor(e) {
        super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root,
            s = e._clip.tracks,
            r = s.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = i.uuid,
            c = this._bindingsByRootAndName;
        let u = c[l];
        u === void 0 && (u = {}, c[l] = u);
        for (let d = 0; d !== r; ++d) {
            const h = s[d],
                f = h.name;
            let m = u[f];
            if (m !== void 0) ++m.referenceCount, o[d] = m;
            else {
                if (m = o[d], m !== void 0) {
                    m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, f));
                    continue
                }
                const g = t && t._propertyBindings[d].binding.parsedPath;
                m = new TN(Et.create(i, f, g), h.ValueTypeName, h.getValueSize()), ++m.referenceCount, this._addInactiveBinding(m, l, f), o[d] = m
            }
            a[d].resultBuffer = m.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid,
                    s = e._clip.uuid,
                    r = this._actionsByClip[s];
                this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, s, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, s = t.length; i !== s; ++i) {
                const r = t[i];
                r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, s = t.length; i !== s; ++i) {
                const r = t[i];
                --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const s = this._actions,
            r = this._actionsByClip;
        let o = r[t];
        if (o === void 0) o = {
            knownActions: [e],
            actionByRoot: {}
        }, e._byClipCacheIndex = 0, r[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length, a.push(e)
        }
        e._cacheIndex = s.length, s.push(e), o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions,
            i = t[t.length - 1],
            s = e._cacheIndex;
        i._cacheIndex = s, t[s] = i, t.pop(), e._cacheIndex = null;
        const r = e._clip.uuid,
            o = this._actionsByClip,
            a = o[r],
            l = a.knownActions,
            c = l[l.length - 1],
            u = e._byClipCacheIndex;
        c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
        const d = a.actionByRoot,
            h = (e._localRoot || this._root).uuid;
        delete d[h], l.length === 0 && delete o[r], this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, s = t.length; i !== s; ++i) {
            const r = t[i];
            --r.referenceCount === 0 && this._removeInactiveBinding(r)
        }
    }
    _lendAction(e) {
        const t = this._actions,
            i = e._cacheIndex,
            s = this._nActiveActions++,
            r = t[s];
        e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
    }
    _takeBackAction(e) {
        const t = this._actions,
            i = e._cacheIndex,
            s = --this._nActiveActions,
            r = t[s];
        e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
    }
    _addInactiveBinding(e, t, i) {
        const s = this._bindingsByRootAndName,
            r = this._bindings;
        let o = s[t];
        o === void 0 && (o = {}, s[t] = o), o[i] = e, e._cacheIndex = r.length, r.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings,
            i = e.binding,
            s = i.rootNode.uuid,
            r = i.path,
            o = this._bindingsByRootAndName,
            a = o[s],
            l = t[t.length - 1],
            c = e._cacheIndex;
        l._cacheIndex = c, t[c] = l, t.pop(), delete a[r], Object.keys(a).length === 0 && delete o[s]
    }
    _lendBinding(e) {
        const t = this._bindings,
            i = e._cacheIndex,
            s = this._nActiveBindings++,
            r = t[s];
        e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
    }
    _takeBackBinding(e) {
        const t = this._bindings,
            i = e._cacheIndex,
            s = --this._nActiveBindings,
            r = t[s];
        e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new Uw(new Float32Array(2), new Float32Array(2), 1, UN), i.__cacheIndex = t, e[t] = i), i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
            i = e.__cacheIndex,
            s = --this._nActiveControlInterpolants,
            r = t[s];
        e.__cacheIndex = s, t[s] = e, r.__cacheIndex = i, t[i] = r
    }
    clipAction(e, t, i) {
        const s = t || this._root,
            r = s.uuid;
        let o = typeof e == "string" ? Ig.findByName(s, e) : e;
        const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
        let c = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = n0), l !== void 0) {
            const d = l.actionByRoot[r];
            if (d !== void 0 && d.blendMode === i) return d;
            c = l.knownActions[0], o === null && (o = c._clip)
        }
        if (o === null) return null;
        const u = new ON(this, o, t, i);
        return this._bindAction(u, c), this._addInactiveAction(u, a, r), u
    }
    existingAction(e, t) {
        const i = t || this._root,
            s = i.uuid,
            r = typeof e == "string" ? Ig.findByName(i, e) : e,
            o = r ? r.uuid : e,
            a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[s] || null
    }
    stopAllAction() {
        const e = this._actions,
            t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i) e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions,
            i = this._nActiveActions,
            s = this.time += e,
            r = Math.sign(e),
            o = this._accuIndex ^= 1;
        for (let c = 0; c !== i; ++c) t[c]._update(s, e, r, o);
        const a = this._bindings,
            l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c) a[c].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions,
            i = e.uuid,
            s = this._actionsByClip,
            r = s[i];
        if (r !== void 0) {
            const o = r.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const u = c._cacheIndex,
                    d = t[t.length - 1];
                c._cacheIndex = null, c._byClipCacheIndex = null, d._cacheIndex = u, t[u] = d, t.pop(), this._removeInactiveBindingsForAction(c)
            }
            delete s[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid,
            i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot,
                l = a[t];
            l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
        }
        const s = this._bindingsByRootAndName,
            r = s[t];
        if (r !== void 0)
            for (const o in r) {
                const a = r[o];
                a.restoreOriginalState(), this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i), this._removeInactiveAction(i))
    }
}
class vi {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new vi(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
class Sb {
    constructor(e = 1, t = 0, i = 0) {
        return this.radius = e, this.phi = t, this.theta = i, this
    }
    set(e, t, i) {
        return this.radius = e, this.phi = t, this.theta = i, this
    }
    copy(e) {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(fi(t / this.radius, -1, 1))), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class zN extends lf {
    constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
            s = new Gi;
        s.setAttribute("position", new xi(t, 3)), s.setAttribute("color", new xi(i, 3));
        const r = new Rl({
            vertexColors: !0,
            toneMapped: !1
        });
        super(s, r), this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const s = new Ue,
            r = this.geometry.attributes.color.array;
        return s.set(e), s.toArray(r, 0), s.toArray(r, 3), s.set(t), s.toArray(r, 6), s.toArray(r, 9), s.set(i), s.toArray(r, 12), s.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class GN {
    constructor() {
        this.type = "ShapePath", this.color = new Ue, this.subPaths = [], this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Sg, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this
    }
    quadraticCurveTo(e, t, i, s) {
        return this.currentPath.quadraticCurveTo(e, t, i, s), this
    }
    bezierCurveTo(e, t, i, s, r, o) {
        return this.currentPath.bezierCurveTo(e, t, i, s, r, o), this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e), this
    }
    toShapes(e) {
        function t(p) {
            const v = [];
            for (let _ = 0, b = p.length; _ < b; _++) {
                const w = p[_],
                    E = new em;
                E.curves = w.curves, v.push(E)
            }
            return v
        }

        function i(p, v) {
            const _ = v.length;
            let b = !1;
            for (let w = _ - 1, E = 0; E < _; w = E++) {
                let C = v[w],
                    S = v[E],
                    x = S.x - C.x,
                    y = S.y - C.y;
                if (Math.abs(y) > Number.EPSILON) {
                    if (y < 0 && (C = v[E], x = -x, S = v[w], y = -y), p.y < C.y || p.y > S.y) continue;
                    if (p.y === C.y) {
                        if (p.x === C.x) return !0
                    } else {
                        const P = y * (p.x - C.x) - x * (p.y - C.y);
                        if (P === 0) return !0;
                        if (P < 0) continue;
                        b = !b
                    }
                } else {
                    if (p.y !== C.y) continue;
                    if (S.x <= p.x && p.x <= C.x || C.x <= p.x && p.x <= S.x) return !0
                }
            }
            return b
        }
        const s = A0.isClockWise,
            r = this.subPaths;
        if (r.length === 0) return [];
        let o, a, l;
        const c = [];
        if (r.length === 1) return a = r[0], l = new em, l.curves = a.curves, c.push(l), c;
        let u = !s(r[0].getPoints());
        u = e ? !u : u;
        const d = [],
            h = [];
        let f = [],
            m = 0,
            g;
        h[m] = void 0, f[m] = [];
        for (let p = 0, v = r.length; p < v; p++) a = r[p], g = a.getPoints(), o = s(g), o = e ? !o : o, o ? (!u && h[m] && m++, h[m] = {
            s: new em,
            p: g
        }, h[m].s.curves = a.curves, u && m++, f[m] = []) : f[m].push({
            h: a,
            p: g[0]
        });
        if (!h[0]) return t(r);
        if (h.length > 1) {
            let p = !1,
                v = 0;
            for (let _ = 0, b = h.length; _ < b; _++) d[_] = [];
            for (let _ = 0, b = h.length; _ < b; _++) {
                const w = f[_];
                for (let E = 0; E < w.length; E++) {
                    const C = w[E];
                    let S = !0;
                    for (let x = 0; x < h.length; x++) i(C.p, h[x].p) && (_ !== x && v++, S ? (S = !1, d[x].push(C)) : p = !0);
                    S && d[_].push(C)
                }
            }
            v > 0 && p === !1 && (f = d)
        }
        let A;
        for (let p = 0, v = h.length; p < v; p++) {
            l = h[p].s, c.push(l), A = f[p];
            for (let _ = 0, b = A.length; _ < b; _++) l.holes.push(A[_].h)
        }
        return c
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: YA
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = YA);
var HN = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function VN(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var qw = {
    exports: {}
};
(function (n, e) {
    (function (t, i) {
        n.exports = i()
    })(HN, function () {
        var t = function () {
            function i(f) {
                return o.appendChild(f.dom), f
            }

            function s(f) {
                for (var m = 0; m < o.children.length; m++) o.children[m].style.display = m === f ? "block" : "none";
                r = f
            }
            var r = 0,
                o = document.createElement("div");
            o.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", o.addEventListener("click", function (f) {
                f.preventDefault(), s(++r % o.children.length)
            }, !1);
            var a = (performance || Date).now(),
                l = a,
                c = 0,
                u = i(new t.Panel("FPS", "#0ff", "#002")),
                d = i(new t.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory) var h = i(new t.Panel("MB", "#f08", "#201"));
            return s(0), {
                REVISION: 16,
                dom: o,
                addPanel: i,
                showPanel: s,
                begin: function () {
                    a = (performance || Date).now()
                },
                end: function () {
                    c++;
                    var f = (performance || Date).now();
                    if (d.update(f - a, 200), f > l + 1e3 && (u.update(1e3 * c / (f - l), 100), l = f, c = 0, h)) {
                        var m = performance.memory;
                        h.update(m.usedJSHeapSize / 1048576, m.jsHeapSizeLimit / 1048576)
                    }
                    return f
                },
                update: function () {
                    a = this.end()
                },
                domElement: o,
                setMode: s
            }
        };
        return t.Panel = function (i, s, r) {
            var o = 1 / 0,
                a = 0,
                l = Math.round,
                c = l(window.devicePixelRatio || 1),
                u = 80 * c,
                d = 48 * c,
                h = 3 * c,
                f = 2 * c,
                m = 3 * c,
                g = 15 * c,
                A = 74 * c,
                p = 30 * c,
                v = document.createElement("canvas");
            v.width = u, v.height = d, v.style.cssText = "width:80px;height:48px";
            var _ = v.getContext("2d");
            return _.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", _.textBaseline = "top", _.fillStyle = r, _.fillRect(0, 0, u, d), _.fillStyle = s, _.fillText(i, h, f), _.fillRect(m, g, A, p), _.fillStyle = r, _.globalAlpha = .9, _.fillRect(m, g, A, p), {
                dom: v,
                update: function (b, w) {
                    o = Math.min(o, b), a = Math.max(a, b), _.fillStyle = r, _.globalAlpha = 1, _.fillRect(0, 0, u, g), _.fillStyle = s, _.fillText(l(b) + " " + i + " (" + l(o) + "-" + l(a) + ")", h, f), _.drawImage(v, m + c, g, A - c, p, m, g, A - c, p), _.fillRect(m + A - c, g, c, p), _.fillStyle = r, _.globalAlpha = .9, _.fillRect(m + A - c, g, c, l((1 - b / w) * p))
                }
            }
        }, t
    })
})(qw);
var WN = qw.exports;
const qN = VN(WN);
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.19.2
 * @author George Michael Brower
 * @license MIT
 */
let sc = class wh {
    constructor(e, t, i, s, r = "div") {
        this.parent = e, this.object = t, this.property = i, this._disabled = !1, this._hidden = !1, this.initialValue = this.getValue(), this.domElement = document.createElement(r), this.domElement.classList.add("controller"), this.domElement.classList.add(s), this.$name = document.createElement("div"), this.$name.classList.add("name"), wh.nextNameID = wh.nextNameID || 0, this.$name.id = `lil-gui-name-${++wh.nextNameID}`, this.$widget = document.createElement("div"), this.$widget.classList.add("widget"), this.$disable = this.$widget, this.domElement.appendChild(this.$name), this.domElement.appendChild(this.$widget), this.domElement.addEventListener("keydown", o => o.stopPropagation()), this.domElement.addEventListener("keyup", o => o.stopPropagation()), this.parent.children.push(this), this.parent.controllers.push(this), this.parent.$children.appendChild(this.domElement), this._listenCallback = this._listenCallback.bind(this), this.name(i)
    }
    name(e) {
        return this._name = e, this.$name.textContent = e, this
    }
    onChange(e) {
        return this._onChange = e, this
    }
    _callOnChange() {
        this.parent._callOnChange(this), this._onChange !== void 0 && this._onChange.call(this, this.getValue()), this._changed = !0
    }
    onFinishChange(e) {
        return this._onFinishChange = e, this
    }
    _callOnFinishChange() {
        this._changed && (this.parent._callOnFinishChange(this), this._onFinishChange !== void 0 && this._onFinishChange.call(this, this.getValue())), this._changed = !1
    }
    reset() {
        return this.setValue(this.initialValue), this._callOnFinishChange(), this
    }
    enable(e = !0) {
        return this.disable(!e)
    }
    disable(e = !0) {
        return e === this._disabled ? this : (this._disabled = e, this.domElement.classList.toggle("disabled", e), this.$disable.toggleAttribute("disabled", e), this)
    }
    show(e = !0) {
        return this._hidden = !e, this.domElement.style.display = this._hidden ? "none" : "", this
    }
    hide() {
        return this.show(!1)
    }
    options(e) {
        const t = this.parent.add(this.object, this.property, e);
        return t.name(this._name), this.destroy(), t
    }
    min(e) {
        return this
    }
    max(e) {
        return this
    }
    step(e) {
        return this
    }
    decimals(e) {
        return this
    }
    listen(e = !0) {
        return this._listening = e, this._listenCallbackID !== void 0 && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this
    }
    _listenCallback() {
        this._listenCallbackID = requestAnimationFrame(this._listenCallback);
        const e = this.save();
        e !== this._listenPrevValue && this.updateDisplay(), this._listenPrevValue = e
    }
    getValue() {
        return this.object[this.property]
    }
    setValue(e) {
        return this.getValue() !== e && (this.object[this.property] = e, this._callOnChange(), this.updateDisplay()), this
    }
    updateDisplay() {
        return this
    }
    load(e) {
        return this.setValue(e), this._callOnFinishChange(), this
    }
    save() {
        return this.getValue()
    }
    destroy() {
        this.listen(!1), this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1), this.parent.$children.removeChild(this.domElement)
    }
};
class $N extends sc {
    constructor(e, t, i) {
        super(e, t, i, "boolean", "label"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "checkbox"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$input.addEventListener("change", () => {
            this.setValue(this.$input.checked), this._callOnFinishChange()
        }), this.$disable = this.$input, this.updateDisplay()
    }
    updateDisplay() {
        return this.$input.checked = this.getValue(), this
    }
}

function Bg(n) {
    let e, t;
    return (e = n.match(/(#|0x)?([a-f0-9]{6})/i)) ? t = e[2] : (e = n.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? t = parseInt(e[1]).toString(16).padStart(2, 0) + parseInt(e[2]).toString(16).padStart(2, 0) + parseInt(e[3]).toString(16).padStart(2, 0) : (e = n.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (t = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), t ? "#" + t : !1
}
const jN = {
    isPrimitive: !0,
    match: n => typeof n == "string",
    fromHexString: Bg,
    toHexString: Bg
},
    Ru = {
        isPrimitive: !0,
        match: n => typeof n == "number",
        fromHexString: n => parseInt(n.substring(1), 16),
        toHexString: n => "#" + n.toString(16).padStart(6, 0)
    },
    YN = {
        isPrimitive: !1,
        match: n => Array.isArray(n),
        fromHexString(n, e, t = 1) {
            const i = Ru.fromHexString(n);
            e[0] = (i >> 16 & 255) / 255 * t, e[1] = (i >> 8 & 255) / 255 * t, e[2] = (i & 255) / 255 * t
        },
        toHexString([n, e, t], i = 1) {
            i = 255 / i;
            const s = n * i << 16 ^ e * i << 8 ^ t * i << 0;
            return Ru.toHexString(s)
        }
    },
    XN = {
        isPrimitive: !1,
        match: n => Object(n) === n,
        fromHexString(n, e, t = 1) {
            const i = Ru.fromHexString(n);
            e.r = (i >> 16 & 255) / 255 * t, e.g = (i >> 8 & 255) / 255 * t, e.b = (i & 255) / 255 * t
        },
        toHexString({
            r: n,
            g: e,
            b: t
        }, i = 1) {
            i = 255 / i;
            const s = n * i << 16 ^ e * i << 8 ^ t * i << 0;
            return Ru.toHexString(s)
        }
    },
    KN = [jN, Ru, YN, XN];

function JN(n) {
    return KN.find(e => e.match(n))
}
class ZN extends sc {
    constructor(e, t, i, s) {
        super(e, t, i, "color"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "color"), this.$input.setAttribute("tabindex", -1), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$text = document.createElement("input"), this.$text.setAttribute("type", "text"), this.$text.setAttribute("spellcheck", "false"), this.$text.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$display.appendChild(this.$input), this.$widget.appendChild(this.$display), this.$widget.appendChild(this.$text), this._format = JN(this.initialValue), this._rgbScale = s, this._initialValueHexString = this.save(), this._textFocused = !1, this.$input.addEventListener("input", () => {
            this._setValueFromHexString(this.$input.value)
        }), this.$input.addEventListener("blur", () => {
            this._callOnFinishChange()
        }), this.$text.addEventListener("input", () => {
            const r = Bg(this.$text.value);
            r && this._setValueFromHexString(r)
        }), this.$text.addEventListener("focus", () => {
            this._textFocused = !0, this.$text.select()
        }), this.$text.addEventListener("blur", () => {
            this._textFocused = !1, this.updateDisplay(), this._callOnFinishChange()
        }), this.$disable = this.$text, this.updateDisplay()
    }
    reset() {
        return this._setValueFromHexString(this._initialValueHexString), this
    }
    _setValueFromHexString(e) {
        if (this._format.isPrimitive) {
            const t = this._format.fromHexString(e);
            this.setValue(t)
        } else this._format.fromHexString(e, this.getValue(), this._rgbScale), this._callOnChange(), this.updateDisplay()
    }
    save() {
        return this._format.toHexString(this.getValue(), this._rgbScale)
    }
    load(e) {
        return this._setValueFromHexString(e), this._callOnFinishChange(), this
    }
    updateDisplay() {
        return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this
    }
}
class nm extends sc {
    constructor(e, t, i) {
        super(e, t, i, "function"), this.$button = document.createElement("button"), this.$button.appendChild(this.$name), this.$widget.appendChild(this.$button), this.$button.addEventListener("click", s => {
            s.preventDefault(), this.getValue().call(this.object), this._callOnChange()
        }), this.$button.addEventListener("touchstart", () => { }, {
            passive: !0
        }), this.$disable = this.$button
    }
}
class e3 extends sc {
    constructor(e, t, i, s, r, o) {
        super(e, t, i, "number"), this._initInput(), this.min(s), this.max(r);
        const a = o !== void 0;
        this.step(a ? o : this._getImplicitStep(), a), this.updateDisplay()
    }
    decimals(e) {
        return this._decimals = e, this.updateDisplay(), this
    }
    min(e) {
        return this._min = e, this._onUpdateMinMax(), this
    }
    max(e) {
        return this._max = e, this._onUpdateMinMax(), this
    }
    step(e, t = !0) {
        return this._step = e, this._stepExplicit = t, this
    }
    updateDisplay() {
        const e = this.getValue();
        if (this._hasSlider) {
            let t = (e - this._min) / (this._max - this._min);
            t = Math.max(0, Math.min(t, 1)), this.$fill.style.width = t * 100 + "%"
        }
        return this._inputFocused || (this.$input.value = this._decimals === void 0 ? e : e.toFixed(this._decimals)), this
    }
    _initInput() {
        this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("aria-labelledby", this.$name.id), window.matchMedia("(pointer: coarse)").matches && (this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any")), this.$widget.appendChild(this.$input), this.$disable = this.$input;
        const t = () => {
            let v = parseFloat(this.$input.value);
            isNaN(v) || (this._stepExplicit && (v = this._snap(v)), this.setValue(this._clamp(v)))
        },
            i = v => {
                const _ = parseFloat(this.$input.value);
                isNaN(_) || (this._snapClampSetValue(_ + v), this.$input.value = this.getValue())
            },
            s = v => {
                v.key === "Enter" && this.$input.blur(), v.code === "ArrowUp" && (v.preventDefault(), i(this._step * this._arrowKeyMultiplier(v))), v.code === "ArrowDown" && (v.preventDefault(), i(this._step * this._arrowKeyMultiplier(v) * -1))
            },
            r = v => {
                this._inputFocused && (v.preventDefault(), i(this._step * this._normalizeMouseWheel(v)))
            };
        let o = !1,
            a, l, c, u, d;
        const h = 5,
            f = v => {
                a = v.clientX, l = c = v.clientY, o = !0, u = this.getValue(), d = 0, window.addEventListener("mousemove", m), window.addEventListener("mouseup", g)
            },
            m = v => {
                if (o) {
                    const _ = v.clientX - a,
                        b = v.clientY - l;
                    Math.abs(b) > h ? (v.preventDefault(), this.$input.blur(), o = !1, this._setDraggingStyle(!0, "vertical")) : Math.abs(_) > h && g()
                }
                if (!o) {
                    const _ = v.clientY - c;
                    d -= _ * this._step * this._arrowKeyMultiplier(v), u + d > this._max ? d = this._max - u : u + d < this._min && (d = this._min - u), this._snapClampSetValue(u + d)
                }
                c = v.clientY
            },
            g = () => {
                this._setDraggingStyle(!1, "vertical"), this._callOnFinishChange(), window.removeEventListener("mousemove", m), window.removeEventListener("mouseup", g)
            },
            A = () => {
                this._inputFocused = !0
            },
            p = () => {
                this._inputFocused = !1, this.updateDisplay(), this._callOnFinishChange()
            };
        this.$input.addEventListener("input", t), this.$input.addEventListener("keydown", s), this.$input.addEventListener("wheel", r, {
            passive: !1
        }), this.$input.addEventListener("mousedown", f), this.$input.addEventListener("focus", A), this.$input.addEventListener("blur", p)
    }
    _initSlider() {
        this._hasSlider = !0, this.$slider = document.createElement("div"), this.$slider.classList.add("slider"), this.$fill = document.createElement("div"), this.$fill.classList.add("fill"), this.$slider.appendChild(this.$fill), this.$widget.insertBefore(this.$slider, this.$input), this.domElement.classList.add("hasSlider");
        const e = (p, v, _, b, w) => (p - v) / (_ - v) * (w - b) + b,
            t = p => {
                const v = this.$slider.getBoundingClientRect();
                let _ = e(p, v.left, v.right, this._min, this._max);
                this._snapClampSetValue(_)
            },
            i = p => {
                this._setDraggingStyle(!0), t(p.clientX), window.addEventListener("mousemove", s), window.addEventListener("mouseup", r)
            },
            s = p => {
                t(p.clientX)
            },
            r = () => {
                this._callOnFinishChange(), this._setDraggingStyle(!1), window.removeEventListener("mousemove", s), window.removeEventListener("mouseup", r)
            };
        let o = !1,
            a, l;
        const c = p => {
            p.preventDefault(), this._setDraggingStyle(!0), t(p.touches[0].clientX), o = !1
        },
            u = p => {
                p.touches.length > 1 || (this._hasScrollBar ? (a = p.touches[0].clientX, l = p.touches[0].clientY, o = !0) : c(p), window.addEventListener("touchmove", d, {
                    passive: !1
                }), window.addEventListener("touchend", h))
            },
            d = p => {
                if (o) {
                    const v = p.touches[0].clientX - a,
                        _ = p.touches[0].clientY - l;
                    Math.abs(v) > Math.abs(_) ? c(p) : (window.removeEventListener("touchmove", d), window.removeEventListener("touchend", h))
                } else p.preventDefault(), t(p.touches[0].clientX)
            },
            h = () => {
                this._callOnFinishChange(), this._setDraggingStyle(!1), window.removeEventListener("touchmove", d), window.removeEventListener("touchend", h)
            },
            f = this._callOnFinishChange.bind(this),
            m = 400;
        let g;
        const A = p => {
            if (Math.abs(p.deltaX) < Math.abs(p.deltaY) && this._hasScrollBar) return;
            p.preventDefault();
            const _ = this._normalizeMouseWheel(p) * this._step;
            this._snapClampSetValue(this.getValue() + _), this.$input.value = this.getValue(), clearTimeout(g), g = setTimeout(f, m)
        };
        this.$slider.addEventListener("mousedown", i), this.$slider.addEventListener("touchstart", u, {
            passive: !1
        }), this.$slider.addEventListener("wheel", A, {
            passive: !1
        })
    }
    _setDraggingStyle(e, t = "horizontal") {
        this.$slider && this.$slider.classList.toggle("active", e), document.body.classList.toggle("lil-gui-dragging", e), document.body.classList.toggle(`lil-gui-${t}`, e)
    }
    _getImplicitStep() {
        return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : .1
    }
    _onUpdateMinMax() {
        !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), !1), this._initSlider(), this.updateDisplay())
    }
    _normalizeMouseWheel(e) {
        let {
            deltaX: t,
            deltaY: i
        } = e;
        return Math.floor(e.deltaY) !== e.deltaY && e.wheelDelta && (t = 0, i = -e.wheelDelta / 120, i *= this._stepExplicit ? 1 : 10), t + -i
    }
    _arrowKeyMultiplier(e) {
        let t = this._stepExplicit ? 1 : 10;
        return e.shiftKey ? t *= 10 : e.altKey && (t /= 10), t
    }
    _snap(e) {
        const t = Math.round(e / this._step) * this._step;
        return parseFloat(t.toPrecision(15))
    }
    _clamp(e) {
        return e < this._min && (e = this._min), e > this._max && (e = this._max), e
    }
    _snapClampSetValue(e) {
        this.setValue(this._clamp(this._snap(e)))
    }
    get _hasScrollBar() {
        const e = this.parent.root.$children;
        return e.scrollHeight > e.clientHeight
    }
    get _hasMin() {
        return this._min !== void 0
    }
    get _hasMax() {
        return this._max !== void 0
    }
}
class t3 extends sc {
    constructor(e, t, i, s) {
        super(e, t, i, "option"), this.$select = document.createElement("select"), this.$select.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$select.addEventListener("change", () => {
            this.setValue(this._values[this.$select.selectedIndex]), this._callOnFinishChange()
        }), this.$select.addEventListener("focus", () => {
            this.$display.classList.add("focus")
        }), this.$select.addEventListener("blur", () => {
            this.$display.classList.remove("focus")
        }), this.$widget.appendChild(this.$select), this.$widget.appendChild(this.$display), this.$disable = this.$select, this.options(s)
    }
    options(e) {
        return this._values = Array.isArray(e) ? e : Object.values(e), this._names = Array.isArray(e) ? e : Object.keys(e), this.$select.replaceChildren(), this._names.forEach(t => {
            const i = document.createElement("option");
            i.textContent = t, this.$select.appendChild(i)
        }), this.updateDisplay(), this
    }
    updateDisplay() {
        const e = this.getValue(),
            t = this._values.indexOf(e);
        return this.$select.selectedIndex = t, this.$display.textContent = t === -1 ? e : this._names[t], this
    }
}
class i3 extends sc {
    constructor(e, t, i) {
        super(e, t, i, "string"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("spellcheck", "false"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$input.addEventListener("input", () => {
            this.setValue(this.$input.value)
        }), this.$input.addEventListener("keydown", s => {
            s.code === "Enter" && this.$input.blur()
        }), this.$input.addEventListener("blur", () => {
            this._callOnFinishChange()
        }), this.$widget.appendChild(this.$input), this.$disable = this.$input, this.updateDisplay()
    }
    updateDisplay() {
        return this.$input.value = this.getValue(), this
    }
}
const n3 = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "↕";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "▾";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "▸";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "✓";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: none;
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
  }
  .lil-gui button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;

function s3(n) {
    const e = document.createElement("style");
    e.innerHTML = n;
    const t = document.querySelector("head link[rel=stylesheet], head style");
    t ? document.head.insertBefore(e, t) : document.head.appendChild(e)
}
let Mb = !1;
class y0 {
    constructor({
        parent: e,
        autoPlace: t = e === void 0,
        container: i,
        width: s,
        title: r = "Controls",
        closeFolders: o = !1,
        injectStyles: a = !0,
        touchStyles: l = !0
    } = {}) {
        if (this.parent = e, this.root = e ? e.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = !1, this._hidden = !1, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", !0), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", () => this.openAnimated(this._closed)), this.$title.addEventListener("keydown", c => {
            (c.code === "Enter" || c.code === "Space") && (c.preventDefault(), this.$title.click())
        }), this.$title.addEventListener("touchstart", () => { }, {
            passive: !0
        }), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(r), this.parent) {
            this.parent.children.push(this), this.parent.folders.push(this), this.parent.$children.appendChild(this.domElement);
            return
        }
        this.domElement.classList.add("root"), l && this.domElement.classList.add("allow-touch-styles"), !Mb && a && (s3(n3), Mb = !0), i ? i.appendChild(this.domElement) : t && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)), s && this.domElement.style.setProperty("--width", s + "px"), this._closeFolders = o
    }
    add(e, t, i, s, r) {
        if (Object(i) === i) return new t3(this, e, t, i);
        const o = e[t];
        switch (typeof o) {
            case "number":
                return new e3(this, e, t, i, s, r);
            case "boolean":
                return new $N(this, e, t);
            case "string":
                return new i3(this, e, t);
            case "function":
                return new nm(this, e, t)
        }
        console.error(`gui.add failed
	property:`, t, `
	object:`, e, `
	value:`, o)
    }
    addColor(e, t, i = 1) {
        return new ZN(this, e, t, i)
    }
    addFolder(e) {
        const t = new y0({
            parent: this,
            title: e
        });
        return this.root._closeFolders && t.close(), t
    }
    load(e, t = !0) {
        return e.controllers && this.controllers.forEach(i => {
            i instanceof nm || i._name in e.controllers && i.load(e.controllers[i._name])
        }), t && e.folders && this.folders.forEach(i => {
            i._title in e.folders && i.load(e.folders[i._title])
        }), this
    }
    save(e = !0) {
        const t = {
            controllers: {},
            folders: {}
        };
        return this.controllers.forEach(i => {
            if (!(i instanceof nm)) {
                if (i._name in t.controllers) throw new Error(`Cannot save GUI with duplicate property "${i._name}"`);
                t.controllers[i._name] = i.save()
            }
        }), e && this.folders.forEach(i => {
            if (i._title in t.folders) throw new Error(`Cannot save GUI with duplicate folder "${i._title}"`);
            t.folders[i._title] = i.save()
        }), t
    }
    open(e = !0) {
        return this._setClosed(!e), this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this
    }
    close() {
        return this.open(!1)
    }
    _setClosed(e) {
        this._closed !== e && (this._closed = e, this._callOnOpenClose(this))
    }
    show(e = !0) {
        return this._hidden = !e, this.domElement.style.display = this._hidden ? "none" : "", this
    }
    hide() {
        return this.show(!1)
    }
    openAnimated(e = !0) {
        return this._setClosed(!e), this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame(() => {
            const t = this.$children.clientHeight;
            this.$children.style.height = t + "px", this.domElement.classList.add("transition");
            const i = r => {
                r.target === this.$children && (this.$children.style.height = "", this.domElement.classList.remove("transition"), this.$children.removeEventListener("transitionend", i))
            };
            this.$children.addEventListener("transitionend", i);
            const s = e ? this.$children.scrollHeight : 0;
            this.domElement.classList.toggle("closed", !e), requestAnimationFrame(() => {
                this.$children.style.height = s + "px"
            })
        }), this
    }
    title(e) {
        return this._title = e, this.$title.textContent = e, this
    }
    reset(e = !0) {
        return (e ? this.controllersRecursive() : this.controllers).forEach(i => i.reset()), this
    }
    onChange(e) {
        return this._onChange = e, this
    }
    _callOnChange(e) {
        this.parent && this.parent._callOnChange(e), this._onChange !== void 0 && this._onChange.call(this, {
            object: e.object,
            property: e.property,
            value: e.getValue(),
            controller: e
        })
    }
    onFinishChange(e) {
        return this._onFinishChange = e, this
    }
    _callOnFinishChange(e) {
        this.parent && this.parent._callOnFinishChange(e), this._onFinishChange !== void 0 && this._onFinishChange.call(this, {
            object: e.object,
            property: e.property,
            value: e.getValue(),
            controller: e
        })
    }
    onOpenClose(e) {
        return this._onOpenClose = e, this
    }
    _callOnOpenClose(e) {
        this.parent && this.parent._callOnOpenClose(e), this._onOpenClose !== void 0 && this._onOpenClose.call(this, e)
    }
    destroy() {
        this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)), this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement), Array.from(this.children).forEach(e => e.destroy())
    }
    controllersRecursive() {
        let e = Array.from(this.controllers);
        return this.folders.forEach(t => {
            e = e.concat(t.controllersRecursive())
        }), e
    }
    foldersRecursive() {
        let e = Array.from(this.folders);
        return this.folders.forEach(t => {
            e = e.concat(t.foldersRecursive())
        }), e
    }
}
class rc {
    constructor() {
        this.callbacks = {}, this.callbacks.base = {}
    }
    on(e, t) {
        return typeof e > "u" || e === "" ? (console.warn("wrong names"), !1) : typeof t > "u" ? (console.warn("wrong callback"), !1) : (this.resolveNames(e).forEach(s => {
            const r = this.resolveName(s);
            this.callbacks[r.namespace] instanceof Object || (this.callbacks[r.namespace] = {}), this.callbacks[r.namespace][r.value] instanceof Array || (this.callbacks[r.namespace][r.value] = []), this.callbacks[r.namespace][r.value].push(t)
        }), this)
    }
    off(e) {
        return typeof e > "u" || e === "" ? (console.warn("wrong name"), !1) : (this.resolveNames(e).forEach(i => {
            const s = this.resolveName(i);
            if (s.namespace !== "base" && s.value === "") delete this.callbacks[s.namespace];
            else if (s.namespace === "base")
                for (const r in this.callbacks) this.callbacks[r] instanceof Object && this.callbacks[r][s.value] instanceof Array && (delete this.callbacks[r][s.value], Object.keys(this.callbacks[r]).length === 0 && delete this.callbacks[r]);
            else this.callbacks[s.namespace] instanceof Object && this.callbacks[s.namespace][s.value] instanceof Array && (delete this.callbacks[s.namespace][s.value], Object.keys(this.callbacks[s.namespace]).length === 0 && delete this.callbacks[s.namespace])
        }), this)
    }
    trigger(e, t) {
        if (typeof e > "u" || e === "") return console.warn("wrong name"), !1;
        let i = null;
        const s = t instanceof Array ? t : [];
        let r = this.resolveNames(e);
        if (r = this.resolveName(r[0]), r.namespace === "base")
            for (const o in this.callbacks) this.callbacks[o] instanceof Object && this.callbacks[o][r.value] instanceof Array && this.callbacks[o][r.value].forEach(function (a) {
                a.apply(this, s)
            });
        else if (this.callbacks[r.namespace] instanceof Object) {
            if (r.value === "") return console.warn("wrong name"), this;
            this.callbacks[r.namespace][r.value].forEach(function (o) {
                o.apply(this, s)
            })
        }
        return i
    }
    resolveNames(e) {
        let t = e;
        return t = t.replace(/[^a-zA-Z0-9 ,/.]/g, ""), t = t.replace(/[,/]+/g, " "), t = t.split(" "), t
    }
    resolveName(e) {
        const t = {},
            i = e.split(".");
        return t.original = e, t.value = i[0], t.namespace = "base", i.length > 1 && i[1] !== "" && (t.namespace = i[1]), t
    }
}
const Yr = class Yr extends rc {
    static getInstance() {
        return Yr._instance || new Yr
    }
    constructor() {
        if (Yr._instance) return Yr._instance;
        super(), Yr._instance = this, this.width = window.innerWidth, this.height = window.innerHeight, this.pixelRatio = Math.min(window.devicePixelRatio, 2), window.addEventListener("resize", () => {
            this.width = window.innerWidth, this.height = window.innerHeight, this.pixelRatio = Math.min(window.devicePixelRatio, 2), this.trigger("resize")
        })
    }
};
Ae(Yr, "_instance", null);
let Ss = Yr;
const Xr = class Xr {
    constructor() {
        Ae(this, "experience", ai.getInstance());
        Ae(this, "sizes", Ss.getInstance());
        if (Xr._instance) return Xr._instance;
        Xr._instance = this, this.active = window.location.hash === "#debug", this.active && (this.panel = new y0, this.stats = new qN, this.stats.showPanel(0), document.body.appendChild(this.stats.dom))
    }
    static getInstance() {
        return Xr._instance || new Xr
    }
    createDebugTexture(e) {
        this.debugTexture = e, this.cameraOrtho = new ju(-this.sizes.width / 2, this.sizes.width / 2, this.sizes.height / 2, -this.sizes.height / 2, 1, 10), this.cameraOrtho.position.z = 10, this.sceneOrtho = new d0, e.colorSpace = Wt;
        const t = new Tw({
            map: e
        }),
            i = 128,
            s = 128;
        this.sprite = new gF(t), this.sprite.center.set(0, 0), this.sprite.scale.set(i, s, 1), this.sceneOrtho.add(this.sprite), this.updateSprite()
    }
    updateSprite() {
        if (!this.debugTexture) return;
        this.cameraOrtho.left = -this.sizes.width / 2, this.cameraOrtho.right = this.sizes.width / 2, this.cameraOrtho.top = this.sizes.height / 2, this.cameraOrtho.bottom = -this.sizes.height / 2, this.cameraOrtho.updateProjectionMatrix();
        const e = this.sizes.width / 2,
            t = this.sizes.height / 2;
        this.sprite.position.set(-e, -t, 1)
    }
    resize() {
        this.updateSprite()
    }
    update(e) {
        var t;
        this.debugTexture && ((t = this.experience) == null || t.renderer.instance.render(this.sceneOrtho, this.cameraOrtho))
    }
};
Ae(Xr, "_instance", null);
let $s = Xr;
const Kr = class Kr extends rc {
    static getInstance() {
        return Kr._instance || new Kr
    }
    constructor() {
        if (Kr._instance) return Kr._instance;
        super(), Kr._instance = this, this.start = Date.now(), this.current = this.start, this.playing = !0, this.elapsed = 0, this.delta = .016666666666666666, this.timeline = bt.timeline({
            paused: !0
        }), window.requestAnimationFrame(() => {
            this.tick()
        })
    }
    tick() {
        const e = Date.now();
        this.delta = Math.min((e - this.current) * .001, .016), this.current = e, this.elapsed = (this.current - this.start) * .001, this.delta > .06 && (this.delta = .06), this.timeline.time(this.elapsed), this.trigger("tick"), window.requestAnimationFrame(() => {
            this.tick()
        })
    }
    reset() {
        this.start = Date.now(), this.current = this.start, this.elapsed = 0
    }
};
Ae(Kr, "_instance", null);
let cf = Kr;
var Tb = !1,
    na, Rg, Pg, Ch, Sh, $w, Mh, Dg, Lg, kg, jw, Fg, Ng, Yw, Xw;

function An() {
    if (!Tb) {
        Tb = !0;
        var n = navigator.userAgent,
            e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(n),
            t = /(Mac OS X)|(Windows)|(Linux)/.exec(n);
        if (Fg = /\b(iPhone|iP[ao]d)/.exec(n), Ng = /\b(iP[ao]d)/.exec(n), kg = /Android/i.exec(n), Yw = /FBAN\/\w+;/i.exec(n), Xw = /Mobile/i.exec(n), jw = !!/Win64/.exec(n), e) {
            na = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN, na && document && document.documentMode && (na = document.documentMode);
            var i = /(?:Trident\/(\d+.\d+))/.exec(n);
            $w = i ? parseFloat(i[1]) + 4 : na, Rg = e[2] ? parseFloat(e[2]) : NaN, Pg = e[3] ? parseFloat(e[3]) : NaN, Ch = e[4] ? parseFloat(e[4]) : NaN, Ch ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(n), Sh = e && e[1] ? parseFloat(e[1]) : NaN) : Sh = NaN
        } else na = Rg = Pg = Sh = Ch = NaN;
        if (t) {
            if (t[1]) {
                var s = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(n);
                Mh = s ? parseFloat(s[1].replace("_", ".")) : !0
            } else Mh = !1;
            Dg = !!t[2], Lg = !!t[3]
        } else Mh = Dg = Lg = !1
    }
}
var Og = {
    ie: function () {
        return An() || na
    },
    ieCompatibilityMode: function () {
        return An() || $w > na
    },
    ie64: function () {
        return Og.ie() && jw
    },
    firefox: function () {
        return An() || Rg
    },
    opera: function () {
        return An() || Pg
    },
    webkit: function () {
        return An() || Ch
    },
    safari: function () {
        return Og.webkit()
    },
    chrome: function () {
        return An() || Sh
    },
    windows: function () {
        return An() || Dg
    },
    osx: function () {
        return An() || Mh
    },
    linux: function () {
        return An() || Lg
    },
    iphone: function () {
        return An() || Fg
    },
    mobile: function () {
        return An() || Fg || Ng || kg || Xw
    },
    nativeApp: function () {
        return An() || Yw
    },
    android: function () {
        return An() || kg
    },
    ipad: function () {
        return An() || Ng
    }
},
    r3 = Og,
    Hd = !!(typeof window < "u" && window.document && window.document.createElement),
    o3 = {
        canUseDOM: Hd,
        canUseWorkers: typeof Worker < "u",
        canUseEventListeners: Hd && !!(window.addEventListener || window.attachEvent),
        canUseViewport: Hd && !!window.screen,
        isInWorker: !Hd
    },
    a3 = o3,
    Kw = a3,
    Jw;
Kw.canUseDOM && (Jw = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function l3(n, e) {
    if (!Kw.canUseDOM || e && !("addEventListener" in document)) return !1;
    var t = "on" + n,
        i = t in document;
    if (!i) {
        var s = document.createElement("div");
        s.setAttribute(t, "return;"), i = typeof s[t] == "function"
    }
    return !i && Jw && n === "wheel" && (i = document.implementation.hasFeature("Events.wheel", "3.0")), i
}
var c3 = l3,
    u3 = r3,
    d3 = c3,
    Ib = 10,
    Bb = 40,
    Rb = 800;

function h3(n) {
    var e = 0,
        t = 0,
        i = 0,
        s = 0;
    return "detail" in n && (t = n.detail), "wheelDelta" in n && (t = -n.wheelDelta / 120), "wheelDeltaY" in n && (t = -n.wheelDeltaY / 120), "wheelDeltaX" in n && (e = -n.wheelDeltaX / 120), "axis" in n && n.axis === n.HORIZONTAL_AXIS && (e = t, t = 0), i = e * Ib, s = t * Ib, "deltaY" in n && (s = n.deltaY), "deltaX" in n && (i = n.deltaX), (i || s) && n.deltaMode && (n.deltaMode == 1 ? (i *= Bb, s *= Bb) : (i *= Rb, s *= Rb)), i && !e && (e = i < 1 ? -1 : 1), s && !t && (t = s < 1 ? -1 : 1), {
        spinX: e,
        spinY: t,
        pixelX: i,
        pixelY: s
    }
}
h3.getEventType = function () {
    return u3.firefox() ? "DOMMouseScroll" : d3("wheel") ? "wheel" : "mousewheel"
};
const Jr = class Jr {
    constructor() {
        Ae(this, "_onMouseMoved", e => {
            this.clientX = e.clientX, this.clientY = e.clientY, this.cursor.x = e.clientX / this.sizes.width * 2 - 1, this.cursor.y = -(e.clientY / this.sizes.height) * 2 + 1, this.cursor.side = e.clientX > this.sizes.width / 2 ? "right" : "left", this.previosCursor3D = this.cursor3D.clone(), this.cursor3D = this.projectNDCTo3D(this.cursor.x, this.cursor.y), this.cursorDirection = this.cursor3D.clone().sub(this.previosCursor3D).normalize()
        });
        Ae(this, "_onTouchStart", e => {
            this._onTouchMoved(e)
        });
        Ae(this, "_onTouchMoved", e => {
            this.cursor.x = e.touches[0].clientX / this.sizes.width * 2 - 1, this.cursor.y = -(e.touches[0].clientY / this.sizes.height) * 2 + 1, this.cursor.side = e.touches[0].clientX > this.sizes.width / 2 ? "right" : "left", this.previosCursor3D = this.cursor3D.clone(), this.cursor3D = this.projectNDCTo3D(this.cursor.x, this.cursor.y), this.cursorDirection = this.cursor3D.clone().sub(this.previosCursor3D).normalize()
        });
        if (Jr._instance) return Jr._instance;
        Jr._instance = this, this.experience = ai.getInstance(), this.sizes = Ss.getInstance(), this.experience.on("classesReady", () => {
            this.camera = this.experience.camera.instance
        }), this.cursor = {
            x: 0,
            y: 0,
            side: "left"
        }, this.cursor3D = new z, this.cursorDirection = new z, this.clientX = 0, this.clientY = 0, this.init()
    }
    static getInstance() {
        return Jr._instance || new Jr
    }
    init() {
        window.addEventListener("mousemove", this._onMouseMoved), window.addEventListener("touchstart", this._onTouchStart), window.addEventListener("touchmove", this._onTouchMoved)
    }
    postInit() { }
    projectNDCTo3D(e, t) {
        const i = new z(e, t, .5);
        i.unproject(this.camera);
        const s = i.sub(this.camera.position).normalize(),
            r = new z;
        this.camera.getWorldDirection(r);
        const o = -this.camera.position.dot(r) / s.dot(r);
        return this.camera.position.clone().add(s.multiplyScalar(o))
    }
    getNDCFrom3d(e, t, i) {
        const s = new z(e, t, i);
        return s.project(this.camera), s
    }
};
Ae(Jr, "_instance", null);
let Pu = Jr;
const Pb = {
    type: "change"
},
    sm = {
        type: "start"
    },
    Db = {
        type: "end"
    },
    Vd = new Wu,
    Lb = new $r,
    f3 = Math.cos(70 * lr.DEG2RAD);
class p3 extends Io {
    constructor(e, t) {
        super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new z, this.cursor = new z, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }, this.mouseButtons = {
            LEFT: La.ROTATE,
            MIDDLE: La.DOLLY,
            RIGHT: La.PAN
        }, this.touches = {
            ONE: ka.ROTATE,
            TWO: ka.DOLLY_PAN
        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
            return a.phi
        }, this.getAzimuthalAngle = function () {
            return a.theta
        }, this.getDistance = function () {
            return this.object.position.distanceTo(this.target)
        }, this.listenToKeyEvents = function (B) {
            B.addEventListener("keydown", me), this._domElementKeyEvents = B
        }, this.stopListenToKeyEvents = function () {
            this._domElementKeyEvents.removeEventListener("keydown", me), this._domElementKeyEvents = null
        }, this.saveState = function () {
            i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom
        }, this.reset = function () {
            i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(Pb), i.update(), r = s.NONE
        }, this.update = function () {
            const B = new z,
                ee = new Tn().setFromUnitVectors(e.up, new z(0, 1, 0)),
                pe = ee.clone().invert(),
                be = new z,
                Se = new Tn,
                et = new z,
                tt = 2 * Math.PI;
            return function (Tt = null) {
                const mt = i.object.position;
                B.copy(mt).sub(i.target), B.applyQuaternion(ee), a.setFromVector3(B), i.autoRotate && r === s.NONE && T(y(Tt)), i.enableDamping ? (a.theta += l.theta * i.dampingFactor, a.phi += l.phi * i.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
                let Ne = i.minAzimuthAngle,
                    De = i.maxAzimuthAngle;
                isFinite(Ne) && isFinite(De) && (Ne < -Math.PI ? Ne += tt : Ne > Math.PI && (Ne -= tt), De < -Math.PI ? De += tt : De > Math.PI && (De -= tt), Ne <= De ? a.theta = Math.max(Ne, Math.min(De, a.theta)) : a.theta = a.theta > (Ne + De) / 2 ? Math.max(Ne, a.theta) : Math.min(De, a.theta)), a.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, a.phi)), a.makeSafe(), i.enableDamping === !0 ? i.target.addScaledVector(u, i.dampingFactor) : i.target.add(u), i.target.sub(i.cursor), i.target.clampLength(i.minTargetRadius, i.maxTargetRadius), i.target.add(i.cursor);
                let it = !1;
                if (i.zoomToCursor && E || i.object.isOrthographicCamera) a.radius = k(a.radius);
                else {
                    const Ee = a.radius;
                    a.radius = k(a.radius * c), it = Ee != a.radius
                }
                if (B.setFromSpherical(a), B.applyQuaternion(pe), mt.copy(i.target).add(B), i.object.lookAt(i.target), i.enableDamping === !0 ? (l.theta *= 1 - i.dampingFactor, l.phi *= 1 - i.dampingFactor, u.multiplyScalar(1 - i.dampingFactor)) : (l.set(0, 0, 0), u.set(0, 0, 0)), i.zoomToCursor && E) {
                    let Ee = null;
                    if (i.object.isPerspectiveCamera) {
                        const $e = B.length();
                        Ee = k($e * c);
                        const Qe = $e - Ee;
                        i.object.position.addScaledVector(b, Qe), i.object.updateMatrixWorld(), it = !!Qe
                    } else if (i.object.isOrthographicCamera) {
                        const $e = new z(w.x, w.y, 0);
                        $e.unproject(i.object);
                        const Qe = i.object.zoom;
                        i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), i.object.updateProjectionMatrix(), it = Qe !== i.object.zoom;
                        const je = new z(w.x, w.y, 0);
                        je.unproject(i.object), i.object.position.sub(je).add($e), i.object.updateMatrixWorld(), Ee = B.length()
                    } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), i.zoomToCursor = !1;
                    Ee !== null && (this.screenSpacePanning ? i.target.set(0, 0, -1).transformDirection(i.object.matrix).multiplyScalar(Ee).add(i.object.position) : (Vd.origin.copy(i.object.position), Vd.direction.set(0, 0, -1).transformDirection(i.object.matrix), Math.abs(i.object.up.dot(Vd.direction)) < f3 ? e.lookAt(i.target) : (Lb.setFromNormalAndCoplanarPoint(i.object.up, i.target), Vd.intersectPlane(Lb, i.target))))
                } else if (i.object.isOrthographicCamera) {
                    const Ee = i.object.zoom;
                    i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), Ee !== i.object.zoom && (i.object.updateProjectionMatrix(), it = !0)
                }
                return c = 1, E = !1, it || be.distanceToSquared(i.object.position) > o || 8 * (1 - Se.dot(i.object.quaternion)) > o || et.distanceToSquared(i.target) > o ? (i.dispatchEvent(Pb), be.copy(i.object.position), Se.copy(i.object.quaternion), et.copy(i.target), !0) : !1
            }
        }(), this.dispose = function () {
            i.domElement.removeEventListener("contextmenu", we), i.domElement.removeEventListener("pointerdown", H), i.domElement.removeEventListener("pointercancel", j), i.domElement.removeEventListener("wheel", re), i.domElement.removeEventListener("pointermove", V), i.domElement.removeEventListener("pointerup", j), i.domElement.getRootNode().removeEventListener("keydown", ge, {
                capture: !0
            }), i._domElementKeyEvents !== null && (i._domElementKeyEvents.removeEventListener("keydown", me), i._domElementKeyEvents = null)
        };
        const i = this,
            s = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
        let r = s.NONE;
        const o = 1e-6,
            a = new Sb,
            l = new Sb;
        let c = 1;
        const u = new z,
            d = new _e,
            h = new _e,
            f = new _e,
            m = new _e,
            g = new _e,
            A = new _e,
            p = new _e,
            v = new _e,
            _ = new _e,
            b = new z,
            w = new _e;
        let E = !1;
        const C = [],
            S = {};
        let x = !1;

        function y(B) {
            return B !== null ? 2 * Math.PI / 60 * i.autoRotateSpeed * B : 2 * Math.PI / 60 / 60 * i.autoRotateSpeed
        }

        function P(B) {
            const ee = Math.abs(B * .01);
            return Math.pow(.95, i.zoomSpeed * ee)
        }

        function T(B) {
            l.theta -= B
        }

        function R(B) {
            l.phi -= B
        }
        const D = function () {
            const B = new z;
            return function (pe, be) {
                B.setFromMatrixColumn(be, 0), B.multiplyScalar(-pe), u.add(B)
            }
        }(),
            U = function () {
                const B = new z;
                return function (pe, be) {
                    i.screenSpacePanning === !0 ? B.setFromMatrixColumn(be, 1) : (B.setFromMatrixColumn(be, 0), B.crossVectors(i.object.up, B)), B.multiplyScalar(pe), u.add(B)
                }
            }(),
            Q = function () {
                const B = new z;
                return function (pe, be) {
                    const Se = i.domElement;
                    if (i.object.isPerspectiveCamera) {
                        const et = i.object.position;
                        B.copy(et).sub(i.target);
                        let tt = B.length();
                        tt *= Math.tan(i.object.fov / 2 * Math.PI / 180), D(2 * pe * tt / Se.clientHeight, i.object.matrix), U(2 * be * tt / Se.clientHeight, i.object.matrix)
                    } else i.object.isOrthographicCamera ? (D(pe * (i.object.right - i.object.left) / i.object.zoom / Se.clientWidth, i.object.matrix), U(be * (i.object.top - i.object.bottom) / i.object.zoom / Se.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1)
                }
            }();

        function F(B) {
            i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? c /= B : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
        }

        function L(B) {
            i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? c *= B : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
        }

        function W(B, ee) {
            if (!i.zoomToCursor) return;
            E = !0;
            const pe = i.domElement.getBoundingClientRect(),
                be = B - pe.left,
                Se = ee - pe.top,
                et = pe.width,
                tt = pe.height;
            w.x = be / et * 2 - 1, w.y = -(Se / tt) * 2 + 1, b.set(w.x, w.y, 1).unproject(i.object).sub(i.object.position).normalize()
        }

        function k(B) {
            return Math.max(i.minDistance, Math.min(i.maxDistance, B))
        }

        function $(B) {
            d.set(B.clientX, B.clientY)
        }

        function X(B) {
            W(B.clientX, B.clientX), p.set(B.clientX, B.clientY)
        }

        function le(B) {
            m.set(B.clientX, B.clientY)
        }

        function K(B) {
            h.set(B.clientX, B.clientY), f.subVectors(h, d).multiplyScalar(i.rotateSpeed);
            const ee = i.domElement;
            T(2 * Math.PI * f.x / ee.clientHeight), R(2 * Math.PI * f.y / ee.clientHeight), d.copy(h), i.update()
        }

        function te(B) {
            v.set(B.clientX, B.clientY), _.subVectors(v, p), _.y > 0 ? F(P(_.y)) : _.y < 0 && L(P(_.y)), p.copy(v), i.update()
        }

        function ue(B) {
            g.set(B.clientX, B.clientY), A.subVectors(g, m).multiplyScalar(i.panSpeed), Q(A.x, A.y), m.copy(g), i.update()
        }

        function fe(B) {
            W(B.clientX, B.clientY), B.deltaY < 0 ? L(P(B.deltaY)) : B.deltaY > 0 && F(P(B.deltaY)), i.update()
        }

        function Me(B) {
            let ee = !1;
            switch (B.code) {
                case i.keys.UP:
                    B.ctrlKey || B.metaKey || B.shiftKey ? R(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(0, i.keyPanSpeed), ee = !0;
                    break;
                case i.keys.BOTTOM:
                    B.ctrlKey || B.metaKey || B.shiftKey ? R(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(0, -i.keyPanSpeed), ee = !0;
                    break;
                case i.keys.LEFT:
                    B.ctrlKey || B.metaKey || B.shiftKey ? T(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(i.keyPanSpeed, 0), ee = !0;
                    break;
                case i.keys.RIGHT:
                    B.ctrlKey || B.metaKey || B.shiftKey ? T(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : Q(-i.keyPanSpeed, 0), ee = !0;
                    break
            }
            ee && (B.preventDefault(), i.update())
        }

        function Be(B) {
            if (C.length === 1) d.set(B.pageX, B.pageY);
            else {
                const ee = We(B),
                    pe = .5 * (B.pageX + ee.x),
                    be = .5 * (B.pageY + ee.y);
                d.set(pe, be)
            }
        }

        function Ce(B) {
            if (C.length === 1) m.set(B.pageX, B.pageY);
            else {
                const ee = We(B),
                    pe = .5 * (B.pageX + ee.x),
                    be = .5 * (B.pageY + ee.y);
                m.set(pe, be)
            }
        }

        function Z(B) {
            const ee = We(B),
                pe = B.pageX - ee.x,
                be = B.pageY - ee.y,
                Se = Math.sqrt(pe * pe + be * be);
            p.set(0, Se)
        }

        function ke(B) {
            i.enableZoom && Z(B), i.enablePan && Ce(B)
        }

        function N(B) {
            i.enableZoom && Z(B), i.enableRotate && Be(B)
        }

        function G(B) {
            if (C.length == 1) h.set(B.pageX, B.pageY);
            else {
                const pe = We(B),
                    be = .5 * (B.pageX + pe.x),
                    Se = .5 * (B.pageY + pe.y);
                h.set(be, Se)
            }
            f.subVectors(h, d).multiplyScalar(i.rotateSpeed);
            const ee = i.domElement;
            T(2 * Math.PI * f.x / ee.clientHeight), R(2 * Math.PI * f.y / ee.clientHeight), d.copy(h)
        }

        function Y(B) {
            if (C.length === 1) g.set(B.pageX, B.pageY);
            else {
                const ee = We(B),
                    pe = .5 * (B.pageX + ee.x),
                    be = .5 * (B.pageY + ee.y);
                g.set(pe, be)
            }
            A.subVectors(g, m).multiplyScalar(i.panSpeed), Q(A.x, A.y), m.copy(g)
        }

        function se(B) {
            const ee = We(B),
                pe = B.pageX - ee.x,
                be = B.pageY - ee.y,
                Se = Math.sqrt(pe * pe + be * be);
            v.set(0, Se), _.set(0, Math.pow(v.y / p.y, i.zoomSpeed)), F(_.y), p.copy(v);
            const et = (B.pageX + ee.x) * .5,
                tt = (B.pageY + ee.y) * .5;
            W(et, tt)
        }

        function M(B) {
            i.enableZoom && se(B), i.enablePan && Y(B)
        }

        function I(B) {
            i.enableZoom && se(B), i.enableRotate && G(B)
        }

        function H(B) {
            i.enabled !== !1 && (C.length === 0 && (i.domElement.setPointerCapture(B.pointerId), i.domElement.addEventListener("pointermove", V), i.domElement.addEventListener("pointerup", j)), !Ve(B) && (Pe(B), B.pointerType === "touch" ? xe(B) : q(B)))
        }

        function V(B) {
            i.enabled !== !1 && (B.pointerType === "touch" ? ve(B) : he(B))
        }

        function j(B) {
            switch (Ke(B), C.length) {
                case 0:
                    i.domElement.releasePointerCapture(B.pointerId), i.domElement.removeEventListener("pointermove", V), i.domElement.removeEventListener("pointerup", j), i.dispatchEvent(Db), r = s.NONE;
                    break;
                case 1:
                    const ee = C[0],
                        pe = S[ee];
                    xe({
                        pointerId: ee,
                        pageX: pe.x,
                        pageY: pe.y
                    });
                    break
            }
        }

        function q(B) {
            let ee;
            switch (B.button) {
                case 0:
                    ee = i.mouseButtons.LEFT;
                    break;
                case 1:
                    ee = i.mouseButtons.MIDDLE;
                    break;
                case 2:
                    ee = i.mouseButtons.RIGHT;
                    break;
                default:
                    ee = -1
            }
            switch (ee) {
                case La.DOLLY:
                    if (i.enableZoom === !1) return;
                    X(B), r = s.DOLLY;
                    break;
                case La.ROTATE:
                    if (B.ctrlKey || B.metaKey || B.shiftKey) {
                        if (i.enablePan === !1) return;
                        le(B), r = s.PAN
                    } else {
                        if (i.enableRotate === !1) return;
                        $(B), r = s.ROTATE
                    }
                    break;
                case La.PAN:
                    if (B.ctrlKey || B.metaKey || B.shiftKey) {
                        if (i.enableRotate === !1) return;
                        $(B), r = s.ROTATE
                    } else {
                        if (i.enablePan === !1) return;
                        le(B), r = s.PAN
                    }
                    break;
                default:
                    r = s.NONE
            }
            r !== s.NONE && i.dispatchEvent(sm)
        }

        function he(B) {
            switch (r) {
                case s.ROTATE:
                    if (i.enableRotate === !1) return;
                    K(B);
                    break;
                case s.DOLLY:
                    if (i.enableZoom === !1) return;
                    te(B);
                    break;
                case s.PAN:
                    if (i.enablePan === !1) return;
                    ue(B);
                    break
            }
        }

        function re(B) {
            i.enabled === !1 || i.enableZoom === !1 || r !== s.NONE || (B.preventDefault(), i.dispatchEvent(sm), fe(de(B)), i.dispatchEvent(Db))
        }

        function de(B) {
            const ee = B.deltaMode,
                pe = {
                    clientX: B.clientX,
                    clientY: B.clientY,
                    deltaY: B.deltaY
                };
            switch (ee) {
                case 1:
                    pe.deltaY *= 16;
                    break;
                case 2:
                    pe.deltaY *= 100;
                    break
            }
            return B.ctrlKey && !x && (pe.deltaY *= 10), pe
        }

        function ge(B) {
            B.key === "Control" && (x = !0, i.domElement.getRootNode().addEventListener("keyup", ce, {
                passive: !0,
                capture: !0
            }))
        }

        function ce(B) {
            B.key === "Control" && (x = !1, i.domElement.getRootNode().removeEventListener("keyup", ce, {
                passive: !0,
                capture: !0
            }))
        }

        function me(B) {
            i.enabled === !1 || i.enablePan === !1 || Me(B)
        }

        function xe(B) {
            switch (Le(B), C.length) {
                case 1:
                    switch (i.touches.ONE) {
                        case ka.ROTATE:
                            if (i.enableRotate === !1) return;
                            Be(B), r = s.TOUCH_ROTATE;
                            break;
                        case ka.PAN:
                            if (i.enablePan === !1) return;
                            Ce(B), r = s.TOUCH_PAN;
                            break;
                        default:
                            r = s.NONE
                    }
                    break;
                case 2:
                    switch (i.touches.TWO) {
                        case ka.DOLLY_PAN:
                            if (i.enableZoom === !1 && i.enablePan === !1) return;
                            ke(B), r = s.TOUCH_DOLLY_PAN;
                            break;
                        case ka.DOLLY_ROTATE:
                            if (i.enableZoom === !1 && i.enableRotate === !1) return;
                            N(B), r = s.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            r = s.NONE
                    }
                    break;
                default:
                    r = s.NONE
            }
            r !== s.NONE && i.dispatchEvent(sm)
        }

        function ve(B) {
            switch (Le(B), r) {
                case s.TOUCH_ROTATE:
                    if (i.enableRotate === !1) return;
                    G(B), i.update();
                    break;
                case s.TOUCH_PAN:
                    if (i.enablePan === !1) return;
                    Y(B), i.update();
                    break;
                case s.TOUCH_DOLLY_PAN:
                    if (i.enableZoom === !1 && i.enablePan === !1) return;
                    M(B), i.update();
                    break;
                case s.TOUCH_DOLLY_ROTATE:
                    if (i.enableZoom === !1 && i.enableRotate === !1) return;
                    I(B), i.update();
                    break;
                default:
                    r = s.NONE
            }
        }

        function we(B) {
            i.enabled !== !1 && B.preventDefault()
        }

        function Pe(B) {
            C.push(B.pointerId)
        }

        function Ke(B) {
            delete S[B.pointerId];
            for (let ee = 0; ee < C.length; ee++)
                if (C[ee] == B.pointerId) {
                    C.splice(ee, 1);
                    return
                }
        }

        function Ve(B) {
            for (let ee = 0; ee < C.length; ee++)
                if (C[ee] == B.pointerId) return !0;
            return !1
        }

        function Le(B) {
            let ee = S[B.pointerId];
            ee === void 0 && (ee = new _e, S[B.pointerId] = ee), ee.set(B.pageX, B.pageY)
        }

        function We(B) {
            const ee = B.pointerId === C[0] ? C[1] : C[0];
            return S[ee]
        }
        i.domElement.addEventListener("contextmenu", we), i.domElement.addEventListener("pointerdown", H), i.domElement.addEventListener("pointercancel", j), i.domElement.addEventListener("wheel", re, {
            passive: !1
        }), i.domElement.getRootNode().addEventListener("keydown", ge, {
            passive: !0,
            capture: !0
        }), this.update()
    }
}
class m3 {
    constructor() {
        this.experience = new ai, this.input = Pu.getInstance(), this.sizes = this.experience.sizes, this.scene = this.experience.scene, this.time = this.experience.time, this.canvas = this.experience.canvas, this.timeline = this.experience.timeline, this.cursorEnabled = !1, this.lerpVector = new z, this.lerpTarget = new z, this.setInstance(), this.setControls()
    }
    setInstance() {
        this.instance = new cn(25, this.sizes.width / this.sizes.height, .1, 3e3), this.defaultCameraPosition = new z(-.5, 1.5, 7), this.instance.position.copy(this.defaultCameraPosition), this.instance.lookAt(new z(0, 0, 0)), this.lerpVector.copy(this.instance.position), this.lerpTarget.copy(this.instance.position), this.scene.add(this.instance)
    }
    setControls() {
        this.controls = new p3(this.instance, this.canvas), this.controls.enableDamping = !0, this.controls.minDistance = 0, this.controls.maxDistance = 500, this.controls.enabled = !0, this.controls.target = new z(0, 0, 0)
    }
    resize() {
        this.instance.aspect = this.sizes.width / this.sizes.height, this.instance.updateProjectionMatrix()
    }
    update() {
        this.instance.position.x = lr.damp(this.instance.position.x, this.input.cursor.x * .5 * 5, 3, this.time.delta), this.instance.position.y = lr.damp(this.instance.position.y, this.input.cursor.y * .5 * 5, 3, this.time.delta), this.controls.update()
    }
    animateCameraPosition() { }
}
class g3 {
    constructor() {
        this.experience = new ai, this.canvas = this.experience.canvas, this.sizes = this.experience.sizes, this.scene = this.experience.scene, this.camera = this.experience.camera, this.debug = this.experience.debug, this.resources = this.experience.resources, this.html = this.experience.html, this.setInstance(), this.setDebug()
    }
    setInstance() {
        this.clearColor = "#010101", this.instance = new mF({
            canvas: this.canvas,
            powerPreference: "high-performance",
            antialias: !1,
            alpha: !1,
            stencil: !1,
            depth: !0,
            useLegacyLights: !1,
            physicallyCorrectLights: !0
        }), this.instance.toneMapping = Zh, this.instance.outputColorSpace = Wt, this.instance.setSize(this.sizes.width, this.sizes.height), this.instance.setPixelRatio(Math.min(this.sizes.pixelRatio, 2)), this.instance.setClearColor(this.clearColor, 1), this.instance.setSize(this.sizes.width, this.sizes.height)
    }
    setDebug() {
        this.debug.active && this.debug.panel && (this.debugFolder = this.debug.panel.addFolder("Renderer"), this.debugFolder.add(this.instance, "toneMapping", {
            No: _r,
            Linear: KA,
            Reinhard: JA,
            Cineon: ZA,
            ACESFilmic: e0,
            AgXToneMapping: t0,
            NeutralToneMapping: Zh
        }).name("Tone Mapping"), this.debugFolder.add(this.instance, "toneMappingExposure").min(0).max(2).step(.01).name("Tone Mapping Exposure"))
    }
    update() {
        this.debug.active ? this.debugRender() : this.productionRender()
    }
    productionRender() {
        this.instance.render(this.scene, this.camera.instance)
    }
    debugRender() {
        this.instance.autoClear = !1, this.instance.clearColor(this.clearColor), this.instance.render(this.scene, this.camera.instance), this.instance.clearDepth()
    }
    resize() {
        this.instance.setSize(this.sizes.width, this.sizes.height), this.instance.setPixelRatio(this.sizes.pixelRatio)
    }
    destroy() { }
}
class A3 {
    constructor() {
        this.experience = new ai, this.scene = this.experience.scene, this.resources = this.experience.resources, this.debug = this.experience.debug, this.scene.colorSpace = Wt, this.setAmbientLight(), this.setDirectionalLight(), this.setDebug()
    }
    setAmbientLight() {
        this.ambientLight = new yN("#ffffff", .05), this.scene.add(this.ambientLight)
    }
    setDirectionalLight() {
        this.directionalLight = new Hw("#ffffff", 1), this.directionalLight.position.set(0, 5, 5), this.scene.add(this.directionalLight)
    }
    setEnvironmentMap() { }
    setDebug() {
        this.debug.active
    }
}
class Zw extends HTMLElement {
    constructor(e, t) {
        super(), this.camera = e, this.options = Object.assign({
            size: 90,
            padding: 8,
            bubbleSizePrimary: 8,
            bubbleSizeSeconday: 6,
            showSecondary: !0,
            lineWidth: 2,
            fontSize: "11px",
            fontFamily: "arial",
            fontWeight: "bold",
            fontColor: "#151515",
            fontYAdjust: 0,
            colors: {
                x: ["#f73c3c", "#942424"],
                y: ["#6ccb26", "#417a17"],
                z: ["#178cf0", "#0e5490"]
            }
        }, t), this.onAxisSelected = null, this.bubbles = [{
            axis: "x",
            direction: new z(1, 0, 0),
            size: this.options.bubbleSizePrimary,
            color: this.options.colors.x,
            line: this.options.lineWidth,
            label: "X"
        }, {
            axis: "y",
            direction: new z(0, 1, 0),
            size: this.options.bubbleSizePrimary,
            color: this.options.colors.y,
            line: this.options.lineWidth,
            label: "Y"
        }, {
            axis: "z",
            direction: new z(0, 0, 1),
            size: this.options.bubbleSizePrimary,
            color: this.options.colors.z,
            line: this.options.lineWidth,
            label: "Z"
        }, {
            axis: "-x",
            direction: new z(-1, 0, 0),
            size: this.options.bubbleSizeSeconday,
            color: this.options.colors.x
        }, {
            axis: "-y",
            direction: new z(0, -1, 0),
            size: this.options.bubbleSizeSeconday,
            color: this.options.colors.y
        }, {
            axis: "-z",
            direction: new z(0, 0, -1),
            size: this.options.bubbleSizeSeconday,
            color: this.options.colors.z
        }], this.center = new z(this.options.size / 2, this.options.size / 2, 0), this.selectedAxis = null, this.innerHTML = "<canvas width='" + this.options.size + "' height='" + this.options.size + "'></canvas>", this.onMouseMove = this.onMouseMove.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onMouseClick = this.onMouseClick.bind(this)
    }
    connectedCallback() {
        this.canvas = this.querySelector("canvas"), this.context = this.canvas.getContext("2d"), this.canvas.addEventListener("mousemove", this.onMouseMove, !1), this.canvas.addEventListener("mouseout", this.onMouseOut, !1), this.canvas.addEventListener("click", this.onMouseClick, !1)
    }
    disconnectedCallback() {
        this.canvas.removeEventListener("mousemove", this.onMouseMove, !1), this.canvas.removeEventListener("mouseout", this.onMouseOut, !1), this.canvas.removeEventListener("click", this.onMouseClick, !1)
    }
    onMouseMove(e) {
        const t = this.canvas.getBoundingClientRect();
        this.mouse = new z(e.clientX - t.left, e.clientY - t.top, 0)
    }
    onMouseOut(e) {
        this.mouse = null
    }
    onMouseClick(e) {
        this.onAxisSelected && typeof this.onAxisSelected == "function" && this.onAxisSelected({
            axis: this.selectedAxis.axis,
            direction: this.selectedAxis.direction.clone()
        })
    }
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
    }
    drawCircle(e, t = 10, i = "#FF0000") {
        this.context.beginPath(), this.context.arc(e.x, e.y, t, 0, 2 * Math.PI, !1), this.context.fillStyle = i, this.context.fill(), this.context.closePath()
    }
    drawLine(e, t, i = 1, s = "#FF0000") {
        this.context.beginPath(), this.context.moveTo(e.x, e.y), this.context.lineTo(t.x, t.y), this.context.lineWidth = i, this.context.strokeStyle = s, this.context.stroke(), this.context.closePath()
    }
    update() {
        this.clear();
        let t = new Xe().makeRotationFromEuler(this.camera.rotation).clone().invert();
        for (var i of this.bubbles) i.position = this.getBubblePosition(i.direction.clone().applyMatrix4(t));
        const s = [];
        for (let r in this.bubbles) (this.options.showSecondary === !0 || r[0] !== "-") && s.push(this.bubbles[r]);
        if (s.sort((r, o) => r.position.z > o.position.z ? 1 : -1), this.selectedAxis = null, this.mouse) {
            let r = 1 / 0;
            for (var i of s) {
                const a = this.mouse.distanceTo(i.position);
                (a < r || a < i.size) && (r = a, this.selectedAxis = i)
            }
        }
        this.drawLayers(s)
    }
    drawLayers(e) {
        for (let t of e) {
            let i = t.color;
            this.selectedAxis === t ? i = "#FFFFFF" : t.position.z >= -.01 ? i = t.color[0] : i = t.color[1], this.drawCircle(t.position, t.size, i), t.line && this.drawLine(this.center, t.position, t.line, i), t.label && (this.context.font = [this.options.fontWeight, this.options.fontSize, this.options.fontFamily].join(" "), this.context.fillStyle = this.options.fontColor, this.context.textBaseline = "middle", this.context.textAlign = "center", this.context.fillText(t.label, t.position.x, t.position.y + this.options.fontYAdjust))
        }
    }
    getBubblePosition(e) {
        return new z(e.x * (this.center.x - this.options.bubbleSizePrimary / 2 - this.options.padding) + this.center.x, this.center.y - e.y * (this.center.y - this.options.bubbleSizePrimary / 2 - this.options.padding), e.z)
    }
}
window.customElements.define("gizmo-helper", Zw);
var Ux;
class _3 {
    constructor() {
        Ae(this, "experience", new ai);
        Ae(this, "debug", experience.debug);
        Ae(this, "scene", experience.scene);
        Ae(this, "time", experience.time);
        Ae(this, "camera", experience.camera.instance);
        Ae(this, "renderer", experience.renderer.instance);
        Ae(this, "resources", experience.resources);
        Ae(this, "cursor", experience.cursor);
        Ae(this, "timeline", experience.timeline);
        Ae(this, "controls", (Ux = experience.camera) == null ? void 0 : Ux.controls);
        Ae(this, "container", new Hn);
        this.debug.active && this.setupDebugFeatures()
    }
    setupDebugFeatures() {
        this.addViewHelper()
    }
    addGlobalAxes() {
        const e = new zN(5);
        this.scene.add(e)
    }
    addViewHelper() {
        this.gizmo = new Zw(this.camera, {
            size: 100,
            padding: 8
        }), document.body.appendChild(this.gizmo), this.gizmo.onAxisSelected = function (e) {
            console.log(e)
        }
    }
    resize() { }
    update(e) {
        var t;
        (t = this.gizmo) == null || t.update()
    }
}
const Zr = class Zr extends rc {
    constructor() {
        if (Zr._instance) return Zr._instance;
        super();
        Ae(this, "experience", ai.getInstance());
        Ae(this, "sizes", Ss.getInstance());
        Zr._instance = this, this.init()
    }
    static getInstance() {
        return Zr._instance || new Zr
    }
    init() {
        this.preloader = document.getElementById("preloader"), this.playButton = document.getElementById("play-button")
    }
    hardRemovePreloader() {
        this.playButton.classList.replace("fade-in", "fade-out"), this.preloader.classList.add("preloaded"), this.preloader.remove(), this.playButton.remove()
    }
};
Ae(Zr, "_instance", null);
let Ug = Zr;
const eo = class eo {
    constructor() {
        Ae(this, "experience", ai.getInstance());
        Ae(this, "renderer", this.experience.renderer.instance);
        Ae(this, "postprocessing", !0);
        Ae(this, "floatType", this.renderer.capabilities.isWebGL2 ? ei : yi);
        Ae(this, "unrealBloom", {
            enabled: !0,
            strength: .681,
            radius: .058,
            threshold: .215,
            tintColor: "#00020f",
            uTintStrength: .45
        });
        Ae(this, "motionBlur", {
            enabled: !1,
            cameraBlur: !0,
            animate: !0,
            samples: 8,
            expandGeometry: 1,
            interpolateGeometry: 1,
            smearIntensity: 5,
            speed: 20,
            renderTargetScale: 1,
            jitter: 1,
            jitterStrategy: 2
        });
        Ae(this, "bokeh", {
            enabled: !0,
            focus: 91.902,
            aperture: 3.5,
            maxblur: 0
        });
        if (eo._instance) return eo._instance;
        eo._instance = this, this.experience = ai.getInstance(), this.renderer = this.experience.renderer.instance, this.scene = this.experience.scene, this.camera = this.experience.camera.instance, this.canvas = this.experience.canvas, this.sizes = Ss.getInstance(), this.setLayers()
    }
    static getInstance() {
        return eo._instance || new eo
    }
    setLayers() {
        this.layersConst = {
            BLOOM_SCENE: 1,
            DEFAULT: 0
        }, this.bloomLayer = new o0, this.bloomLayer.set(this.layersConst.BLOOM_SCENE)
    }
    resize() { }
};
Ae(eo, "_instance", null);
let Ms = eo;
const to = class to {
    constructor() {
        Ae(this, "_darkenNonBloomed", e => {
            e.isMesh && this.bloomLayer.test(e.layers) === !1 && (this.materials[e.uuid] = e.material, e.material = this.darkMaterial)
        });
        Ae(this, "_restoreMaterial", e => {
            this.materials[e.uuid] && (e.material = this.materials[e.uuid], delete this.materials[e.uuid])
        });
        if (to._instance) return to._instance;
        to._instance = this, this.experience = ai.getInstance(), this.debug = $s.getInstance(), this.state = Ms.getInstance(), this.bloomLayer = this.state.bloomLayer, this.materials = {}, this.darkMaterial = new pr({
            color: "black"
        })
    }
    static getInstance() {
        return to._instance || new to
    }
};
Ae(to, "_instance", null);
let Du = to;
var v3 = `uniform vec2 uResolution;
uniform float uSize;
uniform float uTime;
uniform vec2 uCursor;
uniform vec3 uCursorDirection;
uniform sampler2D uDisplacementTexture;
uniform vec2 uResolutionDisplacement;
uniform sampler2D uParticlesTexture;
uniform sampler2D uSolarSystemTexture;
uniform float uScroll;
uniform float uTotalSections;
uniform float uNormalizePoints[20];

varying vec2 vUv;
varying vec3 vColor;

attribute vec3 color;
attribute float a_size;
attribute vec2 aParticlesUv;
attribute vec2 aSolarSystemUv;

vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}

vec4 grad4(float j, vec4 ip){
  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
  vec4 p,s;

  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
  s = vec4(lessThan(p, vec4(0.0)));
  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

  return p;
}

float simplexNoise4d(vec4 v){
  const vec2  C = vec2( 0.138196601125010504,  
                        0.309016994374947451); 

  vec4 i  = floor(v + dot(v, C.yyyy) );
  vec4 x0 = v -   i + dot(i, C.xxxx);

  vec4 i0;

  vec3 isX = step( x0.yzw, x0.xxx );
  vec3 isYZ = step( x0.zww, x0.yyz );

  i0.x = isX.x + isX.y + isX.z;
  i0.yzw = 1.0 - isX;

  i0.y += isYZ.x + isYZ.y;
  i0.zw += 1.0 - isYZ.xy;

  i0.z += isYZ.z;
  i0.w += 1.0 - isYZ.z;

  
  vec4 i3 = clamp( i0, 0.0, 1.0 );
  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

  
  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;

  i = mod(i, 289.0); 
  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
  vec4 j1 = permute( permute( permute( permute (
             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

  vec4 p0 = grad4(j0,   ip);
  vec4 p1 = grad4(j1.x, ip);
  vec4 p2 = grad4(j1.y, ip);
  vec4 p3 = grad4(j1.z, ip);
  vec4 p4 = grad4(j1.w, ip);

  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4,p4));

  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
  m0 = m0 * m0;
  m1 = m1 * m1;
  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;

}
vec4 permute_3d(vec4 x){ return mod(((x*34.0)+1.0)*x, 289.0); }
vec4 taylorInvSqrt3d(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }

float simplexNoise3d(vec3 v)
{
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    
    i = mod(i, 289.0 );
    vec4 p = permute_3d( permute_3d( permute_3d( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))  + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    
    
    float n_ = 1.0/7.0; 
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    
    vec4 norm = taylorInvSqrt3d(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
}

#ifdef USE_POINTS_UV

varying vec2 vUv;
uniform mat3 uvTransform;

#endif

#include <common>
#include <color_pars_vertex>
#include <morphtarget_pars_vertex>

float inOutProgress(vec3 position, vec3 target, float scrollProgress) {
    
    float noiseOrigin = simplexNoise3d(position * 0.2);
    float noiseTarget = simplexNoise3d(target * 0.2);
    float noise = mix(noiseOrigin, noiseTarget, scrollProgress);
    noise = smoothstep(-1.0, 1.0, noise);

    float duration = 0.3;
    float delay = (1.0 - duration) * noise;
    float end = delay + duration;
    float progress = smoothstep(delay, end, scrollProgress);

    return progress;
}

float remap(float value, float inputMin, float inputMax, float outputMin, float outputMax) {
    return outputMin + ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin));
}

vec2 rotate2d(vec2 _st, float _angle){
    _st -= 0.5;
    _st =  mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle)) * _st;
    _st += 0.5;
    return _st;
}

void main() {

    #ifdef USE_POINTS_UV

    vUv = (uvTransform * vec3(uv, 1)).xy;

    #endif

    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <project_vertex>

    vUv = uv;

    vec4 particleSim = texture(uParticlesTexture, aParticlesUv);
    vec4 particleSolarSystem = texture(uSolarSystemTexture, aParticlesUv);
    particleSolarSystem.x += 1.0;
    particleSolarSystem.xz = rotate2d(particleSolarSystem.xz, PI * uScroll);

    float time = uTime * 0.2;
    float range = 1.0 / uTotalSections;
    float cursorPointerActivation = 0.0;

    
    float section_2 = uNormalizePoints[1] / 2.0;
    float section_3 = uNormalizePoints[2];
    float section_4 = uNormalizePoints[3];
    float section_5 = uNormalizePoints[4];
    float section_6 = uNormalizePoints[5];
    float section_7 = uNormalizePoints[6];
    float section_8 = uNormalizePoints[7];
    float section_9 = uNormalizePoints[8];

    
    float scrollProgress = clamp(remap(uScroll, 0.0, section_2, 0.0, 1.0), 0.0, 1.0);
    float pointSizeOnScroll = mix(1.0, 3.0, scrollProgress);

    
    transformed.xyz *= 4.0;
    transformed.y += 0.9;
    transformed.x += 0.2;

    if ( uScroll < section_2 ) { 
        float inOutProgress = inOutProgress(transformed.xyz, particleSim.xyz, scrollProgress);
        vec3 mixedPosition = mix(transformed, particleSim.xyz, inOutProgress);

        transformed.xyz = mixedPosition;
    } else if ( uScroll < section_5 ) {
        float inOutProgress = inOutProgress(transformed.xyz, particleSim.xyz, scrollProgress);
        vec3 mixedPosition = mix(transformed, particleSim.xyz, inOutProgress);

        transformed.xyz = mixedPosition;

    } else if ( uScroll < section_6 ) {
        scrollProgress = clamp(remap(uScroll, section_5, section_6, 0.0, 1.0), 0.0, 1.0);
        pointSizeOnScroll = mix(3.0, 3.0, scrollProgress);
        cursorPointerActivation = scrollProgress;
        float inOutProgress = inOutProgress(particleSim.xyz, particleSolarSystem.xyz, scrollProgress);
        vec3 mixedPosition = mix(particleSim.xyz, particleSolarSystem.xyz, inOutProgress);

        transformed.xyz = mixedPosition;
    } else if ( uScroll < section_7 || uScroll < 100.0) {
        scrollProgress = clamp(remap(uScroll, section_6, section_7, 0.0, 1.0), 0.0, 1.0);
        pointSizeOnScroll = mix(3.0, 3.0, scrollProgress);
        cursorPointerActivation = 1.0 - scrollProgress;
        float inOutProgress = inOutProgress(particleSolarSystem.xyz, particleSim.xyz, scrollProgress);
        vec3 mixedPosition = mix(particleSolarSystem.xyz, particleSim.xyz, inOutProgress);

        transformed.xyz = mixedPosition;
    }

    
    transformed.xz = rotate2d(transformed.xz, PI2 * uScroll);

    
    
    
    vec4 modelPosition = modelMatrix * vec4(transformed.xyz, 1.0);
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectedPosition = projectionMatrix * viewPosition;

    gl_Position = projectedPosition;

    
    float sizeIn = smoothstep(0.0, 0.1, particleSim.a);
    float sizeOut = 1.0 - smoothstep(0.7, 1.0, particleSim.a);
    float size = min(sizeIn, sizeOut);

    gl_PointSize = size * a_size * uSize * uResolution.y * pointSizeOnScroll;
    gl_PointSize *= (1.0 / - viewPosition.z);

    #include <worldpos_vertex>

    vColor = color;
}`,
    b3 = `varying vec3 vColor;
void main() {

    vec2 uv = gl_PointCoord;
    float distanceToCenter = length(uv - 0.5);
    float alpha = 0.05 / distanceToCenter - 0.95;

    gl_FragColor = vec4(vColor, alpha);

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`;

function Rc(n, e, t) {
    return n * (1 - t) + e * t
}

function Wd(n, e, t, i, s) {
    return Rc(i, s, (n - e) / (t - e))
}
class x3 {
    constructor() {
        Ae(this, "experience", ai.getInstance());
        Ae(this, "debug", $s.getInstance());
        Ae(this, "state", Ms.getInstance());
        Ae(this, "materials", Du.getInstance());
        Ae(this, "sizes", Ss.getInstance());
        Ae(this, "input", Pu.getInstance());
        Ae(this, "scene", experience.scene);
        Ae(this, "time", experience.time);
        Ae(this, "camera", experience.camera.instance);
        Ae(this, "renderer", experience.renderer.instance);
        Ae(this, "resources", experience.resources);
        Ae(this, "container", new Hn);
        Ae(this, "particlesCount", 11092);
        Ae(this, "normalizeScrollY", 0);
        Ae(this, "normalizeScrollYTarget", 0);
        Ae(this, "normalizePoints", [0, .3, .6]);
        Ae(this, "particleSize", .226);
        Ae(this, "sectionCount", 9);
        Ae(this, "range", 1 / this.sectionCount);
        Ae(this, "lambda", 9);
        Ae(this, "particlesColors", [new Ue(2493923), new Ue(11744), new Ue(25343)]);
        Ae(this, "displacement", {});
        this.setModel(), this.setListeners(), this.setAnimation(), this.setDebug()
    }
    setModel() {
        this.dogCompressedSource = this.resources.items.dogCompressedModel, this.dogCompressedModel = this.dogCompressedSource.scene.children[0], this.particlesCount = this.dogCompressedModel.geometry.attributes.position.data.count;
        const e = new Gi;
        e.morphAttributes = this.dogCompressedModel.geometry.morphAttributes, e.morphTargetsRelative = this.dogCompressedModel.geometry.morphTargetsRelative;
        const t = new Float32Array(this.particlesCount * 3),
            i = new Float32Array(this.particlesCount * 3),
            s = new Float32Array(this.particlesCount);
        for (let l = 0; l < this.particlesCount; l++) {
            const c = l * 3;
            t[c] = (Math.random() - .5) * 1.5, t[c + 1] = (Math.random() - .5) * 1.5, t[c + 2] = (Math.random() - .5) * 1.5;
            const u = this.particlesColors[Math.floor(Math.random() * this.particlesColors.length)];
            i[c] = u.r, i[c + 1] = u.g, i[c + 2] = u.b, s[l] = Math.random()
        }
        const r = new Int16Array(this.particlesCount * 3);
        for (let l = 0; l < this.particlesCount; l++) {
            const array = this.dogCompressedModel.geometry.attributes.position.data.array;

            r[l * 3] = array[l * 4] ?? 0;           // x-coordinate
            r[l * 3 + 1] = array[l * 4 + 1] ?? 0;   // y-coordinate
            r[l * 3 + 2] = array[l * 4 + 2] ?? 0;   // z-coordinate
        }
        const o = new h0(r, 3);
        e.setAttribute("position", new $l(o, 3, 0, !0)), e.setAttribute("color", new pi(i, 3)), e.setAttribute("a_size", new pi(s, 1)), e.computeVertexNormals();
        const a = new ti({
            vertexShader: v3,
            fragmentShader: b3,
            uniforms: {
                uTime: {
                    value: 0
                },
                uSize: new vi(this.particleSize),
                uResolution: new vi(new _e(this.sizes.width * this.sizes.pixelRatio, this.sizes.height * this.sizes.pixelRatio)),
                uResolutionDisplacement: new vi(new _e),
                uCursor: new vi(this.input.cursor3D),
                uCursorDirection: new vi(new z),
                uDisplacementTexture: new vi,
                uParticlesTexture: new vi,
                uSolarSystemTexture: new vi,
                uScroll: new vi(0),
                uTotalSections: new vi(this.sectionCount),
                uNormalizePoints: new vi(this.normalizePoints)
            },
            blending: Kh,
            depthWrite: !1
        });
        this.points = new Kc(e, a), this.points.frustumCulled = !1, this.points.morphTargetInfluences = this.dogCompressedModel.morphTargetInfluences, this.points.morphTargetDictionary = this.dogCompressedModel.morphTargetDictionary, this.container.add(this.points), this.scene.add(this.container)
    }
    setListeners() {
        window.addEventListener("scroll:update-normalize-y", ({
            detail: e
        }) => {
            this.normalizeScrollYTarget = e.currentPoint
        }), window.addEventListener("scroll:update-breakpoints", ({
            detail: e
        }) => {
            this.sectionCount = e.breakpoints.length, this.range = 1 / this.sectionCount, this.normalizePoints = e.breakpoints, this.points.material.uniforms.uNormalizePoints.value = this.normalizePoints, this.points.material.uniforms.uTotalSections.value = this.sectionCount
        })
    }
    resize() {
        this.points.material.uniforms.uResolution.value.set(this.sizes.width * this.sizes.pixelRatio, this.sizes.height * this.sizes.pixelRatio)
    }
    createDisplacementTexture() {
        const e = this.displacement,
            t = this.sizes.width / 8,
            i = this.sizes.height / 8;
        e.canvas = document.createElement("canvas"), e.canvas.width = t, e.canvas.height = i, e.canvas.style.position = "fixed", e.canvas.style.width = `${t}px`, e.canvas.style.height = `${i}px`, e.canvas.style.top = 0, e.canvas.style.left = 0, e.canvas.style.zIndex = 100, this.debug.active ? document.body.appendChild(e.canvas) : e.canvas.style.display = "none", e.context = e.canvas.getContext("2d"), e.context.fillRect(0, 0, e.canvas.width, e.canvas.height), e.glowImage = this.resources.items.glowTexture.source.data, e.screenCursor = new _e(9999, 9999), e.canvasCursor = new _e(9999, 9999), e.canvasCursorPrevious = new _e(9999, 9999), e.texture = new SF(e.canvas), this.points.material.uniforms.uResolutionDisplacement.value.set(t, i)
    }
    setDebug() {
        this.debug.active && (this.debugFolder = this.debug.panel.addFolder("Particles"), this.debugFolder.add(this, "particleSize").min(0).max(1).step(.001).name("Particle Size").onChange(() => {
            this.points.material.uniforms.uSize.value = this.particleSize
        }), this.debugFolder.addColor(this.particlesColors, "0").name("Particles Color 1").onChange(() => {
            this.changeColors()
        }), this.debugFolder.addColor(this.particlesColors, "1").name("Particles Color 2").onChange(() => {
            this.changeColors()
        }), this.debugFolder.addColor(this.particlesColors, "2").name("Particles Color 3").onChange(() => {
            this.changeColors()
        }), this.debugFolder.add(this, "normalizeScrollY").min(0).max(1).step(.001).name("Normalize Scroll Y"))
    }
    changeColors() {
        const e = this.points.geometry.attributes.color;
        for (let t = 0; t < this.particlesCount; t++) {
            const i = this.particlesColors[Math.floor(Math.random() * this.particlesColors.length)],
                s = t * 3;
            e.array[s] = i.r, e.array[s + 1] = i.g, e.array[s + 2] = i.b
        }
        e.needsUpdate = !0
    }
    setAnimation() {
        this.animation = {}, this.animation.mixer = new QN(this.dogCompressedModel), this.animation.actions = {}, this.animation.actions.idle = this.animation.mixer.clipAction(this.dogCompressedSource.animations[0]), this.animation.actions.open = this.animation.mixer.clipAction(this.dogCompressedSource.animations[0]), this.animation.actions.current = this.animation.actions.idle, this.animation.actions.current.play(), this.animation.play = e => {
            const t = this.animation.actions[e],
                i = this.animation.actions.current;
            t.reset(), t.play(), t.crossFadeFrom(i, 1), this.animation.actions.current = t
        }
    }
    update(e) {
        this.animation && this.animation.mixer.update(this.time.delta), this.normalizeScrollY = lr.damp(this.normalizeScrollY, this.normalizeScrollYTarget, this.lambda, e), this.points.material.uniforms.uTime.value = this.time.elapsed, this.points.material.uniforms.uCursor.value = this.input.cursor3D, this.points.material.uniforms.uCursorDirection.value.set(this.input.cursorDirection.x, this.input.cursorDirection.y, this.input.cursorDirection.z), this.points.material.uniforms.uScroll.value = this.normalizeScrollY, this.updateScrollProgress()
    }
    updateScrollProgress() {
        let e = lr.clamp(Wd(this.normalizeScrollY, 0, this.normalizePoints[1], 0, 1), 0, 1);
        return this.normalizeScrollY < this.normalizePoints[1] ? (e = lr.clamp(Wd(this.normalizeScrollY, 0, this.normalizePoints[1], 0, 1), 0, 1), this.experience.postProcess.bokehPass.uniforms.maxblur.value = this.state.bokeh.maxblur + Rc(0, .009, e), this.renderer.toneMappingExposure = Rc(1, .6, e)) : this.normalizeScrollY < this.normalizePoints[5] ? (e = lr.clamp(Wd(this.normalizeScrollY, this.normalizePoints[4], this.normalizePoints[5], 0, 1), 0, 1), this.experience.postProcess.bokehPass.uniforms.maxblur.value = this.state.bokeh.maxblur + Rc(.009, 0, e)) : this.normalizeScrollY < this.normalizePoints[6] && (e = lr.clamp(Wd(this.normalizeScrollY, this.normalizePoints[5], this.normalizePoints[6], 0, 1), 0, 1), this.experience.postProcess.bokehPass.uniforms.maxblur.value = this.state.bokeh.maxblur + Rc(0, .009, e)), e
    }
    updateDisplacementCursorTexture() {
        if (this.experience.isMobile) return;
        const e = this.displacement;
        e.context.globalCompositeOperation = "source-over", e.context.globalAlpha = .01, e.context.fillRect(0, 0, e.canvas.width, e.canvas.height), e.canvasCursor.x = (this.input.cursor.x + 1) * e.canvas.width / 2, e.canvasCursor.y = (-this.input.cursor.y + 1) * e.canvas.height / 2;
        const t = e.canvasCursorPrevious.distanceTo(e.canvasCursor);
        e.canvasCursorPrevious.copy(e.canvasCursor);
        const i = Math.min(t * .05, 1),
            s = e.canvas.width * .06;
        e.context.globalCompositeOperation = "lighten", e.context.globalAlpha = i, e.context.drawImage(e.glowImage, e.canvasCursor.x - s * .5, e.canvasCursor.y - s * .5, s, s), e.texture.needsUpdate = !0, this.points.material.uniforms.uDisplacementTexture.value = e.texture
    }
}
class y3 {
    constructor(e, t, i) {
        this.variables = [], this.currentTextureIndex = 0;
        let s = ei;
        const r = new d0,
            o = new a0;
        o.position.z = 1;
        const a = {
            passThruTexture: {
                value: null
            }
        },
            l = d(f(), a),
            c = new Ri(new $u(2, 2), l);
        r.add(c), this.setDataType = function (m) {
            return s = m, this
        }, this.addVariable = function (m, g, A) {
            const p = this.createShaderMaterial(g),
                v = {
                    name: m,
                    initialValueTexture: A,
                    material: p,
                    dependencies: null,
                    renderTargets: [],
                    wrapS: null,
                    wrapT: null,
                    minFilter: Kt,
                    magFilter: Kt
                };
            return this.variables.push(v), v
        }, this.setVariableDependencies = function (m, g) {
            m.dependencies = g
        }, this.init = function () {
            if (i.capabilities.maxVertexTextures === 0) return "No support for vertex shader textures.";
            for (let m = 0; m < this.variables.length; m++) {
                const g = this.variables[m];
                g.renderTargets[0] = this.createRenderTarget(e, t, g.wrapS, g.wrapT, g.minFilter, g.magFilter), g.renderTargets[1] = this.createRenderTarget(e, t, g.wrapS, g.wrapT, g.minFilter, g.magFilter), this.renderTexture(g.initialValueTexture, g.renderTargets[0]), this.renderTexture(g.initialValueTexture, g.renderTargets[1]);
                const A = g.material,
                    p = A.uniforms;
                if (g.dependencies !== null)
                    for (let v = 0; v < g.dependencies.length; v++) {
                        const _ = g.dependencies[v];
                        if (_.name !== g.name) {
                            let b = !1;
                            for (let w = 0; w < this.variables.length; w++)
                                if (_.name === this.variables[w].name) {
                                    b = !0;
                                    break
                                }
                            if (!b) return "Variable dependency not found. Variable=" + g.name + ", dependency=" + _.name
                        }
                        p[_.name] = {
                            value: null
                        }, A.fragmentShader = `
uniform sampler2D ` + _.name + `;
` + A.fragmentShader
                    }
            }
            return this.currentTextureIndex = 0, null
        }, this.compute = function () {
            const m = this.currentTextureIndex,
                g = this.currentTextureIndex === 0 ? 1 : 0;
            for (let A = 0, p = this.variables.length; A < p; A++) {
                const v = this.variables[A];
                if (v.dependencies !== null) {
                    const _ = v.material.uniforms;
                    for (let b = 0, w = v.dependencies.length; b < w; b++) {
                        const E = v.dependencies[b];
                        _[E.name].value = E.renderTargets[m].texture
                    }
                }
                this.doRenderTarget(v.material, v.renderTargets[g])
            }
            this.currentTextureIndex = g
        }, this.getCurrentRenderTarget = function (m) {
            return m.renderTargets[this.currentTextureIndex]
        }, this.getAlternateRenderTarget = function (m) {
            return m.renderTargets[this.currentTextureIndex === 0 ? 1 : 0]
        }, this.dispose = function () {
            c.geometry.dispose(), c.material.dispose();
            const m = this.variables;
            for (let g = 0; g < m.length; g++) {
                const A = m[g];
                A.initialValueTexture && A.initialValueTexture.dispose();
                const p = A.renderTargets;
                for (let v = 0; v < p.length; v++) p[v].dispose()
            }
        };

        function u(m) {
            m.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )"
        }
        this.addResolutionDefine = u;

        function d(m, g) {
            g = g || {};
            const A = new ti({
                name: "GPUComputationShader",
                uniforms: g,
                vertexShader: h(),
                fragmentShader: m
            });
            return u(A), A
        }
        this.createShaderMaterial = d, this.createRenderTarget = function (m, g, A, p, v, _) {
            return m = m || e, g = g || t, A = A || pn, p = p || pn, v = v || Kt, _ = _ || Kt, new mn(m, g, {
                wrapS: A,
                wrapT: p,
                minFilter: v,
                magFilter: _,
                format: Jt,
                type: s,
                depthBuffer: !1
            })
        }, this.createTexture = function () {
            const m = new Float32Array(e * t * 4),
                g = new Bo(m, e, t, Jt, ei);
            return g.needsUpdate = !0, g
        }, this.renderTexture = function (m, g) {
            a.passThruTexture.value = m, this.doRenderTarget(l, g), a.passThruTexture.value = null
        }, this.doRenderTarget = function (m, g) {
            const A = i.getRenderTarget(),
                p = i.xr.enabled,
                v = i.shadowMap.autoUpdate;
            i.xr.enabled = !1, i.shadowMap.autoUpdate = !1, c.material = m, i.setRenderTarget(g), i.render(r, o), c.material = l, i.xr.enabled = p, i.shadowMap.autoUpdate = v, i.setRenderTarget(A)
        };

        function h() {
            return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`
        }

        function f() {
            return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`
        }
    }
}
var E3 = `uniform float uTime;
uniform float uDeltaTime;
uniform sampler2D uBase;
uniform float uFlowFieldInfluence;
uniform float uFlowFieldStrength;
uniform float uFlowFieldFrequency;

vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}

vec4 grad4(float j, vec4 ip){
  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
  vec4 p,s;

  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
  s = vec4(lessThan(p, vec4(0.0)));
  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

  return p;
}

float simplexNoise4d(vec4 v){
  const vec2  C = vec2( 0.138196601125010504,  
                        0.309016994374947451); 

  vec4 i  = floor(v + dot(v, C.yyyy) );
  vec4 x0 = v -   i + dot(i, C.xxxx);

  vec4 i0;

  vec3 isX = step( x0.yzw, x0.xxx );
  vec3 isYZ = step( x0.zww, x0.yyz );

  i0.x = isX.x + isX.y + isX.z;
  i0.yzw = 1.0 - isX;

  i0.y += isYZ.x + isYZ.y;
  i0.zw += 1.0 - isYZ.xy;

  i0.z += isYZ.z;
  i0.w += 1.0 - isYZ.z;

  
  vec4 i3 = clamp( i0, 0.0, 1.0 );
  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

  
  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;

  i = mod(i, 289.0); 
  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
  vec4 j1 = permute( permute( permute( permute (
             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

  vec4 p0 = grad4(j0,   ip);
  vec4 p1 = grad4(j1.x, ip);
  vec4 p2 = grad4(j1.y, ip);
  vec4 p3 = grad4(j1.z, ip);
  vec4 p4 = grad4(j1.w, ip);

  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4,p4));

  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
  m0 = m0 * m0;
  m1 = m1 * m1;
  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;

}

void main()
{
    float time = uTime * 0.2;
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec4 particle = texture(uParticles, uv);
    vec4 base = texture(uBase, uv);

    
    if(particle.a >= 1.0)
    {
        particle.a = mod(particle.a, 1.0);
        particle.xyz = base.xyz;
    }

    
    else
    {
        
        float strength = simplexNoise4d(vec4(base.xyz * 0.2, time + 1.0));
        float influence = (uFlowFieldInfluence - 0.5) * (- 2.0);
        strength = smoothstep(influence, 1.0, strength);

        
        vec3 flowField = vec3(
            simplexNoise4d(vec4(particle.xyz * uFlowFieldFrequency + 0.0, time)),
            simplexNoise4d(vec4(particle.xyz * uFlowFieldFrequency + 1.0, time)),
            simplexNoise4d(vec4(particle.xyz * uFlowFieldFrequency + 2.0, time))
        );
        flowField = normalize(flowField);
        particle.xyz += flowField * uDeltaTime * uFlowFieldStrength ;

        
        particle.a += uDeltaTime * 0.01;
    }

    gl_FragColor = particle;
}`;
const w3 = (Math.sqrt(5) - 1) / 4,
    Fi = (5 - Math.sqrt(5)) / 20,
    qd = n => Math.floor(n) | 0,
    $d = new Float64Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);

function C3(n = Math.random) {
    const e = S3(n),
        t = new Float64Array(e).map(o => $d[o % 32 * 4]),
        i = new Float64Array(e).map(o => $d[o % 32 * 4 + 1]),
        s = new Float64Array(e).map(o => $d[o % 32 * 4 + 2]),
        r = new Float64Array(e).map(o => $d[o % 32 * 4 + 3]);
    return function (a, l, c, u) {
        let d, h, f, m, g;
        const A = (a + l + c + u) * w3,
            p = qd(a + A),
            v = qd(l + A),
            _ = qd(c + A),
            b = qd(u + A),
            w = (p + v + _ + b) * Fi,
            E = p - w,
            C = v - w,
            S = _ - w,
            x = b - w,
            y = a - E,
            P = l - C,
            T = c - S,
            R = u - x;
        let D = 0,
            U = 0,
            Q = 0,
            F = 0;
        y > P ? D++ : U++, y > T ? D++ : Q++, y > R ? D++ : F++, P > T ? U++ : Q++, P > R ? U++ : F++, T > R ? Q++ : F++;
        const L = D >= 3 ? 1 : 0,
            W = U >= 3 ? 1 : 0,
            k = Q >= 3 ? 1 : 0,
            $ = F >= 3 ? 1 : 0,
            X = D >= 2 ? 1 : 0,
            le = U >= 2 ? 1 : 0,
            K = Q >= 2 ? 1 : 0,
            te = F >= 2 ? 1 : 0,
            ue = D >= 1 ? 1 : 0,
            fe = U >= 1 ? 1 : 0,
            Me = Q >= 1 ? 1 : 0,
            Be = F >= 1 ? 1 : 0,
            Ce = y - L + Fi,
            Z = P - W + Fi,
            ke = T - k + Fi,
            N = R - $ + Fi,
            G = y - X + 2 * Fi,
            Y = P - le + 2 * Fi,
            se = T - K + 2 * Fi,
            M = R - te + 2 * Fi,
            I = y - ue + 3 * Fi,
            H = P - fe + 3 * Fi,
            V = T - Me + 3 * Fi,
            j = R - Be + 3 * Fi,
            q = y - 1 + 4 * Fi,
            he = P - 1 + 4 * Fi,
            re = T - 1 + 4 * Fi,
            de = R - 1 + 4 * Fi,
            ge = p & 255,
            ce = v & 255,
            me = _ & 255,
            xe = b & 255;
        let ve = .6 - y * y - P * P - T * T - R * R;
        if (ve < 0) d = 0;
        else {
            const Le = ge + e[ce + e[me + e[xe]]];
            ve *= ve, d = ve * ve * (t[Le] * y + i[Le] * P + s[Le] * T + r[Le] * R)
        }
        let we = .6 - Ce * Ce - Z * Z - ke * ke - N * N;
        if (we < 0) h = 0;
        else {
            const Le = ge + L + e[ce + W + e[me + k + e[xe + $]]];
            we *= we, h = we * we * (t[Le] * Ce + i[Le] * Z + s[Le] * ke + r[Le] * N)
        }
        let Pe = .6 - G * G - Y * Y - se * se - M * M;
        if (Pe < 0) f = 0;
        else {
            const Le = ge + X + e[ce + le + e[me + K + e[xe + te]]];
            Pe *= Pe, f = Pe * Pe * (t[Le] * G + i[Le] * Y + s[Le] * se + r[Le] * M)
        }
        let Ke = .6 - I * I - H * H - V * V - j * j;
        if (Ke < 0) m = 0;
        else {
            const Le = ge + ue + e[ce + fe + e[me + Me + e[xe + Be]]];
            Ke *= Ke, m = Ke * Ke * (t[Le] * I + i[Le] * H + s[Le] * V + r[Le] * j)
        }
        let Ve = .6 - q * q - he * he - re * re - de * de;
        if (Ve < 0) g = 0;
        else {
            const Le = ge + 1 + e[ce + 1 + e[me + 1 + e[xe + 1]]];
            Ve *= Ve, g = Ve * Ve * (t[Le] * q + i[Le] * he + s[Le] * re + r[Le] * de)
        }
        return 27 * (d + h + f + m + g)
    }
}

function S3(n) {
    const t = new Uint8Array(512);
    for (let i = 0; i < 512 / 2; i++) t[i] = i;
    for (let i = 0; i < 512 / 2 - 1; i++) {
        const s = i + ~~(n() * (256 - i)),
            r = t[i];
        t[i] = t[s], t[s] = r
    }
    for (let i = 256; i < 512; i++) t[i] = t[i - 256];
    return t
}
class M3 {
    constructor() {
        Ae(this, "experience", ai.getInstance());
        Ae(this, "debug", $s.getInstance());
        Ae(this, "state", Ms.getInstance());
        Ae(this, "scene", experience.scene);
        Ae(this, "time", experience.time);
        Ae(this, "camera", experience.camera.instance);
        Ae(this, "renderer", experience.renderer.instance);
        Ae(this, "resources", experience.resources);
        Ae(this, "container", new Hn);
        Ae(this, "points", experience.world.particles.points);
        this.setModel(), this.setDebug()
    }
    setModel() {
        const e = {};
        e.instance = this.points.geometry, e.count = e.instance.attributes.position.data.count;
        const t = {};
        this.gpgpu = t, t.size = Math.ceil(Math.sqrt(e.count)), t.computation = new y3(t.size, t.size, this.renderer);
        const i = t.computation.createTexture(),
            s = C3();
        for (let o = 0; o < e.count; o++) {
            const a = o * 4,
                l = 1.2,
                c = Math.random() * Math.PI * 2,
                u = Math.acos(2 * Math.random() - 1),
                d = l * Math.sin(u) * Math.cos(c),
                h = l * Math.sin(u) * Math.sin(c),
                f = l * Math.cos(u);
            i.image.data[a + 0] = d + s(d, h, f, this.time.elapsed) * 1, i.image.data[a + 1] = h + s(d, h, f, this.time.elapsed) * 1, i.image.data[a + 2] = f + s(d, h, f, this.time.elapsed) * 1, i.image.data[a + 3] = Math.random()
        }
        t.particlesVariable = t.computation.addVariable("uParticles", E3, i), t.computation.setVariableDependencies(t.particlesVariable, [t.particlesVariable]), t.particlesVariable.material.uniforms.uTime = new vi(0), t.particlesVariable.material.uniforms.uDeltaTime = new vi(0), t.particlesVariable.material.uniforms.uBase = new vi(i), t.particlesVariable.material.uniforms.uFlowFieldInfluence = new vi(.5), t.particlesVariable.material.uniforms.uFlowFieldStrength = new vi(.222), t.particlesVariable.material.uniforms.uFlowFieldFrequency = new vi(.5), t.computation.init();
        const r = new Float32Array(e.count * 2);
        for (let o = 0; o < e.count; o++) {
            const a = o * 2,
                l = Math.floor(o / t.size),
                c = o - l * t.size;
            r[a + 0] = (c + .5) / t.size, r[a + 1] = (l + .5) / t.size
        }
        this.points.geometry.setAttribute("aParticlesUv", new pi(r, 2)), this.points.geometry.needsUpdate = !0
    }
    resize() { }
    setDebug() {
        this.debug.active && (this.debugFolder = this.debug.panel.addFolder("Flow Field"), this.debugFolder.add(this.gpgpu.particlesVariable.material.uniforms.uFlowFieldInfluence, "value").min(0).max(1).step(.001).name("uFlowfieldInfluence"), this.debugFolder.add(this.gpgpu.particlesVariable.material.uniforms.uFlowFieldStrength, "value").min(0).max(10).step(.001).name("uFlowfieldStrength"), this.debugFolder.add(this.gpgpu.particlesVariable.material.uniforms.uFlowFieldFrequency, "value").min(0).max(1).step(.001).name("uFlowfieldFrequency"), this.debug.createDebugTexture(this.gpgpu.computation.getCurrentRenderTarget(this.gpgpu.particlesVariable).texture))
    }
    update(e) {
        this.gpgpu.particlesVariable.material.uniforms.uTime.value = this.time.elapsed, this.gpgpu.particlesVariable.material.uniforms.uDeltaTime.value = e, this.gpgpu.computation.compute(), this.points.material.uniforms.uParticlesTexture.value = this.gpgpu.computation.getCurrentRenderTarget(this.gpgpu.particlesVariable).texture
    }
}

function T3(n) {
    let e = n.attributes.position.count,
        t = Math.ceil(Math.sqrt(e)),
        i = Math.ceil(e / t),
        s = new Float32Array(t * i * 4);

    function r(a) {
        let c = Math.floor(a.length / 3);
        for (let u = c - 1; u > 0; u--) {
            const d = Math.floor(Math.random() * (u + 1));
            for (let h = 0; h < 3; h++) {
                let f = a[u * 3 + h];
                a[u * 3 + h] = a[d * 3 + h], a[d * 3 + h] = f
            }
        }
        return a
    }
    r(n.attributes.position.array);
    for (let a = 0; a < e; a++) {
        const positionArray = n.attributes.position.array;

        const l = positionArray[a * 3 + 0] ?? 2; // x-coordinate
        const c = positionArray[a * 3 + 1] ?? 0; // y-coordinate
        const u = positionArray[a * 3 + 2] ?? 0; // z-coordinate
        const d = 0; // Default value

        s[a * 4 + 0] = l;
        s[a * 4 + 1] = c;
        s[a * 4 + 2] = u;
        s[a * 4 + 3] = d;
    }
    let o = new Bo(s, t, i, Jt, ei);
    return o.needsUpdate = !0, o
}
class I3 {
    constructor() {
        Ae(this, "experience", ai.getInstance());
        Ae(this, "debug", $s.getInstance());
        Ae(this, "state", Ms.getInstance());
        Ae(this, "materials", Du.getInstance());
        Ae(this, "scene", experience.scene);
        Ae(this, "time", experience.time);
        Ae(this, "camera", experience.camera.instance);
        Ae(this, "renderer", experience.renderer.instance);
        Ae(this, "resources", experience.resources);
        Ae(this, "container", new Hn);
        Ae(this, "points", experience.world.particles.points);
        this.setModel(), this.setDebug()
    }
    setModel() {
        this.solarSystemSource = this.resources.items.solarSystemModel, this.solarSystemModel = this.solarSystemSource.scene.children[0], this.solarSystemGeometry = this.solarSystemModel.geometry, this.solarSystemGeometry.scale(.5, .5, .5), this.solarSystemTexturePositions = T3(this.solarSystemGeometry), this.points.material.uniforms.uSolarSystemTexture.value = this.solarSystemTexturePositions
    }
    resize() { }
    setDebug() {
        this.debug.active
    }
    update(e) { }
}
class B3 {
    constructor() {
        this.experience = ai.getInstance(), this.ui = new Ug, this.time = cf.getInstance(), this.camera = this.experience.camera, this.scene = this.experience.scene, this.resources = this.experience.resources, this.html = this.experience.html, this.sound = this.experience.sound, this.debug = this.experience.debug.panel, this.resources.on("ready", () => {
            this.state = new Ms, this.start()
        })
    }
    start() {
        this.time.reset(), this.setupWorld(), this.animationPipeline()
    }
    setupWorld() {
        this.particles = new x3, this.particlesSimulation = new M3, this.solarSystem = new I3, this.environment = new A3, this.debugHelpers = new _3, this.animationPipeline(), window.dispatchEvent(new CustomEvent("3d-app:loaded"))
    }
    startWithPreloader() {
        this.ui.playButton.classList.add("fade-in"), this.ui.playButton.addEventListener("click", () => {
            this.ui.playButton.classList.replace("fade-in", "fade-out"), setTimeout(() => {
                this.time.reset(), this.setupWorld(), this.ui.preloader.classList.add("preloaded"), setTimeout(() => {
                    this.ui.preloader.remove(), this.ui.playButton.remove()
                }, 2500)
            }, 100)
        }, {
            once: !0
        })
    }
    animationPipeline() {
        this.camera && this.camera.animateCameraPosition()
    }
    resize() {
        var e, t, i, s;
        (e = this.state) == null || e.resize(), (t = this.particles) == null || t.resize(), (i = this.particlesSimulation) == null || i.resize(), (s = this.solarSystem) == null || s.resize()
    }
    update(e) {
        var t, i, s, r, o;
        (t = this.debugHelpers) == null || t.update(e), (i = this.cube) == null || i.update(e), (s = this.particles) == null || s.update(e), (r = this.particlesSimulation) == null || r.update(e), (o = this.solarSystem) == null || o.update(e)
    }
}

function kb(n, e) {
    if (e === kR) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), n;
    if (e === xg || e === cw) {
        let t = n.getIndex();
        if (t === null) {
            const o = [],
                a = n.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++) o.push(l);
                n.setIndex(o), t = n.getIndex()
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n
        }
        const i = t.count - 2,
            s = [];
        if (e === xg)
            for (let o = 1; o <= i; o++) s.push(t.getX(0)), s.push(t.getX(o)), s.push(t.getX(o + 1));
        else
            for (let o = 0; o < i; o++) o % 2 === 0 ? (s.push(t.getX(o)), s.push(t.getX(o + 1)), s.push(t.getX(o + 2))) : (s.push(t.getX(o + 2)), s.push(t.getX(o + 1)), s.push(t.getX(o)));
        s.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const r = n.clone();
        return r.setIndex(s), r.clearGroups(), r
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), n
}
class R3 extends $n {
    constructor(e) {
        super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) {
            return new F3(t)
        }), this.register(function (t) {
            return new W3(t)
        }), this.register(function (t) {
            return new q3(t)
        }), this.register(function (t) {
            return new $3(t)
        }), this.register(function (t) {
            return new O3(t)
        }), this.register(function (t) {
            return new U3(t)
        }), this.register(function (t) {
            return new Q3(t)
        }), this.register(function (t) {
            return new z3(t)
        }), this.register(function (t) {
            return new k3(t)
        }), this.register(function (t) {
            return new G3(t)
        }), this.register(function (t) {
            return new N3(t)
        }), this.register(function (t) {
            return new V3(t)
        }), this.register(function (t) {
            return new H3(t)
        }), this.register(function (t) {
            return new D3(t)
        }), this.register(function (t) {
            return new j3(t)
        }), this.register(function (t) {
            return new Y3(t)
        })
    }
    load(e, t, i, s) {
        const r = this;
        let o;
        if (this.resourcePath !== "") o = this.resourcePath;
        else if (this.path !== "") {
            const c = eu.extractUrlBase(e);
            o = eu.resolveURL(c, this.path)
        } else o = eu.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function (c) {
            s ? s(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e)
        },
            l = new ws(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (c) {
            try {
                r.parse(c, o, function (u) {
                    t(u), r.manager.itemEnd(e)
                }, a)
            } catch (u) {
                a(u)
            }
        }, i, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e, this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e, this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e, this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }
    parse(e, t, i, s) {
        let r;
        const o = {},
            a = {},
            l = new TextDecoder;
        if (typeof e == "string") r = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (l.decode(new Uint8Array(e, 0, 4)) === eC) {
                try {
                    o[ht.KHR_BINARY_GLTF] = new X3(e)
                } catch (d) {
                    s && s(d);
                    return
                }
                r = JSON.parse(o[ht.KHR_BINARY_GLTF].content)
            } else r = JSON.parse(l.decode(e));
        else r = e;
        if (r.asset === void 0 || r.asset.version[0] < 2) {
            s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new cO(r, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const d = this.pluginCallbacks[u](c);
            d.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[d.name] = d, o[d.name] = !0
        }
        if (r.extensionsUsed)
            for (let u = 0; u < r.extensionsUsed.length; ++u) {
                const d = r.extensionsUsed[u],
                    h = r.extensionsRequired || [];
                switch (d) {
                    case ht.KHR_MATERIALS_UNLIT:
                        o[d] = new L3;
                        break;
                    case ht.KHR_DRACO_MESH_COMPRESSION:
                        o[d] = new K3(r, this.dracoLoader);
                        break;
                    case ht.KHR_TEXTURE_TRANSFORM:
                        o[d] = new J3;
                        break;
                    case ht.KHR_MESH_QUANTIZATION:
                        o[d] = new Z3;
                        break;
                    default:
                        h.indexOf(d) >= 0 && a[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".')
                }
            }
        c.setExtensions(o), c.setPlugins(a), c.parse(i, s)
    }
    parseAsync(e, t) {
        const i = this;
        return new Promise(function (s, r) {
            i.parse(e, t, s, r)
        })
    }
}

function P3() {
    let n = {};
    return {
        get: function (e) {
            return n[e]
        },
        add: function (e, t) {
            n[e] = t
        },
        remove: function (e) {
            delete n[e]
        },
        removeAll: function () {
            n = {}
        }
    }
}
const ht = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class D3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser,
            t = this.parser.json.nodes || [];
        for (let i = 0, s = t.length; i < s; i++) {
            const r = t[i];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser,
            i = "light:" + e;
        let s = t.cache.get(i);
        if (s) return s;
        const r = t.json,
            l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
        let c;
        const u = new Ue(16777215);
        l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], gi);
        const d = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
            case "directional":
                c = new Hw(u), c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            case "point":
                c = new bN(u), c.distance = d;
                break;
            case "spot":
                c = new _N(u), c.distance = d, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0), c.decay = 2, jr(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(i, s), s
    }
    getDependency(e, t) {
        if (e === "light") return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this,
            i = this.parser,
            r = i.json.nodes[e],
            a = (r.extensions && r.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function (l) {
            return i._getNodeRef(t.cache, a, l)
        })
    }
}
class L3 {
    constructor() {
        this.name = ht.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return pr
    }
    extendParams(e, t, i) {
        const s = [];
        e.color = new Ue(1, 1, 1), e.opacity = 1;
        const r = t.pbrMetallicRoughness;
        if (r) {
            if (Array.isArray(r.baseColorFactor)) {
                const o = r.baseColorFactor;
                e.color.setRGB(o[0], o[1], o[2], gi), e.opacity = o[3]
            }
            r.baseColorTexture !== void 0 && s.push(i.assignTexture(e, "map", r.baseColorTexture, Wt))
        }
        return Promise.all(s)
    }
}
class k3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const s = this.parser.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = s.extensions[this.name].emissiveStrength;
        return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve()
    }
}
class F3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [],
            o = s.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (r.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new _e(a, a)
        }
        return Promise.all(r)
    }
}
class N3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [],
            o = s.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(r)
    }
}
class O3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [];
        t.sheenColor = new Ue(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
        const o = s.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            t.sheenColor.setRGB(a[0], a[1], a[2], gi)
        }
        return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && r.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Wt)), o.sheenRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r)
    }
}
class U3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [],
            o = s.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && r.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r)
    }
}
class Q3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [],
            o = s.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && r.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Ue().setRGB(a[0], a[1], a[2], gi), Promise.all(r)
    }
}
class z3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const s = this.parser.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = s.extensions[this.name];
        return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve()
    }
}
class G3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [],
            o = s.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && r.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Ue().setRGB(a[0], a[1], a[2], gi), o.specularColorTexture !== void 0 && r.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, Wt)), Promise.all(r)
    }
}
class H3 {
    constructor(e) {
        this.parser = e, this.name = ht.EXT_MATERIALS_BUMP
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [],
            o = s.extensions[this.name];
        return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && r.push(i.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(r)
    }
}
class V3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Mr
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            s = i.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const r = [],
            o = s.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && r.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(r)
    }
}
class W3 {
    constructor(e) {
        this.parser = e, this.name = ht.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser,
            i = t.json,
            s = i.textures[e];
        if (!s.extensions || !s.extensions[this.name]) return null;
        const r = s.extensions[this.name],
            o = t.options.ktx2Loader;
        if (!o) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, r.source, o)
    }
}
class q3 {
    constructor(e) {
        this.parser = e, this.name = ht.EXT_TEXTURE_WEBP, this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name,
            i = this.parser,
            s = i.json,
            r = s.textures[e];
        if (!r.extensions || !r.extensions[t]) return null;
        const o = r.extensions[t],
            a = s.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function (c) {
            if (c) return i.loadTextureImage(e, o.source, l);
            if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function (e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
                e(t.height === 1)
            }
        })), this.isSupported
    }
}
class $3 {
    constructor(e) {
        this.parser = e, this.name = ht.EXT_TEXTURE_AVIF, this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name,
            i = this.parser,
            s = i.json,
            r = s.textures[e];
        if (!r.extensions || !r.extensions[t]) return null;
        const o = r.extensions[t],
            a = s.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function (c) {
            if (c) return i.loadTextureImage(e, o.source, l);
            if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function (e) {
            const t = new Image;
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () {
                e(t.height === 1)
            }
        })), this.isSupported
    }
}
class j3 {
    constructor(e) {
        this.name = ht.EXT_MESHOPT_COMPRESSION, this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json,
            i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
            const s = i.extensions[this.name],
                r = this.parser.getDependency("buffer", s.buffer),
                o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return r.then(function (a) {
                const l = s.byteOffset || 0,
                    c = s.byteLength || 0,
                    u = s.count,
                    d = s.byteStride,
                    h = new Uint8Array(a, l, c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, d, h, s.mode, s.filter).then(function (f) {
                    return f.buffer
                }) : o.ready.then(function () {
                    const f = new ArrayBuffer(u * d);
                    return o.decodeGltfBuffer(new Uint8Array(f), u, d, h, s.mode, s.filter), f
                })
            })
        } else return null
    }
}
class Y3 {
    constructor(e) {
        this.name = ht.EXT_MESH_GPU_INSTANCING, this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json,
            i = t.nodes[e];
        if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null;
        const s = t.meshes[i.mesh];
        for (const c of s.primitives)
            if (c.mode !== Zn.TRIANGLES && c.mode !== Zn.TRIANGLE_STRIP && c.mode !== Zn.TRIANGLE_FAN && c.mode !== void 0) return null;
        const o = i.extensions[this.name].attributes,
            a = [],
            l = {};
        for (const c in o) a.push(this.parser.getDependency("accessor", o[c]).then(u => (l[c] = u, l[c])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then(c => {
            const u = c.pop(),
                d = u.isGroup ? u.children : [u],
                h = c[0].count,
                f = [];
            for (const m of d) {
                const g = new Xe,
                    A = new z,
                    p = new Tn,
                    v = new z(1, 1, 1),
                    _ = new xF(m.geometry, m.material, h);
                for (let b = 0; b < h; b++) l.TRANSLATION && A.fromBufferAttribute(l.TRANSLATION, b), l.ROTATION && p.fromBufferAttribute(l.ROTATION, b), l.SCALE && v.fromBufferAttribute(l.SCALE, b), _.setMatrixAt(b, g.compose(A, p, v));
                for (const b in l)
                    if (b === "_COLOR_0") {
                        const w = l[b];
                        _.instanceColor = new wg(w.array, w.itemSize, w.normalized)
                    } else b !== "TRANSLATION" && b !== "ROTATION" && b !== "SCALE" && m.geometry.setAttribute(b, l[b]);
                Ft.prototype.copy.call(_, m), this.parser.assignFinalMaterial(_), f.push(_)
            }
            return u.isGroup ? (u.clear(), u.add(...f), u) : f[0]
        }))
    }
}
const eC = "glTF",
    bc = 12,
    Fb = {
        JSON: 1313821514,
        BIN: 5130562
    };
class X3 {
    constructor(e) {
        this.name = ht.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const t = new DataView(e, 0, bc),
            i = new TextDecoder;
        if (this.header = {
            magic: i.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        }, this.header.magic !== eC) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const s = this.header.length - bc,
            r = new DataView(e, bc);
        let o = 0;
        for (; o < s;) {
            const a = r.getUint32(o, !0);
            o += 4;
            const l = r.getUint32(o, !0);
            if (o += 4, l === Fb.JSON) {
                const c = new Uint8Array(e, bc + o, a);
                this.content = i.decode(c)
            } else if (l === Fb.BIN) {
                const c = bc + o;
                this.body = e.slice(c, c + a)
            }
            o += a
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class K3 {
    constructor(e, t) {
        if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = ht.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const i = this.json,
            s = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
        for (const u in o) {
            const d = Qg[u] || u.toLowerCase();
            a[d] = o[u]
        }
        for (const u in e.attributes) {
            const d = Qg[u] || u.toLowerCase();
            if (o[u] !== void 0) {
                const h = i.accessors[e.attributes[u]],
                    f = Pl[h.componentType];
                c[d] = f.name, l[d] = h.normalized === !0
            }
        }
        return t.getDependency("bufferView", r).then(function (u) {
            return new Promise(function (d, h) {
                s.decodeDracoFile(u, function (f) {
                    for (const m in f.attributes) {
                        const g = f.attributes[m],
                            A = l[m];
                        A !== void 0 && (g.normalized = A)
                    }
                    d(f)
                }, a, c, gi, h)
            })
        })
    }
}
class J3 {
    constructor() {
        this.name = ht.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
    }
}
class Z3 {
    constructor() {
        this.name = ht.KHR_MESH_QUANTIZATION
    }
}
class tC extends Yu {
    constructor(e, t, i, s) {
        super(e, t, i, s)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            i = this.sampleValues,
            s = this.valueSize,
            r = e * s * 3 + s;
        for (let o = 0; o !== s; o++) t[o] = i[r + o];
        return t
    }
    interpolate_(e, t, i, s) {
        const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = a * 2,
            c = a * 3,
            u = s - t,
            d = (i - t) / u,
            h = d * d,
            f = h * d,
            m = e * c,
            g = m - c,
            A = -2 * f + 3 * h,
            p = f - h,
            v = 1 - A,
            _ = p - h + d;
        for (let b = 0; b !== a; b++) {
            const w = o[g + b + a],
                E = o[g + b + l] * u,
                C = o[m + b + a],
                S = o[m + b] * u;
            r[b] = v * w + _ * E + A * C + p * S
        }
        return r
    }
}
const eO = new Tn;
class tO extends tC {
    interpolate_(e, t, i, s) {
        const r = super.interpolate_(e, t, i, s);
        return eO.fromArray(r).normalize().toArray(r), r
    }
}
const Zn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
},
    Pl = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    Nb = {
        9728: Kt,
        9729: Pt,
        9984: tw,
        9985: vh,
        9986: Ic,
        9987: ys
    },
    Ob = {
        33071: pn,
        33648: ef,
        10497: Eo
    },
    rm = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    Qg = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    Ur = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    iO = {
        CUBICSPLINE: void 0,
        LINEAR: Vl,
        STEP: Su
    },
    om = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };

function nO(n) {
    return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new _0({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: wr
    })), n.DefaultMaterial
}

function jo(n, e, t) {
    for (const i in t.extensions) n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i])
}

function jr(n, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}

function sO(n, e, t) {
    let i = !1,
        s = !1,
        r = !1;
    for (let c = 0, u = e.length; c < u; c++) {
        const d = e[c];
        if (d.POSITION !== void 0 && (i = !0), d.NORMAL !== void 0 && (s = !0), d.COLOR_0 !== void 0 && (r = !0), i && s && r) break
    }
    if (!i && !s && !r) return Promise.resolve(n);
    const o = [],
        a = [],
        l = [];
    for (let c = 0, u = e.length; c < u; c++) {
        const d = e[c];
        if (i) {
            const h = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : n.attributes.position;
            o.push(h)
        }
        if (s) {
            const h = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : n.attributes.normal;
            a.push(h)
        }
        if (r) {
            const h = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : n.attributes.color;
            l.push(h)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) {
        const u = c[0],
            d = c[1],
            h = c[2];
        return i && (n.morphAttributes.position = u), s && (n.morphAttributes.normal = d), r && (n.morphAttributes.color = h), n.morphTargetsRelative = !0, n
    })
}

function rO(n, e) {
    if (n.updateMorphTargets(), e.weights !== void 0)
        for (let t = 0, i = e.weights.length; t < i; t++) n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, s = t.length; i < s; i++) n.morphTargetDictionary[t[i]] = i
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function oO(n) {
    let e;
    const t = n.extensions && n.extensions[ht.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + am(t.attributes) : e = n.indices + ":" + am(n.attributes) + ":" + n.mode, n.targets !== void 0)
        for (let i = 0, s = n.targets.length; i < s; i++) e += ":" + am(n.targets[i]);
    return e
}

function am(n) {
    let e = "";
    const t = Object.keys(n).sort();
    for (let i = 0, s = t.length; i < s; i++) e += t[i] + ":" + n[t[i]] + ";";
    return e
}

function zg(n) {
    switch (n) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function aO(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const lO = new Xe;
class cO {
    constructor(e = {}, t = {}) {
        this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new P3, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {
            refs: {},
            uses: {}
        }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let i = !1,
            s = !1,
            r = -1;
        typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, r = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || i || s && r < 98 ? this.textureLoader = new Gw(this.options.manager) : this.textureLoader = new EN(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ws(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const i = this,
            s = this.json,
            r = this.extensions;
        this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (o) {
            return o._markDefs && o._markDefs()
        }), Promise.all(this._invokeAll(function (o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function () {
            return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
        }).then(function (o) {
            const a = {
                scene: o[0][s.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: s.asset,
                parser: i,
                userData: {}
            };
            return jo(r, a, s), jr(a, s), Promise.all(i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function () {
                for (const l of a.scenes) l.updateMatrixWorld();
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || [],
            t = this.json.skins || [],
            i = this.json.meshes || [];
        for (let s = 0, r = t.length; s < r; s++) {
            const o = t[s].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0
        }
        for (let s = 0, r = e.length; s < r; s++) {
            const o = e[s];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
    }
    _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1) return i;
        const s = i.clone(),
            r = (o, a) => {
                const l = this.associations.get(o);
                l != null && this.associations.set(a, l);
                for (const [c, u] of o.children.entries()) r(u, a.children[c])
            };
        return r(i, s), s.name += "_instance_" + e.uses[t]++, s
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            if (s) return s
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let s = 0; s < t.length; s++) {
            const r = e(t[s]);
            r && i.push(r)
        }
        return i
    }
    getDependency(e, t) {
        const i = e + ":" + t;
        let s = this.cache.get(i);
        if (!s) {
            switch (e) {
                case "scene":
                    s = this.loadScene(t);
                    break;
                case "node":
                    s = this._invokeOne(function (r) {
                        return r.loadNode && r.loadNode(t)
                    });
                    break;
                case "mesh":
                    s = this._invokeOne(function (r) {
                        return r.loadMesh && r.loadMesh(t)
                    });
                    break;
                case "accessor":
                    s = this.loadAccessor(t);
                    break;
                case "bufferView":
                    s = this._invokeOne(function (r) {
                        return r.loadBufferView && r.loadBufferView(t)
                    });
                    break;
                case "buffer":
                    s = this.loadBuffer(t);
                    break;
                case "material":
                    s = this._invokeOne(function (r) {
                        return r.loadMaterial && r.loadMaterial(t)
                    });
                    break;
                case "texture":
                    s = this._invokeOne(function (r) {
                        return r.loadTexture && r.loadTexture(t)
                    });
                    break;
                case "skin":
                    s = this.loadSkin(t);
                    break;
                case "animation":
                    s = this._invokeOne(function (r) {
                        return r.loadAnimation && r.loadAnimation(t)
                    });
                    break;
                case "camera":
                    s = this.loadCamera(t);
                    break;
                default:
                    if (s = this._invokeOne(function (r) {
                        return r != this && r.getDependency && r.getDependency(e, t)
                    }), !s) throw new Error("Unknown type: " + e);
                    break
            }
            this.cache.add(i, s)
        }
        return s
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const i = this,
                s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(s.map(function (r, o) {
                return i.getDependency(e, o)
            })), this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e],
            i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[ht.KHR_BINARY_GLTF].body);
        const s = this.options;
        return new Promise(function (r, o) {
            i.load(eu.resolveURL(t.uri, s.path), r, void 0, function () {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        })
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function (i) {
            const s = t.byteLength || 0,
                r = t.byteOffset || 0;
            return i.slice(r, r + s)
        })
    }
    loadAccessor(e) {
        const t = this,
            i = this.json,
            s = this.json.accessors[e];
        if (s.bufferView === void 0 && s.sparse === void 0) {
            const o = rm[s.type],
                a = Pl[s.componentType],
                l = s.normalized === !0,
                c = new a(s.count * o);
            return Promise.resolve(new pi(c, o, l))
        }
        const r = [];
        return s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null), s.sparse !== void 0 && (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(r).then(function (o) {
            const a = o[0],
                l = rm[s.type],
                c = Pl[s.componentType],
                u = c.BYTES_PER_ELEMENT,
                d = u * l,
                h = s.byteOffset || 0,
                f = s.bufferView !== void 0 ? i.bufferViews[s.bufferView].byteStride : void 0,
                m = s.normalized === !0;
            let g, A;
            if (f && f !== d) {
                const p = Math.floor(h / f),
                    v = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + p + ":" + s.count;
                let _ = t.cache.get(v);
                _ || (g = new c(a, p * f, s.count * f / u), _ = new h0(g, f / u), t.cache.add(v, _)), A = new $l(_, l, h % f / u, m)
            } else a === null ? g = new c(s.count * l) : g = new c(a, h, s.count * l), A = new pi(g, l, m);
            if (s.sparse !== void 0) {
                const p = rm.SCALAR,
                    v = Pl[s.sparse.indices.componentType],
                    _ = s.sparse.indices.byteOffset || 0,
                    b = s.sparse.values.byteOffset || 0,
                    w = new v(o[1], _, s.sparse.count * p),
                    E = new c(o[2], b, s.sparse.count * l);
                a !== null && (A = new pi(A.array.slice(), A.itemSize, A.normalized));
                for (let C = 0, S = w.length; C < S; C++) {
                    const x = w[C];
                    if (A.setX(x, E[C * l]), l >= 2 && A.setY(x, E[C * l + 1]), l >= 3 && A.setZ(x, E[C * l + 2]), l >= 4 && A.setW(x, E[C * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return A
        })
    }
    loadTexture(e) {
        const t = this.json,
            i = this.options,
            r = t.textures[e].source,
            o = t.images[r];
        let a = this.textureLoader;
        if (o.uri) {
            const l = i.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, r, a)
    }
    loadTextureImage(e, t, i) {
        const s = this,
            r = this.json,
            o = r.textures[e],
            a = r.images[t],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        const c = this.loadImageSource(t, i).then(function (u) {
            u.flipY = !1, u.name = o.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
            const h = (r.samplers || {})[o.sampler] || {};
            return u.magFilter = Nb[h.magFilter] || Pt, u.minFilter = Nb[h.minFilter] || ys, u.wrapS = Ob[h.wrapS] || Eo, u.wrapT = Ob[h.wrapT] || Eo, s.associations.set(u, {
                textures: e
            }), u
        }).catch(function () {
            return null
        });
        return this.textureCache[l] = c, c
    }
    loadImageSource(e, t) {
        const i = this,
            s = this.json,
            r = this.options;
        if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(d => d.clone());
        const o = s.images[e],
            a = self.URL || self.webkitURL;
        let l = o.uri || "",
            c = !1;
        if (o.bufferView !== void 0) l = i.getDependency("bufferView", o.bufferView).then(function (d) {
            c = !0;
            const h = new Blob([d], {
                type: o.mimeType
            });
            return l = a.createObjectURL(h), l
        });
        else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const u = Promise.resolve(l).then(function (d) {
            return new Promise(function (h, f) {
                let m = h;
                t.isImageBitmapLoader === !0 && (m = function (g) {
                    const A = new oi(g);
                    A.needsUpdate = !0, h(A)
                }), t.load(eu.resolveURL(d, r.path), m, void 0, f)
            })
        }).then(function (d) {
            return c === !0 && a.revokeObjectURL(l), d.userData.mimeType = o.mimeType || aO(o.uri), d
        }).catch(function (d) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), d
        });
        return this.sourceCache[e] = u, u
    }
    assignTexture(e, t, i, s) {
        const r = this;
        return this.getDependency("texture", i.index).then(function (o) {
            if (!o) return null;
            if (i.texCoord !== void 0 && i.texCoord > 0 && (o = o.clone(), o.channel = i.texCoord), r.extensions[ht.KHR_TEXTURE_TRANSFORM]) {
                const a = i.extensions !== void 0 ? i.extensions[ht.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = r.associations.get(o);
                    o = r.extensions[ht.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), r.associations.set(o, l)
                }
            }
            return s !== void 0 && (o.colorSpace = s), e[t] = o, o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const s = t.attributes.tangent === void 0,
            r = t.attributes.color !== void 0,
            o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new gl, In.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(a, l)), i = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new Rl, In.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, this.cache.add(a, l)), i = l
        }
        if (s || r || o) {
            let a = "ClonedMaterial:" + i.uuid + ":";
            s && (a += "derivative-tangents:"), r && (a += "vertex-colors:"), o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = i.clone(), r && (l.vertexColors = !0), o && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(i))), i = l
        }
        e.material = i
    }
    getMaterialType() {
        return _0
    }
    loadMaterial(e) {
        const t = this,
            i = this.json,
            s = this.extensions,
            r = i.materials[e];
        let o;
        const a = {},
            l = r.extensions || {},
            c = [];
        if (l[ht.KHR_MATERIALS_UNLIT]) {
            const d = s[ht.KHR_MATERIALS_UNLIT];
            o = d.getMaterialType(), c.push(d.extendParams(a, r, t))
        } else {
            const d = r.pbrMetallicRoughness || {};
            if (a.color = new Ue(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) {
                const h = d.baseColorFactor;
                a.color.setRGB(h[0], h[1], h[2], gi), a.opacity = h[3]
            }
            d.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", d.baseColorTexture, Wt)), a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), o = this._invokeOne(function (h) {
                return h.getMaterialType && h.getMaterialType(e)
            }), c.push(Promise.all(this._invokeAll(function (h) {
                return h.extendMaterialParams && h.extendMaterialParams(e, a)
            })))
        }
        r.doubleSided === !0 && (a.side = Fs);
        const u = r.alphaMode || om.OPAQUE;
        if (u === om.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === om.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)), r.normalTexture !== void 0 && o !== pr && (c.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new _e(1, 1), r.normalTexture.scale !== void 0)) {
            const d = r.normalTexture.scale;
            a.normalScale.set(d, d)
        }
        if (r.occlusionTexture !== void 0 && o !== pr && (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && o !== pr) {
            const d = r.emissiveFactor;
            a.emissive = new Ue().setRGB(d[0], d[1], d[2], gi)
        }
        return r.emissiveTexture !== void 0 && o !== pr && c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, Wt)), Promise.all(c).then(function () {
            const d = new o(a);
            return r.name && (d.name = r.name), jr(d, r), t.associations.set(d, {
                materials: e
            }), r.extensions && jo(s, d, r), d
        })
    }
    createUniqueName(e) {
        const t = Et.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
    }
    loadGeometries(e) {
        const t = this,
            i = this.extensions,
            s = this.primitiveCache;

        function r(a) {
            return i[ht.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) {
                return Ub(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
                u = oO(c),
                d = s[u];
            if (d) o.push(d.promise);
            else {
                let h;
                c.extensions && c.extensions[ht.KHR_DRACO_MESH_COMPRESSION] ? h = r(c) : h = Ub(new Gi, c, t), s[u] = {
                    primitive: c,
                    promise: h
                }, o.push(h)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this,
            i = this.json,
            s = this.extensions,
            r = i.meshes[e],
            o = r.primitives,
            a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const u = o[l].material === void 0 ? nO(this.cache) : this.getDependency("material", o[l].material);
            a.push(u)
        }
        return a.push(t.loadGeometries(o)), Promise.all(a).then(function (l) {
            const c = l.slice(0, l.length - 1),
                u = l[l.length - 1],
                d = [];
            for (let f = 0, m = u.length; f < m; f++) {
                const g = u[f],
                    A = o[f];
                let p;
                const v = c[f];
                if (A.mode === Zn.TRIANGLES || A.mode === Zn.TRIANGLE_STRIP || A.mode === Zn.TRIANGLE_FAN || A.mode === void 0) p = r.isSkinnedMesh === !0 ? new _F(g, v) : new Ri(g, v), p.isSkinnedMesh === !0 && p.normalizeSkinWeights(), A.mode === Zn.TRIANGLE_STRIP ? p.geometry = kb(p.geometry, cw) : A.mode === Zn.TRIANGLE_FAN && (p.geometry = kb(p.geometry, xg));
                else if (A.mode === Zn.LINES) p = new lf(g, v);
                else if (A.mode === Zn.LINE_STRIP) p = new p0(g, v);
                else if (A.mode === Zn.LINE_LOOP) p = new yF(g, v);
                else if (A.mode === Zn.POINTS) p = new Kc(g, v);
                else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode);
                Object.keys(p.geometry.morphAttributes).length > 0 && rO(p, r), p.name = t.createUniqueName(r.name || "mesh_" + e), jr(p, r), A.extensions && jo(s, p, A), t.assignFinalMaterial(p), d.push(p)
            }
            for (let f = 0, m = d.length; f < m; f++) t.associations.set(d[f], {
                meshes: e,
                primitives: f
            });
            if (d.length === 1) return r.extensions && jo(s, d[0], r), d[0];
            const h = new Hn;
            r.extensions && jo(s, h, r), t.associations.set(h, {
                meshes: e
            });
            for (let f = 0, m = d.length; f < m; f++) h.add(d[f]);
            return h
        })
    }
    loadCamera(e) {
        let t;
        const i = this.json.cameras[e],
            s = i[i.type];
        if (!s) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return i.type === "perspective" ? t = new cn(lr.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : i.type === "orthographic" && (t = new ju(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), i.name && (t.name = this.createUniqueName(i.name)), jr(t, i), Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e],
            i = [];
        for (let s = 0, r = t.joints.length; s < r; s++) i.push(this._loadNodeShallow(t.joints[s]));
        return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function (s) {
            const r = s.pop(),
                o = s,
                a = [],
                l = [];
            for (let c = 0, u = o.length; c < u; c++) {
                const d = o[c];
                if (d) {
                    a.push(d);
                    const h = new Xe;
                    r !== null && h.fromArray(r.array, c * 16), l.push(h)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
            }
            return new f0(a, l)
        })
    }
    loadAnimation(e) {
        const t = this.json,
            i = this,
            s = t.animations[e],
            r = s.name ? s.name : "animation_" + e,
            o = [],
            a = [],
            l = [],
            c = [],
            u = [];
        for (let d = 0, h = s.channels.length; d < h; d++) {
            const f = s.channels[d],
                m = s.samplers[f.sampler],
                g = f.target,
                A = g.node,
                p = s.parameters !== void 0 ? s.parameters[m.input] : m.input,
                v = s.parameters !== void 0 ? s.parameters[m.output] : m.output;
            g.node !== void 0 && (o.push(this.getDependency("node", A)), a.push(this.getDependency("accessor", p)), l.push(this.getDependency("accessor", v)), c.push(m), u.push(g))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(u)]).then(function (d) {
            const h = d[0],
                f = d[1],
                m = d[2],
                g = d[3],
                A = d[4],
                p = [];
            for (let v = 0, _ = h.length; v < _; v++) {
                const b = h[v],
                    w = f[v],
                    E = m[v],
                    C = g[v],
                    S = A[v];
                if (b === void 0) continue;
                b.updateMatrix && b.updateMatrix();
                const x = i._createAnimationTracks(b, w, E, C, S);
                if (x)
                    for (let y = 0; y < x.length; y++) p.push(x[y])
            }
            return new Ig(r, void 0, p)
        })
    }
    createNodeMesh(e) {
        const t = this.json,
            i = this,
            s = t.nodes[e];
        return s.mesh === void 0 ? null : i.getDependency("mesh", s.mesh).then(function (r) {
            const o = i._getNodeRef(i.meshCache, s.mesh, r);
            return s.weights !== void 0 && o.traverse(function (a) {
                if (a.isMesh)
                    for (let l = 0, c = s.weights.length; l < c; l++) a.morphTargetInfluences[l] = s.weights[l]
            }), o
        })
    }
    loadNode(e) {
        const t = this.json,
            i = this,
            s = t.nodes[e],
            r = i._loadNodeShallow(e),
            o = [],
            a = s.children || [];
        for (let c = 0, u = a.length; c < u; c++) o.push(i.getDependency("node", a[c]));
        const l = s.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", s.skin);
        return Promise.all([r, Promise.all(o), l]).then(function (c) {
            const u = c[0],
                d = c[1],
                h = c[2];
            h !== null && u.traverse(function (f) {
                f.isSkinnedMesh && f.bind(h, lO)
            });
            for (let f = 0, m = d.length; f < m; f++) u.add(d[f]);
            return u
        })
    }
    _loadNodeShallow(e) {
        const t = this.json,
            i = this.extensions,
            s = this;
        if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
        const r = t.nodes[e],
            o = r.name ? s.createUniqueName(r.name) : "",
            a = [],
            l = s._invokeOne(function (c) {
                return c.createNodeMesh && c.createNodeMesh(e)
            });
        return l && a.push(l), r.camera !== void 0 && a.push(s.getDependency("camera", r.camera).then(function (c) {
            return s._getNodeRef(s.cameraCache, r.camera, c)
        })), s._invokeAll(function (c) {
            return c.createNodeAttachment && c.createNodeAttachment(e)
        }).forEach(function (c) {
            a.push(c)
        }), this.nodeCache[e] = Promise.all(a).then(function (c) {
            let u;
            if (r.isBone === !0 ? u = new Bw : c.length > 1 ? u = new Hn : c.length === 1 ? u = c[0] : u = new Ft, u !== c[0])
                for (let d = 0, h = c.length; d < h; d++) u.add(c[d]);
            if (r.name && (u.userData.name = r.name, u.name = o), jr(u, r), r.extensions && jo(i, u, r), r.matrix !== void 0) {
                const d = new Xe;
                d.fromArray(r.matrix), u.applyMatrix4(d)
            } else r.translation !== void 0 && u.position.fromArray(r.translation), r.rotation !== void 0 && u.quaternion.fromArray(r.rotation), r.scale !== void 0 && u.scale.fromArray(r.scale);
            return s.associations.has(u) || s.associations.set(u, {}), s.associations.get(u).nodes = e, u
        }), this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions,
            i = this.json.scenes[e],
            s = this,
            r = new Hn;
        i.name && (r.name = s.createUniqueName(i.name)), jr(r, i), i.extensions && jo(t, r, i);
        const o = i.nodes || [],
            a = [];
        for (let l = 0, c = o.length; l < c; l++) a.push(s.getDependency("node", o[l]));
        return Promise.all(a).then(function (l) {
            for (let u = 0, d = l.length; u < d; u++) r.add(l[u]);
            const c = u => {
                const d = new Map;
                for (const [h, f] of s.associations) (h instanceof In || h instanceof oi) && d.set(h, f);
                return u.traverse(h => {
                    const f = s.associations.get(h);
                    f != null && d.set(h, f)
                }), d
            };
            return s.associations = c(r), r
        })
    }
    _createAnimationTracks(e, t, i, s, r) {
        const o = [],
            a = e.name ? e.name : e.uuid,
            l = [];
        Ur[r.path] === Ur.weights ? e.traverse(function (h) {
            h.morphTargetInfluences && l.push(h.name ? h.name : h.uuid)
        }) : l.push(a);
        let c;
        switch (Ur[r.path]) {
            case Ur.weights:
                c = jl;
                break;
            case Ur.rotation:
                c = wa;
                break;
            case Ur.position:
            case Ur.scale:
                c = Yl;
                break;
            default:
                switch (i.itemSize) {
                    case 1:
                        c = jl;
                        break;
                    case 2:
                    case 3:
                    default:
                        c = Yl;
                        break
                }
                break
        }
        const u = s.interpolation !== void 0 ? iO[s.interpolation] : Vl,
            d = this._getArrayFromAccessor(i);
        for (let h = 0, f = l.length; h < f; h++) {
            const m = new c(l[h] + "." + Ur[r.path], t.array, d, u);
            s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), o.push(m)
        }
        return o
    }
    _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
            const i = zg(t.constructor),
                s = new Float32Array(t.length);
            for (let r = 0, o = t.length; r < o; r++) s[r] = t[r] * i;
            t = s
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function (i) {
            const s = this instanceof wa ? tO : tC;
            return new s(this.times, this.values, this.getValueSize() / 3, i)
        }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}

function uO(n, e, t) {
    const i = e.attributes,
        s = new Sr;
    if (i.POSITION !== void 0) {
        const a = t.json.accessors[i.POSITION],
            l = a.min,
            c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (s.set(new z(l[0], l[1], l[2]), new z(c[0], c[1], c[2])), a.normalized) {
                const u = zg(Pl[a.componentType]);
                s.min.multiplyScalar(u), s.max.multiplyScalar(u)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else return;
    const r = e.targets;
    if (r !== void 0) {
        const a = new z,
            l = new z;
        for (let c = 0, u = r.length; c < u; c++) {
            const d = r[c];
            if (d.POSITION !== void 0) {
                const h = t.json.accessors[d.POSITION],
                    f = h.min,
                    m = h.max;
                if (f !== void 0 && m !== void 0) {
                    if (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))), h.normalized) {
                        const g = zg(Pl[h.componentType]);
                        l.multiplyScalar(g)
                    }
                    a.max(l)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        s.expandByVector(a)
    }
    n.boundingBox = s;
    const o = new js;
    s.getCenter(o.center), o.radius = s.min.distanceTo(s.max) / 2, n.boundingSphere = o
}

function Ub(n, e, t) {
    const i = e.attributes,
        s = [];

    function r(o, a) {
        return t.getDependency("accessor", o).then(function (l) {
            n.setAttribute(a, l)
        })
    }
    for (const o in i) {
        const a = Qg[o] || o.toLowerCase();
        a in n.attributes || s.push(r(i[o], a))
    }
    if (e.indices !== void 0 && !n.index) {
        const o = t.getDependency("accessor", e.indices).then(function (a) {
            n.setIndex(a)
        });
        s.push(o)
    }
    return vt.workingColorSpace !== gi && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${vt.workingColorSpace}" not supported.`), jr(n, e), uO(n, e, t), Promise.all(s).then(function () {
        return e.targets !== void 0 ? sO(n, e.targets, t) : n
    })
}
const dO = /^[og]\s*(.+)?/,
    hO = /^mtllib /,
    fO = /^usemtl /,
    pO = /^usemap /,
    Qb = /\s+/,
    zb = new z,
    lm = new z,
    Gb = new z,
    Hb = new z,
    Kn = new z,
    jd = new Ue;

function mO() {
    const n = {
        objects: [],
        object: {},
        vertices: [],
        normals: [],
        colors: [],
        uvs: [],
        materials: {},
        materialLibraries: [],
        startObject: function (e, t) {
            if (this.object && this.object.fromDeclaration === !1) {
                this.object.name = e, this.object.fromDeclaration = t !== !1;
                return
            }
            const i = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
            if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
                name: e || "",
                fromDeclaration: t !== !1,
                geometry: {
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
                    hasUVIndices: !1
                },
                materials: [],
                smooth: !0,
                startMaterial: function (s, r) {
                    const o = this._finalize(!1);
                    o && (o.inherited || o.groupCount <= 0) && this.materials.splice(o.index, 1);
                    const a = {
                        index: this.materials.length,
                        name: s || "",
                        mtllib: Array.isArray(r) && r.length > 0 ? r[r.length - 1] : "",
                        smooth: o !== void 0 ? o.smooth : this.smooth,
                        groupStart: o !== void 0 ? o.groupEnd : 0,
                        groupEnd: -1,
                        groupCount: -1,
                        inherited: !1,
                        clone: function (l) {
                            const c = {
                                index: typeof l == "number" ? l : this.index,
                                name: this.name,
                                mtllib: this.mtllib,
                                smooth: this.smooth,
                                groupStart: 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: !1
                            };
                            return c.clone = this.clone.bind(c), c
                        }
                    };
                    return this.materials.push(a), a
                },
                currentMaterial: function () {
                    if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                },
                _finalize: function (s) {
                    const r = this.currentMaterial();
                    if (r && r.groupEnd === -1 && (r.groupEnd = this.geometry.vertices.length / 3, r.groupCount = r.groupEnd - r.groupStart, r.inherited = !1), s && this.materials.length > 1)
                        for (let o = this.materials.length - 1; o >= 0; o--) this.materials[o].groupCount <= 0 && this.materials.splice(o, 1);
                    return s && this.materials.length === 0 && this.materials.push({
                        name: "",
                        smooth: this.smooth
                    }), r
                }
            }, i && i.name && typeof i.clone == "function") {
                const s = i.clone(0);
                s.inherited = !0, this.object.materials.push(s)
            }
            this.objects.push(this.object)
        },
        finalize: function () {
            this.object && typeof this.object._finalize == "function" && this.object._finalize(!0)
        },
        parseVertexIndex: function (e, t) {
            const i = parseInt(e, 10);
            return (i >= 0 ? i - 1 : i + t / 3) * 3
        },
        parseNormalIndex: function (e, t) {
            const i = parseInt(e, 10);
            return (i >= 0 ? i - 1 : i + t / 3) * 3
        },
        parseUVIndex: function (e, t) {
            const i = parseInt(e, 10);
            return (i >= 0 ? i - 1 : i + t / 2) * 2
        },
        addVertex: function (e, t, i) {
            const s = this.vertices,
                r = this.object.geometry.vertices;
            r.push(s[e + 0], s[e + 1], s[e + 2]), r.push(s[t + 0], s[t + 1], s[t + 2]), r.push(s[i + 0], s[i + 1], s[i + 2])
        },
        addVertexPoint: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
        },
        addVertexLine: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
        },
        addNormal: function (e, t, i) {
            const s = this.normals,
                r = this.object.geometry.normals;
            r.push(s[e + 0], s[e + 1], s[e + 2]), r.push(s[t + 0], s[t + 1], s[t + 2]), r.push(s[i + 0], s[i + 1], s[i + 2])
        },
        addFaceNormal: function (e, t, i) {
            const s = this.vertices,
                r = this.object.geometry.normals;
            zb.fromArray(s, e), lm.fromArray(s, t), Gb.fromArray(s, i), Kn.subVectors(Gb, lm), Hb.subVectors(zb, lm), Kn.cross(Hb), Kn.normalize(), r.push(Kn.x, Kn.y, Kn.z), r.push(Kn.x, Kn.y, Kn.z), r.push(Kn.x, Kn.y, Kn.z)
        },
        addColor: function (e, t, i) {
            const s = this.colors,
                r = this.object.geometry.colors;
            s[e] !== void 0 && r.push(s[e + 0], s[e + 1], s[e + 2]), s[t] !== void 0 && r.push(s[t + 0], s[t + 1], s[t + 2]), s[i] !== void 0 && r.push(s[i + 0], s[i + 1], s[i + 2])
        },
        addUV: function (e, t, i) {
            const s = this.uvs,
                r = this.object.geometry.uvs;
            r.push(s[e + 0], s[e + 1]), r.push(s[t + 0], s[t + 1]), r.push(s[i + 0], s[i + 1])
        },
        addDefaultUV: function () {
            const e = this.object.geometry.uvs;
            e.push(0, 0), e.push(0, 0), e.push(0, 0)
        },
        addUVLine: function (e) {
            const t = this.uvs;
            this.object.geometry.uvs.push(t[e + 0], t[e + 1])
        },
        addFace: function (e, t, i, s, r, o, a, l, c) {
            const u = this.vertices.length;
            let d = this.parseVertexIndex(e, u),
                h = this.parseVertexIndex(t, u),
                f = this.parseVertexIndex(i, u);
            if (this.addVertex(d, h, f), this.addColor(d, h, f), a !== void 0 && a !== "") {
                const m = this.normals.length;
                d = this.parseNormalIndex(a, m), h = this.parseNormalIndex(l, m), f = this.parseNormalIndex(c, m), this.addNormal(d, h, f)
            } else this.addFaceNormal(d, h, f);
            if (s !== void 0 && s !== "") {
                const m = this.uvs.length;
                d = this.parseUVIndex(s, m), h = this.parseUVIndex(r, m), f = this.parseUVIndex(o, m), this.addUV(d, h, f), this.object.geometry.hasUVIndices = !0
            } else this.addDefaultUV()
        },
        addPointGeometry: function (e) {
            this.object.geometry.type = "Points";
            const t = this.vertices.length;
            for (let i = 0, s = e.length; i < s; i++) {
                const r = this.parseVertexIndex(e[i], t);
                this.addVertexPoint(r), this.addColor(r)
            }
        },
        addLineGeometry: function (e, t) {
            this.object.geometry.type = "Line";
            const i = this.vertices.length,
                s = this.uvs.length;
            for (let r = 0, o = e.length; r < o; r++) this.addVertexLine(this.parseVertexIndex(e[r], i));
            for (let r = 0, o = t.length; r < o; r++) this.addUVLine(this.parseUVIndex(t[r], s))
        }
    };
    return n.startObject("", !1), n
}
class gO extends $n {
    constructor(e) {
        super(e), this.materials = null
    }
    load(e, t, i, s) {
        const r = this,
            o = new ws(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) {
            try {
                t(r.parse(a))
            } catch (l) {
                s ? s(l) : console.error(l), r.manager.itemError(e)
            }
        }, i, s)
    }
    setMaterials(e) {
        return this.materials = e, this
    }
    parse(e) {
        const t = new mO;
        e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
        const i = e.split(`
`);
        let s = [];
        for (let a = 0, l = i.length; a < l; a++) {
            const c = i[a].trimStart();
            if (c.length === 0) continue;
            const u = c.charAt(0);
            if (u !== "#")
                if (u === "v") {
                    const d = c.split(Qb);
                    switch (d[0]) {
                        case "v":
                            t.vertices.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])), d.length >= 7 ? (jd.setRGB(parseFloat(d[4]), parseFloat(d[5]), parseFloat(d[6])).convertSRGBToLinear(), t.colors.push(jd.r, jd.g, jd.b)) : t.colors.push(void 0, void 0, void 0);
                            break;
                        case "vn":
                            t.normals.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]));
                            break;
                        case "vt":
                            t.uvs.push(parseFloat(d[1]), parseFloat(d[2]));
                            break
                    }
                } else if (u === "f") {
                    const h = c.slice(1).trim().split(Qb),
                        f = [];
                    for (let g = 0, A = h.length; g < A; g++) {
                        const p = h[g];
                        if (p.length > 0) {
                            const v = p.split("/");
                            f.push(v)
                        }
                    }
                    const m = f[0];
                    for (let g = 1, A = f.length - 1; g < A; g++) {
                        const p = f[g],
                            v = f[g + 1];
                        t.addFace(m[0], p[0], v[0], m[1], p[1], v[1], m[2], p[2], v[2])
                    }
                } else if (u === "l") {
                    const d = c.substring(1).trim().split(" ");
                    let h = [];
                    const f = [];
                    if (c.indexOf("/") === -1) h = d;
                    else
                        for (let m = 0, g = d.length; m < g; m++) {
                            const A = d[m].split("/");
                            A[0] !== "" && h.push(A[0]), A[1] !== "" && f.push(A[1])
                        }
                    t.addLineGeometry(h, f)
                } else if (u === "p") {
                    const h = c.slice(1).trim().split(" ");
                    t.addPointGeometry(h)
                } else if ((s = dO.exec(c)) !== null) {
                    const d = (" " + s[0].slice(1).trim()).slice(1);
                    t.startObject(d)
                } else if (fO.test(c)) t.object.startMaterial(c.substring(7).trim(), t.materialLibraries);
                else if (hO.test(c)) t.materialLibraries.push(c.substring(7).trim());
                else if (pO.test(c)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                else if (u === "s") {
                    if (s = c.split(" "), s.length > 1) {
                        const h = s[1].trim().toLowerCase();
                        t.object.smooth = h !== "0" && h !== "off"
                    } else t.object.smooth = !0;
                    const d = t.object.currentMaterial();
                    d && (d.smooth = t.object.smooth)
                } else {
                    if (c === "\0") continue;
                    console.warn('THREE.OBJLoader: Unexpected line: "' + c + '"')
                }
        }
        t.finalize();
        const r = new Hn;
        if (r.materialLibraries = [].concat(t.materialLibraries), !(t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0) === !0)
            for (let a = 0, l = t.objects.length; a < l; a++) {
                const c = t.objects[a],
                    u = c.geometry,
                    d = c.materials,
                    h = u.type === "Line",
                    f = u.type === "Points";
                let m = !1;
                if (u.vertices.length === 0) continue;
                const g = new Gi;
                g.setAttribute("position", new xi(u.vertices, 3)), u.normals.length > 0 && g.setAttribute("normal", new xi(u.normals, 3)), u.colors.length > 0 && (m = !0, g.setAttribute("color", new xi(u.colors, 3))), u.hasUVIndices === !0 && g.setAttribute("uv", new xi(u.uvs, 2));
                const A = [];
                for (let v = 0, _ = d.length; v < _; v++) {
                    const b = d[v],
                        w = b.name + "_" + b.smooth + "_" + m;
                    let E = t.materials[w];
                    if (this.materials !== null) {
                        if (E = this.materials.create(b.name), h && E && !(E instanceof Rl)) {
                            const C = new Rl;
                            In.prototype.copy.call(C, E), C.color.copy(E.color), E = C
                        } else if (f && E && !(E instanceof gl)) {
                            const C = new gl({
                                size: 10,
                                sizeAttenuation: !1
                            });
                            In.prototype.copy.call(C, E), C.color.copy(E.color), C.map = E.map, E = C
                        }
                    }
                    E === void 0 && (h ? E = new Rl : f ? E = new gl({
                        size: 1,
                        sizeAttenuation: !1
                    }) : E = new sN, E.name = b.name, E.flatShading = !b.smooth, E.vertexColors = m, t.materials[w] = E), A.push(E)
                }
                let p;
                if (A.length > 1) {
                    for (let v = 0, _ = d.length; v < _; v++) {
                        const b = d[v];
                        g.addGroup(b.groupStart, b.groupCount, v)
                    }
                    h ? p = new lf(g, A) : f ? p = new Kc(g, A) : p = new Ri(g, A)
                } else h ? p = new lf(g, A[0]) : f ? p = new Kc(g, A[0]) : p = new Ri(g, A[0]);
                p.name = c.name, r.add(p)
            } else if (t.vertices.length > 0) {
                const a = new gl({
                    size: 1,
                    sizeAttenuation: !1
                }),
                    l = new Gi;
                l.setAttribute("position", new xi(t.vertices, 3)), t.colors.length > 0 && t.colors[0] !== void 0 && (l.setAttribute("color", new xi(t.colors, 3)), a.vertexColors = !0);
                const c = new Kc(l, a);
                r.add(c)
            }
        return r
    }
}
class AO extends $n {
    constructor(e) {
        super(e)
    }
    load(e, t, i, s) {
        const r = this,
            o = new ws(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) {
            const l = r.parse(JSON.parse(a));
            t && t(l)
        }, i, s)
    }
    parse(e) {
        return new _O(e)
    }
}
class _O {
    constructor(e) {
        this.isFont = !0, this.type = "Font", this.data = e
    }
    generateShapes(e, t = 100) {
        const i = [],
            s = vO(e, t, this.data);
        for (let r = 0, o = s.length; r < o; r++) i.push(...s[r].toShapes());
        return i
    }
}

function vO(n, e, t) {
    const i = Array.from(n),
        s = e / t.resolution,
        r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * s,
        o = [];
    let a = 0,
        l = 0;
    for (let c = 0; c < i.length; c++) {
        const u = i[c];
        if (u === `
`) a = 0, l -= r;
        else {
            const d = bO(u, s, a, l, t);
            a += d.offsetX, o.push(d.path)
        }
    }
    return o
}

function bO(n, e, t, i, s) {
    const r = s.glyphs[n] || s.glyphs["?"];
    if (!r) {
        console.error('THREE.Font: character "' + n + '" does not exists in font family ' + s.familyName + ".");
        return
    }
    const o = new GN;
    let a, l, c, u, d, h, f, m;
    if (r.o) {
        const g = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
        for (let A = 0, p = g.length; A < p;) switch (g[A++]) {
            case "m":
                a = g[A++] * e + t, l = g[A++] * e + i, o.moveTo(a, l);
                break;
            case "l":
                a = g[A++] * e + t, l = g[A++] * e + i, o.lineTo(a, l);
                break;
            case "q":
                c = g[A++] * e + t, u = g[A++] * e + i, d = g[A++] * e + t, h = g[A++] * e + i, o.quadraticCurveTo(d, h, c, u);
                break;
            case "b":
                c = g[A++] * e + t, u = g[A++] * e + i, d = g[A++] * e + t, h = g[A++] * e + i, f = g[A++] * e + t, m = g[A++] * e + i, o.bezierCurveTo(d, h, f, m, c, u);
                break
        }
    }
    return {
        offsetX: r.ha * e,
        path: o
    }
}
class xO extends gN {
    constructor(e) {
        super(e), this.type = yi
    }
    parse(e) {
        const o = function (S, x) {
            switch (S) {
                case 1:
                    throw new Error("THREE.RGBELoader: Read Error: " + (x || ""));
                case 2:
                    throw new Error("THREE.RGBELoader: Write Error: " + (x || ""));
                case 3:
                    throw new Error("THREE.RGBELoader: Bad File Format: " + (x || ""));
                default:
                case 4:
                    throw new Error("THREE.RGBELoader: Memory Error: " + (x || ""))
            }
        },
            u = `
`,
            d = function (S, x, y) {
                x = x || 1024;
                let T = S.pos,
                    R = -1,
                    D = 0,
                    U = "",
                    Q = String.fromCharCode.apply(null, new Uint16Array(S.subarray(T, T + 128)));
                for (; 0 > (R = Q.indexOf(u)) && D < x && T < S.byteLength;) U += Q, D += Q.length, T += 128, Q += String.fromCharCode.apply(null, new Uint16Array(S.subarray(T, T + 128)));
                return -1 < R ? (y !== !1 && (S.pos += D + R + 1), U + Q.slice(0, R)) : !1
            },
            h = function (S) {
                const x = /^#\?(\S+)/,
                    y = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                    P = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                    T = /^\s*FORMAT=(\S+)\s*$/,
                    R = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                    D = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                let U, Q;
                for ((S.pos >= S.byteLength || !(U = d(S))) && o(1, "no header found"), (Q = U.match(x)) || o(3, "bad initial token"), D.valid |= 1, D.programtype = Q[1], D.string += U + `
`; U = d(S), U !== !1;) {
                    if (D.string += U + `
`, U.charAt(0) === "#") {
                        D.comments += U + `
`;
                        continue
                    }
                    if ((Q = U.match(y)) && (D.gamma = parseFloat(Q[1])), (Q = U.match(P)) && (D.exposure = parseFloat(Q[1])), (Q = U.match(T)) && (D.valid |= 2, D.format = Q[1]), (Q = U.match(R)) && (D.valid |= 4, D.height = parseInt(Q[1], 10), D.width = parseInt(Q[2], 10)), D.valid & 2 && D.valid & 4) break
                }
                return D.valid & 2 || o(3, "missing format specifier"), D.valid & 4 || o(3, "missing image size specifier"), D
            },
            f = function (S, x, y) {
                const P = x;
                if (P < 8 || P > 32767 || S[0] !== 2 || S[1] !== 2 || S[2] & 128) return new Uint8Array(S);
                P !== (S[2] << 8 | S[3]) && o(3, "wrong scanline width");
                const T = new Uint8Array(4 * x * y);
                T.length || o(4, "unable to allocate buffer space");
                let R = 0,
                    D = 0;
                const U = 4 * P,
                    Q = new Uint8Array(4),
                    F = new Uint8Array(U);
                let L = y;
                for (; L > 0 && D < S.byteLength;) {
                    D + 4 > S.byteLength && o(1), Q[0] = S[D++], Q[1] = S[D++], Q[2] = S[D++], Q[3] = S[D++], (Q[0] != 2 || Q[1] != 2 || (Q[2] << 8 | Q[3]) != P) && o(3, "bad rgbe scanline format");
                    let W = 0,
                        k;
                    for (; W < U && D < S.byteLength;) {
                        k = S[D++];
                        const X = k > 128;
                        if (X && (k -= 128), (k === 0 || W + k > U) && o(3, "bad scanline data"), X) {
                            const le = S[D++];
                            for (let K = 0; K < k; K++) F[W++] = le
                        } else F.set(S.subarray(D, D + k), W), W += k, D += k
                    }
                    const $ = P;
                    for (let X = 0; X < $; X++) {
                        let le = 0;
                        T[R] = F[X + le], le += P, T[R + 1] = F[X + le], le += P, T[R + 2] = F[X + le], le += P, T[R + 3] = F[X + le], R += 4
                    }
                    L--
                }
                return T
            },
            m = function (S, x, y, P) {
                const T = S[x + 3],
                    R = Math.pow(2, T - 128) / 255;
                y[P + 0] = S[x + 0] * R, y[P + 1] = S[x + 1] * R, y[P + 2] = S[x + 2] * R, y[P + 3] = 1
            },
            g = function (S, x, y, P) {
                const T = S[x + 3],
                    R = Math.pow(2, T - 128) / 255;
                y[P + 0] = Ad.toHalfFloat(Math.min(S[x + 0] * R, 65504)), y[P + 1] = Ad.toHalfFloat(Math.min(S[x + 1] * R, 65504)), y[P + 2] = Ad.toHalfFloat(Math.min(S[x + 2] * R, 65504)), y[P + 3] = Ad.toHalfFloat(1)
            },
            A = new Uint8Array(e);
        A.pos = 0;
        const p = h(A),
            v = p.width,
            _ = p.height,
            b = f(A.subarray(A.pos), v, _);
        let w, E, C;
        switch (this.type) {
            case ei:
                C = b.length / 4;
                const S = new Float32Array(C * 4);
                for (let y = 0; y < C; y++) m(b, y * 4, S, y * 4);
                w = S, E = ei;
                break;
            case yi:
                C = b.length / 4;
                const x = new Uint16Array(C * 4);
                for (let y = 0; y < C; y++) g(b, y * 4, x, y * 4);
                w = x, E = yi;
                break;
            default:
                throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: v,
            height: _,
            data: w,
            header: p.string,
            gamma: p.gamma,
            exposure: p.exposure,
            type: E
        }
    }
    setDataType(e) {
        return this.type = e, this
    }
    load(e, t, i, s) {
        function r(o, a) {
            switch (o.type) {
                case ei:
                case yi:
                    o.colorSpace = gi, o.minFilter = Pt, o.magFilter = Pt, o.generateMipmaps = !1, o.flipY = !0;
                    break
            }
            t && t(o, a)
        }
        return super.load(e, r, i, s)
    }
}
const cm = new WeakMap;
class yO extends $n {
    constructor(e) {
        super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e, this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e, this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e, this
    }
    load(e, t, i, s) {
        const r = new ws(this.manager);
        r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, o => {
            this.parse(o, t, s)
        }, i, s)
    }
    parse(e, t, i = () => { }) {
        this.decodeDracoFile(e, t, null, null, Wt).catch(i)
    }
    decodeDracoFile(e, t, i, s, r = gi, o = () => { }) {
        const a = {
            attributeIDs: i || this.defaultAttributeIDs,
            attributeTypes: s || this.defaultAttributeTypes,
            useUniqueIDs: !!i,
            vertexColorSpace: r
        };
        return this.decodeGeometry(e, a).then(t).catch(o)
    }
    decodeGeometry(e, t) {
        const i = JSON.stringify(t);
        if (cm.has(e)) {
            const l = cm.get(e);
            if (l.key === i) return l.promise;
            if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let s;
        const r = this.workerNextTaskID++,
            o = e.byteLength,
            a = this._getWorker(r, o).then(l => (s = l, new Promise((c, u) => {
                s._callbacks[r] = {
                    resolve: c,
                    reject: u
                }, s.postMessage({
                    type: "decode",
                    id: r,
                    taskConfig: t,
                    buffer: e
                }, [e])
            }))).then(l => this._createGeometry(l.geometry));
        return a.catch(() => !0).then(() => {
            s && r && this._releaseTask(s, r)
        }), cm.set(e, {
            key: i,
            promise: a
        }), a
    }
    _createGeometry(e) {
        const t = new Gi;
        e.index && t.setIndex(new pi(e.index.array, 1));
        for (let i = 0; i < e.attributes.length; i++) {
            const s = e.attributes[i],
                r = s.name,
                o = s.array,
                a = s.itemSize,
                l = new pi(o, a);
            r === "color" && (this._assignVertexColorSpace(l, s.vertexColorSpace), l.normalized = !(o instanceof Float32Array)), t.setAttribute(r, l)
        }
        return t
    }
    _assignVertexColorSpace(e, t) {
        if (t !== Wt) return;
        const i = new Ue;
        for (let s = 0, r = e.count; s < r; s++) i.fromBufferAttribute(e, s).convertSRGBToLinear(), e.setXYZ(s, i.r, i.g, i.b)
    }
    _loadLibrary(e, t) {
        const i = new ws(this.manager);
        return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((s, r) => {
            i.load(e, s, void 0, r)
        })
    }
    preload() {
        return this._initDecoder(), this
    }
    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
            t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(i => {
            const s = i[0];
            e || (this.decoderConfig.wasmBinary = i[1]);
            const r = EO.toString(),
                o = ["/* draco decoder */", s, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }), this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
                const s = new Worker(this.workerSourceURL);
                s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }), s.onmessage = function (r) {
                    const o = r.data;
                    switch (o.type) {
                        case "decode":
                            s._callbacks[o.id].resolve(o);
                            break;
                        case "error":
                            s._callbacks[o.id].reject(o);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }, this.workerPool.push(s)
            } else this.workerPool.sort(function (s, r) {
                return s._taskLoad > r._taskLoad ? -1 : 1
            });
            const i = this.workerPool[this.workerPool.length - 1];
            return i._taskCosts[e] = t, i._taskLoad += t, i
        })
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
        return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this
    }
}

function EO() {
    let n, e;
    onmessage = function (o) {
        const a = o.data;
        switch (a.type) {
            case "init":
                n = a.decoderConfig, e = new Promise(function (u) {
                    n.onModuleLoaded = function (d) {
                        u({
                            draco: d
                        })
                    }, DracoDecoderModule(n)
                });
                break;
            case "decode":
                const l = a.buffer,
                    c = a.taskConfig;
                e.then(u => {
                    const d = u.draco,
                        h = new d.Decoder;
                    try {
                        const f = t(d, h, new Int8Array(l), c),
                            m = f.attributes.map(g => g.array.buffer);
                        f.index && m.push(f.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: a.id,
                            geometry: f
                        }, m)
                    } catch (f) {
                        console.error(f), self.postMessage({
                            type: "error",
                            id: a.id,
                            error: f.message
                        })
                    } finally {
                        d.destroy(h)
                    }
                });
                break
        }
    };

    function t(o, a, l, c) {
        const u = c.attributeIDs,
            d = c.attributeTypes;
        let h, f;
        const m = a.GetEncodedGeometryType(l);
        if (m === o.TRIANGULAR_MESH) h = new o.Mesh, f = a.DecodeArrayToMesh(l, l.byteLength, h);
        else if (m === o.POINT_CLOUD) h = new o.PointCloud, f = a.DecodeArrayToPointCloud(l, l.byteLength, h);
        else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!f.ok() || h.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
        const g = {
            index: null,
            attributes: []
        };
        for (const A in u) {
            const p = self[d[A]];
            let v, _;
            if (c.useUniqueIDs) _ = u[A], v = a.GetAttributeByUniqueId(h, _);
            else {
                if (_ = a.GetAttributeId(h, o[u[A]]), _ === -1) continue;
                v = a.GetAttribute(h, _)
            }
            const b = s(o, a, h, A, p, v);
            A === "color" && (b.vertexColorSpace = c.vertexColorSpace), g.attributes.push(b)
        }
        return m === o.TRIANGULAR_MESH && (g.index = i(o, a, h)), o.destroy(h), g
    }

    function i(o, a, l) {
        const u = l.num_faces() * 3,
            d = u * 4,
            h = o._malloc(d);
        a.GetTrianglesUInt32Array(l, d, h);
        const f = new Uint32Array(o.HEAPF32.buffer, h, u).slice();
        return o._free(h), {
            array: f,
            itemSize: 1
        }
    }

    function s(o, a, l, c, u, d) {
        const h = d.num_components(),
            m = l.num_points() * h,
            g = m * u.BYTES_PER_ELEMENT,
            A = r(o, u),
            p = o._malloc(g);
        a.GetAttributeDataArrayForAllPoints(l, d, A, g, p);
        const v = new u(o.HEAPF32.buffer, p, m).slice();
        return o._free(p), {
            name: c,
            array: v,
            itemSize: h
        }
    }

    function r(o, a) {
        switch (a) {
            case Float32Array:
                return o.DT_FLOAT32;
            case Int8Array:
                return o.DT_INT8;
            case Int16Array:
                return o.DT_INT16;
            case Int32Array:
                return o.DT_INT32;
            case Uint8Array:
                return o.DT_UINT8;
            case Uint16Array:
                return o.DT_UINT16;
            case Uint32Array:
                return o.DT_UINT32
        }
    }
}
class wO {
    constructor(e = 4) {
        this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
    }
    _initWorker(e) {
        if (!this.workers[e]) {
            const t = this.workerCreator();
            t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t
        }
    }
    _getIdleWorker() {
        for (let e = 0; e < this.pool; e++)
            if (!(this.workerStatus & 1 << e)) return e;
        return -1
    }
    _onMessage(e, t) {
        const i = this.workersResolve[e];
        if (i && i(t), this.queue.length) {
            const {
                resolve: s,
                msg: r,
                transfer: o
            } = this.queue.shift();
            this.workersResolve[e] = s, this.workers[e].postMessage(r, o)
        } else this.workerStatus ^= 1 << e
    }
    setWorkerCreator(e) {
        this.workerCreator = e
    }
    setWorkerLimit(e) {
        this.pool = e
    }
    postMessage(e, t) {
        return new Promise(i => {
            const s = this._getIdleWorker();
            s !== -1 ? (this._initWorker(s), this.workerStatus |= 1 << s, this.workersResolve[s] = i, this.workers[s].postMessage(e, t)) : this.queue.push({
                resolve: i,
                msg: e,
                transfer: t
            })
        })
    }
    dispose() {
        this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
    }
}
const CO = 0,
    Vb = 2,
    SO = 1,
    Wb = 2,
    MO = 0,
    TO = 1,
    IO = 10,
    BO = 0,
    iC = 9,
    nC = 15,
    sC = 16,
    rC = 22,
    oC = 37,
    aC = 43,
    lC = 76,
    cC = 83,
    uC = 97,
    dC = 100,
    hC = 103,
    fC = 109,
    pC = 165,
    mC = 166;
class RO {
    constructor() {
        this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
            vendorId: 0,
            descriptorType: 0,
            descriptorBlockSize: 0,
            versionNumber: 2,
            colorModel: 0,
            colorPrimaries: 1,
            transferFunction: 2,
            flags: 0,
            texelBlockDimension: [0, 0, 0, 0],
            bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
            samples: []
        }], this.keyValue = {}, this.globalData = null
    }
}
class xc {
    constructor(e, t, i, s) {
        this._dataView = new DataView(e.buffer, e.byteOffset + t, i), this._littleEndian = s, this._offset = 0
    }
    _nextUint8() {
        const e = this._dataView.getUint8(this._offset);
        return this._offset += 1, e
    }
    _nextUint16() {
        const e = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2, e
    }
    _nextUint32() {
        const e = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4, e
    }
    _nextUint64() {
        const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8, e
    }
    _nextInt32() {
        const e = this._dataView.getInt32(this._offset, this._littleEndian);
        return this._offset += 4, e
    }
    _skip(e) {
        return this._offset += e, this
    }
    _scan(e, t = 0) {
        const i = this._offset;
        let s = 0;
        for (; this._dataView.getUint8(this._offset) !== t && s < e;) s++, this._offset++;
        return s < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, s)
    }
}
const en = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

function qb(n) {
    return typeof TextDecoder < "u" ? new TextDecoder().decode(n) : Buffer.from(n).toString("utf8")
}

function PO(n) {
    const e = new Uint8Array(n.buffer, n.byteOffset, en.length);
    if (e[0] !== en[0] || e[1] !== en[1] || e[2] !== en[2] || e[3] !== en[3] || e[4] !== en[4] || e[5] !== en[5] || e[6] !== en[6] || e[7] !== en[7] || e[8] !== en[8] || e[9] !== en[9] || e[10] !== en[10] || e[11] !== en[11]) throw new Error("Missing KTX 2.0 identifier.");
    const t = new RO,
        i = 17 * Uint32Array.BYTES_PER_ELEMENT,
        s = new xc(n, en.length, i, !0);
    t.vkFormat = s._nextUint32(), t.typeSize = s._nextUint32(), t.pixelWidth = s._nextUint32(), t.pixelHeight = s._nextUint32(), t.pixelDepth = s._nextUint32(), t.layerCount = s._nextUint32(), t.faceCount = s._nextUint32();
    const r = s._nextUint32();
    t.supercompressionScheme = s._nextUint32();
    const o = s._nextUint32(),
        a = s._nextUint32(),
        l = s._nextUint32(),
        c = s._nextUint32(),
        u = s._nextUint64(),
        d = s._nextUint64(),
        h = new xc(n, en.length + i, 3 * r * 8, !0);
    for (let F = 0; F < r; F++) t.levels.push({
        levelData: new Uint8Array(n.buffer, n.byteOffset + h._nextUint64(), h._nextUint64()),
        uncompressedByteLength: h._nextUint64()
    });
    const f = new xc(n, o, a, !0),
        m = {
            vendorId: f._skip(4)._nextUint16(),
            descriptorType: f._nextUint16(),
            versionNumber: f._nextUint16(),
            descriptorBlockSize: f._nextUint16(),
            colorModel: f._nextUint8(),
            colorPrimaries: f._nextUint8(),
            transferFunction: f._nextUint8(),
            flags: f._nextUint8(),
            texelBlockDimension: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
            bytesPlane: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
            samples: []
        },
        g = (m.descriptorBlockSize / 4 - 6) / 4;
    for (let F = 0; F < g; F++) {
        const L = {
            bitOffset: f._nextUint16(),
            bitLength: f._nextUint8(),
            channelType: f._nextUint8(),
            samplePosition: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()],
            sampleLower: -1 / 0,
            sampleUpper: 1 / 0
        };
        64 & L.channelType ? (L.sampleLower = f._nextInt32(), L.sampleUpper = f._nextInt32()) : (L.sampleLower = f._nextUint32(), L.sampleUpper = f._nextUint32()), m.samples[F] = L
    }
    t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(m);
    const A = new xc(n, l, c, !0);
    for (; A._offset < c;) {
        const F = A._nextUint32(),
            L = A._scan(F),
            W = qb(L),
            k = A._scan(F - L.byteLength);
        t.keyValue[W] = W.match(/^ktx/i) ? qb(k) : k, A._offset % 4 && A._skip(4 - A._offset % 4)
    }
    if (d <= 0) return t;
    const p = new xc(n, u, d, !0),
        v = p._nextUint16(),
        _ = p._nextUint16(),
        b = p._nextUint32(),
        w = p._nextUint32(),
        E = p._nextUint32(),
        C = p._nextUint32(),
        S = [];
    for (let F = 0; F < r; F++) S.push({
        imageFlags: p._nextUint32(),
        rgbSliceByteOffset: p._nextUint32(),
        rgbSliceByteLength: p._nextUint32(),
        alphaSliceByteOffset: p._nextUint32(),
        alphaSliceByteLength: p._nextUint32()
    });
    const x = u + p._offset,
        y = x + b,
        P = y + w,
        T = P + E,
        R = new Uint8Array(n.buffer, n.byteOffset + x, b),
        D = new Uint8Array(n.buffer, n.byteOffset + y, w),
        U = new Uint8Array(n.buffer, n.byteOffset + P, E),
        Q = new Uint8Array(n.buffer, n.byteOffset + T, C);
    return t.globalData = {
        endpointCount: v,
        selectorCount: _,
        imageDescs: S,
        endpointsData: R,
        selectorsData: D,
        tablesData: U,
        extendedData: Q
    }, t
}
let um, rr, Gg;
const dm = {
    env: {
        emscripten_notify_memory_growth: function (n) {
            Gg = new Uint8Array(rr.exports.memory.buffer)
        }
    }
};
class DO {
    init() {
        return um || (um = typeof fetch < "u" ? fetch("data:application/wasm;base64," + $b).then(e => e.arrayBuffer()).then(e => WebAssembly.instantiate(e, dm)).then(this._init) : WebAssembly.instantiate(Buffer.from($b, "base64"), dm).then(this._init), um)
    }
    _init(e) {
        rr = e.instance, dm.env.emscripten_notify_memory_growth(0)
    }
    decode(e, t = 0) {
        if (!rr) throw new Error("ZSTDDecoder: Await .init() before decoding.");
        const i = e.byteLength,
            s = rr.exports.malloc(i);
        Gg.set(e, s), t = t || Number(rr.exports.ZSTD_findDecompressedSize(s, i));
        const r = rr.exports.malloc(t),
            o = rr.exports.ZSTD_decompress(r, t, s, i),
            a = Gg.slice(r, r + o);
        return rr.exports.free(s), rr.exports.free(r), a
    }
}
const $b = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",
    hm = new WeakMap;
let fm = 0,
    pm;
class Us extends $n {
    constructor(e) {
        super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new wO, this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
    }
    setTranscoderPath(e) {
        return this.transcoderPath = e, this
    }
    setWorkerLimit(e) {
        return this.workerPool.setWorkerLimit(e), this
    }
    async detectSupportAsync(e) {
        return this.workerConfig = {
            astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
            etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
            etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
            dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
            bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
            pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
        }, this
    }
    detectSupport(e) {
        return e.isWebGPURenderer === !0 ? this.workerConfig = {
            astcSupported: e.hasFeature("texture-compression-astc"),
            etc1Supported: e.hasFeature("texture-compression-etc1"),
            etc2Supported: e.hasFeature("texture-compression-etc2"),
            dxtSupported: e.hasFeature("texture-compression-bc"),
            bptcSupported: e.hasFeature("texture-compression-bptc"),
            pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
        } : (this.workerConfig = {
            astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
            etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
        }, this.workerConfig.etc1Supported = !1), this
    }
    init() {
        if (!this.transcoderPending) {
            const e = new ws(this.manager);
            e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
            const t = e.loadAsync("basis_transcoder.js"),
                i = new ws(this.manager);
            i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials);
            const s = i.loadAsync("basis_transcoder.wasm");
            this.transcoderPending = Promise.all([t, s]).then(([r, o]) => {
                const a = Us.BasisWorker.toString(),
                    l = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Us.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Us.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Us.BasisFormat), "/* basis_transcoder.js */", r, "/* worker */", a.substring(a.indexOf("{") + 1, a.lastIndexOf("}"))].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([l])), this.transcoderBinary = o, this.workerPool.setWorkerCreator(() => {
                    const c = new Worker(this.workerSourceURL),
                        u = this.transcoderBinary.slice(0);
                    return c.postMessage({
                        type: "init",
                        config: this.workerConfig,
                        transcoderBinary: u
                    }, [u]), c
                })
            }), fm > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), fm++
        }
        return this.transcoderPending
    }
    load(e, t, i, s) {
        if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
        const r = new ws(this.manager);
        r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, o => {
            if (hm.has(o)) return hm.get(o).promise.then(t).catch(s);
            this._createTexture(o).then(a => t ? t(a) : null).catch(s)
        }, i, s)
    }
    _createTextureFrom(e, t) {
        const {
            faces: i,
            width: s,
            height: r,
            format: o,
            type: a,
            error: l,
            dfdFlags: c
        } = e;
        if (a === "error") return Promise.reject(l);
        let u;
        if (t.faceCount === 6) u = new CF(i, o, hi);
        else {
            const d = i[0].mipmaps;
            u = t.layerCount > 1 ? new wF(d, s, r, t.layerCount, o, hi) : new Gf(d, s, r, o, hi)
        }
        return u.minFilter = i[0].mipmaps.length === 1 ? Pt : ys, u.magFilter = Pt, u.generateMipmaps = !1, u.needsUpdate = !0, u.colorSpace = gC(t), u.premultiplyAlpha = !!(c & SO), u
    }
    async _createTexture(e, t = {}) {
        const i = PO(new Uint8Array(e));
        if (i.vkFormat !== BO) return kO(i);
        const s = t,
            r = this.init().then(() => this.workerPool.postMessage({
                type: "transcode",
                buffer: e,
                taskConfig: s
            }, [e])).then(o => this._createTextureFrom(o.data, i));
        return hm.set(e, {
            promise: r
        }), r
    }
    dispose() {
        return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), fm--, this
    }
}
Us.BasisFormat = {
    ETC1S: 0,
    UASTC_4x4: 1
};
Us.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16
};
Us.EngineFormat = {
    RGBAFormat: Jt,
    RGBA_ASTC_4x4_Format: bg,
    RGBA_BPTC_Format: yh,
    RGBA_ETC2_EAC_Format: vg,
    RGBA_PVRTC_4BPPV1_Format: Ag,
    RGBA_S3TC_DXT5_Format: xh,
    RGB_ETC1_Format: i0,
    RGB_ETC2_Format: _g,
    RGB_PVRTC_4BPPV1_Format: gg,
    RGB_S3TC_DXT1_Format: bh
};
Us.BasisWorker = function () {
    let n, e, t;
    const i = _EngineFormat,
        s = _TranscoderFormat,
        r = _BasisFormat;
    self.addEventListener("message", function (m) {
        const g = m.data;
        switch (g.type) {
            case "init":
                n = g.config, o(g.transcoderBinary);
                break;
            case "transcode":
                e.then(() => {
                    try {
                        const {
                            faces: A,
                            buffers: p,
                            width: v,
                            height: _,
                            hasAlpha: b,
                            format: w,
                            dfdFlags: E
                        } = a(g.buffer);
                        self.postMessage({
                            type: "transcode",
                            id: g.id,
                            faces: A,
                            width: v,
                            height: _,
                            hasAlpha: b,
                            format: w,
                            dfdFlags: E
                        }, p)
                    } catch (A) {
                        console.error(A), self.postMessage({
                            type: "error",
                            id: g.id,
                            error: A.message
                        })
                    }
                });
                break
        }
    });

    function o(m) {
        e = new Promise(g => {
            t = {
                wasmBinary: m,
                onRuntimeInitialized: g
            }, BASIS(t)
        }).then(() => {
            t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
        })
    }

    function a(m) {
        const g = new t.KTX2File(new Uint8Array(m));

        function A() {
            g.close(), g.delete()
        }
        if (!g.isValid()) throw A(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
        const p = g.isUASTC() ? r.UASTC_4x4 : r.ETC1S,
            v = g.getWidth(),
            _ = g.getHeight(),
            b = g.getLayers() || 1,
            w = g.getLevels(),
            E = g.getFaces(),
            C = g.getHasAlpha(),
            S = g.getDFDFlags(),
            {
                transcoderFormat: x,
                engineFormat: y
            } = d(p, v, _, C);
        if (!v || !_ || !w) throw A(), new Error("THREE.KTX2Loader:	Invalid texture");
        if (!g.startTranscoding()) throw A(), new Error("THREE.KTX2Loader: .startTranscoding failed");
        const P = [],
            T = [];
        for (let R = 0; R < E; R++) {
            const D = [];
            for (let U = 0; U < w; U++) {
                const Q = [];
                let F, L;
                for (let k = 0; k < b; k++) {
                    const $ = g.getImageLevelInfo(U, k, R);
                    R === 0 && U === 0 && k === 0 && ($.origWidth % 4 !== 0 || $.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), w > 1 ? (F = $.origWidth, L = $.origHeight) : (F = $.width, L = $.height);
                    const X = new Uint8Array(g.getImageTranscodedSizeInBytes(U, k, 0, x));
                    if (!g.transcodeImage(X, U, k, R, x, 0, -1, -1)) throw A(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                    Q.push(X)
                }
                const W = f(Q);
                D.push({
                    data: W,
                    width: F,
                    height: L
                }), T.push(W.buffer)
            }
            P.push({
                mipmaps: D,
                width: v,
                height: _,
                format: y
            })
        }
        return A(), {
            faces: P,
            buffers: T,
            width: v,
            height: _,
            hasAlpha: C,
            format: y,
            dfdFlags: S
        }
    }
    const l = [{
        if: "astcSupported",
        basisFormat: [r.UASTC_4x4],
        transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
        engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
        priorityETC1S: 1 / 0,
        priorityUASTC: 1,
        needsPowerOfTwo: !1
    }, {
        if: "bptcSupported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [s.BC7_M5, s.BC7_M5],
        engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
        priorityETC1S: 3,
        priorityUASTC: 2,
        needsPowerOfTwo: !1
    }, {
        if: "dxtSupported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [s.BC1, s.BC3],
        engineFormat: [i.RGB_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
        priorityETC1S: 4,
        priorityUASTC: 5,
        needsPowerOfTwo: !1
    }, {
        if: "etc2Supported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [s.ETC1, s.ETC2],
        engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
        priorityETC1S: 1,
        priorityUASTC: 3,
        needsPowerOfTwo: !1
    }, {
        if: "etc1Supported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [s.ETC1],
        engineFormat: [i.RGB_ETC1_Format],
        priorityETC1S: 2,
        priorityUASTC: 4,
        needsPowerOfTwo: !1
    }, {
        if: "pvrtcSupported",
        basisFormat: [r.ETC1S, r.UASTC_4x4],
        transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
        engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
        priorityETC1S: 5,
        priorityUASTC: 6,
        needsPowerOfTwo: !0
    }],
        c = l.sort(function (m, g) {
            return m.priorityETC1S - g.priorityETC1S
        }),
        u = l.sort(function (m, g) {
            return m.priorityUASTC - g.priorityUASTC
        });

    function d(m, g, A, p) {
        let v, _;
        const b = m === r.ETC1S ? c : u;
        for (let w = 0; w < b.length; w++) {
            const E = b[w];
            if (n[E.if] && E.basisFormat.includes(m) && !(p && E.transcoderFormat.length < 2) && !(E.needsPowerOfTwo && !(h(g) && h(A)))) return v = E.transcoderFormat[p ? 1 : 0], _ = E.engineFormat[p ? 1 : 0], {
                transcoderFormat: v,
                engineFormat: _
            }
        }
        return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), v = s.RGBA32, _ = i.RGBAFormat, {
            transcoderFormat: v,
            engineFormat: _
        }
    }

    function h(m) {
        return m <= 2 ? !0 : (m & m - 1) === 0 && m !== 0
    }

    function f(m) {
        if (m.length === 1) return m[0];
        let g = 0;
        for (let v = 0; v < m.length; v++) {
            const _ = m[v];
            g += _.byteLength
        }
        const A = new Uint8Array(g);
        let p = 0;
        for (let v = 0; v < m.length; v++) {
            const _ = m[v];
            A.set(_, p), p += _.byteLength
        }
        return A
    }
};
const LO = new Set([Jt, hl, ra]),
    mm = {
        [fC]: Jt,
        [uC]: Jt,
        [oC]: Jt,
        [aC]: Jt,
        [hC]: hl,
        [cC]: hl,
        [sC]: hl,
        [rC]: hl,
        [dC]: ra,
        [lC]: ra,
        [nC]: ra,
        [iC]: ra,
        [mC]: tf,
        [pC]: tf
    },
    gm = {
        [fC]: ei,
        [uC]: yi,
        [oC]: hi,
        [aC]: hi,
        [hC]: ei,
        [cC]: yi,
        [sC]: hi,
        [rC]: hi,
        [dC]: ei,
        [lC]: yi,
        [nC]: hi,
        [iC]: hi,
        [mC]: hi,
        [pC]: hi
    };
async function kO(n) {
    const {
        vkFormat: e
    } = n;
    if (mm[e] === void 0) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
    let t;
    n.supercompressionScheme === Vb && (pm || (pm = new Promise(async r => {
        const o = new DO;
        await o.init(), r(o)
    })), t = await pm);
    const i = [];
    for (let r = 0; r < n.levels.length; r++) {
        const o = Math.max(1, n.pixelWidth >> r),
            a = Math.max(1, n.pixelHeight >> r),
            l = n.pixelDepth ? Math.max(1, n.pixelDepth >> r) : 0,
            c = n.levels[r];
        let u;
        if (n.supercompressionScheme === CO) u = c.levelData;
        else if (n.supercompressionScheme === Vb) u = t.decode(c.levelData, c.uncompressedByteLength);
        else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
        let d;
        gm[e] === ei ? d = new Float32Array(u.buffer, u.byteOffset, u.byteLength / Float32Array.BYTES_PER_ELEMENT) : gm[e] === yi ? d = new Uint16Array(u.buffer, u.byteOffset, u.byteLength / Uint16Array.BYTES_PER_ELEMENT) : d = u, i.push({
            data: d,
            width: o,
            height: a,
            depth: l
        })
    }
    let s;
    if (LO.has(mm[e])) s = n.pixelDepth === 0 ? new Bo(i[0].data, n.pixelWidth, n.pixelHeight) : new gw(i[0].data, n.pixelWidth, n.pixelHeight, n.pixelDepth);
    else {
        if (n.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
        s = new Gf(i, n.pixelWidth, n.pixelHeight)
    }
    return s.mipmaps = i, s.type = gm[e], s.format = mm[e], s.colorSpace = gC(n), s.needsUpdate = !0, Promise.resolve(s)
}

function gC(n) {
    const e = n.dataFormatDescriptor[0];
    return e.colorPrimaries === TO ? e.transferFunction === Wb ? Wt : gi : e.colorPrimaries === IO ? e.transferFunction === Wb ? Uf : Vu : (e.colorPrimaries === MO || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), Ns)
}
var FO = function () {
    var n = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",
        e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb",
        t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
        i = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
    if (typeof WebAssembly != "object") return {
        supported: !1
    };
    var s = WebAssembly.validate(t) ? e : n,
        r, o = WebAssembly.instantiate(a(s), {}).then(function (p) {
            r = p.instance, r.exports.__wasm_call_ctors()
        });

    function a(p) {
        for (var v = new Uint8Array(p.length), _ = 0; _ < p.length; ++_) {
            var b = p.charCodeAt(_);
            v[_] = b > 96 ? b - 97 : b > 64 ? b - 39 : b + 4
        }
        for (var w = 0, _ = 0; _ < p.length; ++_) v[w++] = v[_] < 60 ? i[v[_]] : (v[_] - 60) * 64 + v[++_];
        return v.buffer.slice(0, w)
    }

    function l(p, v, _, b, w, E) {
        var C = r.exports.sbrk,
            S = _ + 3 & -4,
            x = C(S * b),
            y = C(w.length),
            P = new Uint8Array(r.exports.memory.buffer);
        P.set(w, y);
        var T = p(x, _, b, y, w.length);
        if (T == 0 && E && E(x, S, b), v.set(P.subarray(x, x + _ * b)), C(x - C(0)), T != 0) throw new Error("Malformed buffer data: " + T)
    }
    var c = {
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp"
    },
        u = {
            ATTRIBUTES: "meshopt_decodeVertexBuffer",
            TRIANGLES: "meshopt_decodeIndexBuffer",
            INDICES: "meshopt_decodeIndexSequence"
        },
        d = [],
        h = 0;

    function f(p) {
        var v = {
            object: new Worker(p),
            pending: 0,
            requests: {}
        };
        return v.object.onmessage = function (_) {
            var b = _.data;
            v.pending -= b.count, v.requests[b.id][b.action](b.value), delete v.requests[b.id]
        }, v
    }

    function m(p) {
        for (var v = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(a(s)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + l.toString() + A.toString(), _ = new Blob([v], {
            type: "text/javascript"
        }), b = URL.createObjectURL(_), w = 0; w < p; ++w) d[w] = f(b);
        URL.revokeObjectURL(b)
    }

    function g(p, v, _, b, w) {
        for (var E = d[0], C = 1; C < d.length; ++C) d[C].pending < E.pending && (E = d[C]);
        return new Promise(function (S, x) {
            var y = new Uint8Array(_),
                P = h++;
            E.pending += p, E.requests[P] = {
                resolve: S,
                reject: x
            }, E.object.postMessage({
                id: P,
                count: p,
                size: v,
                source: y,
                mode: b,
                filter: w
            }, [y.buffer])
        })
    }

    function A(p) {
        o.then(function () {
            var v = p.data;
            try {
                var _ = new Uint8Array(v.count * v.size);
                l(r.exports[v.mode], _, v.count, v.size, v.source, r.exports[v.filter]), self.postMessage({
                    id: v.id,
                    count: v.count,
                    action: "resolve",
                    value: _
                }, [_.buffer])
            } catch (b) {
                self.postMessage({
                    id: v.id,
                    count: v.count,
                    action: "reject",
                    value: b
                })
            }
        })
    }
    return {
        ready: o,
        supported: !0,
        useWorkers: function (p) {
            m(p)
        },
        decodeVertexBuffer: function (p, v, _, b, w) {
            l(r.exports.meshopt_decodeVertexBuffer, p, v, _, b, r.exports[c[w]])
        },
        decodeIndexBuffer: function (p, v, _, b) {
            l(r.exports.meshopt_decodeIndexBuffer, p, v, _, b)
        },
        decodeIndexSequence: function (p, v, _, b) {
            l(r.exports.meshopt_decodeIndexSequence, p, v, _, b)
        },
        decodeGltfBuffer: function (p, v, _, b, w, E) {
            l(r.exports[u[w]], p, v, _, b, r.exports[c[E]])
        },
        decodeGltfBufferAsync: function (p, v, _, b, w) {
            return d.length > 0 ? g(p, v, _, u[b], c[w]) : o.then(function () {
                var E = new Uint8Array(p * v);
                return l(r.exports[u[b]], E, p, v, _, r.exports[c[w]]), E
            })
        }
    }
}();
class NO extends rc {
    constructor(e) {
        super(), this.sources = e, this.items = {}, this.toLoad = this.sources.length, this.loaded = 0, this.loadedAll = !1, this.setLoaders(), this.startLoading()
    }
    setLoaders() {
        this.loaders = {}, this.loaders.gltfLoader = new R3, this.loaders.objLoader = new gO, this.loaders.textureLoader = new Gw, this.loaders.cubeTextureLoader = new mN, this.loaders.RGBELoader = new xO, this.loaders.fontLoader = new AO, this.loaders.AudioLoader = new wN;
        const e = new yO;
        e.setDecoderPath("/draco/");
        const t = new Us;
        t.setTranscoderPath("/basis/"), this.loaders.gltfLoader.setDRACOLoader(e), this.loaders.gltfLoader.setKTX2Loader(t), this.loaders.gltfLoader.setMeshoptDecoder(FO)
    }
    startLoading() {
        for (const e of this.sources)
            if (e.type === "gltfModel") this.loaders.gltfLoader.load(e.path, t => {
                this.sourceLoaded(e, t)
            });
            else if (e.type === "objModel") this.loaders.objLoader.load(e.path, t => {
                this.sourceLoaded(e, t)
            });
            else if (e.type === "texture") this.loaders.textureLoader.load(e.path, t => {
                this.sourceLoaded(e, t)
            });
            else if (e.type === "videoTexture") {
                let t = document.createElement("video");
                t.src = e.path, t.setAttribute("crossorigin", "anonymous"), t.muted = !0, t.loop = !0, t.load(), t.setAttribute("playsinline", ""), t.setAttribute("webkit-playsinline", ""), t.play();
                const i = {
                    videoTexture: new EF(t),
                    videoElement: t
                };
                t.addEventListener("canplaythrough", () => {
                    this.sourceLoaded(e, i)
                })
            } else e.type === "cubeTexture" ? this.loaders.cubeTextureLoader.load(e.path, t => {
                this.sourceLoaded(e, t)
            }) : e.type === "rgbeTexture" ? this.loaders.RGBELoader.load(e.path, t => {
                this.sourceLoaded(e, t)
            }) : e.type === "font" ? this.loaders.fontLoader.load(e.path, t => {
                this.sourceLoaded(e, t)
            }) : e.type === "audio" && this.loaders.AudioLoader.load(e.path, t => {
                this.sourceLoaded(e, t)
            });
        this.sources.length === 0 && setTimeout(() => {
            this.loadedAll = !0, this.trigger("ready")
        })
    }
    sourceLoaded(e, t) {
        this.items[e.name] = t, this.loaded++, this.loaded === this.toLoad && (this.loadedAll = !0, this.trigger("ready"))
    }
}
class OO extends rc {
    constructor() {
        super(), this.experience = ai.getInstance(), this.camera = this.experience.camera.instance, this.resources = this.experience.resources, this.renderer = this.experience.renderer.instance, this.debug = $s.getInstance(), this.sizes = Ss.getInstance(), this.soundsCreated = !1
    }
    isTabVisible() {
        return document.visibilityState === "visible"
    }
    handleVisibilityChange() {
        this.isTabVisible() ? (this.backgroundSound.play(), this.listener.setMasterVolume(1)) : (this.backgroundSound.pause(), this.listener.setMasterVolume(0))
    }
    createSounds() {
        this.soundsCreated !== !0 && (this.listener = new SN, this.camera.add(this.listener), this.backgroundSound = new MN(this.listener), this.backgroundSound.setBuffer(this.resources.items.backgroundSound), this.backgroundSound.setLoop(!0), this.backgroundSound.setVolume(.8), this.backgroundSound.play(), this.soundsCreated = !0, document.addEventListener("visibilitychange", () => this.handleVisibilityChange(), !1))
    }
    update() { }
    resize() { }
}
const UO = [{
    name: "dogCompressedModel",
    type: "gltfModel",
    path: "models/Dog/dog_compress_3.glb"
}, {
    name: "solarSystemModel",
    type: "gltfModel",
    path: "models/SolarSystem/solar_system_3.glb"
}, {
    name: "displacementTexture",
    type: "texture",
    path: "textures/displacement.jpg"
}, {
    name: "glowTexture",
    type: "texture",
    path: "textures/glow.png"
}];
/*!
 * paths 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var QO = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    zO = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    GO = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
    HO = /(^[#\.][a-z]|[a-y][a-z])/i,
    VO = Math.PI / 180,
    WO = 180 / Math.PI,
    Yd = Math.sin,
    Xd = Math.cos,
    as = Math.abs,
    ur = Math.sqrt,
    qO = Math.atan2,
    Hg = 1e8,
    jb = function (e) {
        return typeof e == "string"
    },
    AC = function (e) {
        return typeof e == "number"
    },
    $O = function (e) {
        return typeof e > "u"
    },
    jO = {},
    YO = {},
    uf = 1e5,
    _C = function (e) {
        return Math.round((e + Hg) % 1 * uf) / uf || (e < 0 ? 0 : 1)
    },
    yt = function (e) {
        return Math.round(e * uf) / uf || 0
    },
    Yb = function (e) {
        return Math.round(e * 1e10) / 1e10 || 0
    },
    Xb = function (e, t, i, s) {
        var r = e[t],
            o = s === 1 ? 6 : Vg(r, i, s);
        if ((o || !s) && o + i + 2 < r.length) return e.splice(t, 0, r.slice(0, i + o + 2)), r.splice(0, i + o), 1
    },
    vC = function (e, t, i) {
        var s = e.length,
            r = ~~(i * s);
        if (e[r] > t) {
            for (; --r && e[r] > t;);
            r < 0 && (r = 0)
        } else
            for (; e[++r] < t && r < s;);
        return r < s ? r : s - 1
    },
    XO = function (e, t) {
        var i = e.length;
        for (t || e.reverse(); i--;) e[i].reversed || ZO(e[i])
    },
    Kb = function (e, t) {
        return t.totalLength = e.totalLength, e.samples ? (t.samples = e.samples.slice(0), t.lookup = e.lookup.slice(0), t.minLength = e.minLength, t.resolution = e.resolution) : e.totalPoints && (t.totalPoints = e.totalPoints), t
    },
    KO = function (e, t) {
        var i = e.length,
            s = e[i - 1] || [],
            r = s.length;
        i && t[0] === s[r - 2] && t[1] === s[r - 1] && (t = s.concat(t.slice(2)), i--), e[i] = t
    };

function Th(n) {
    n = jb(n) && HO.test(n) && document.querySelector(n) || n;
    var e = n.getAttribute ? n : 0,
        t;
    return e && (n = n.getAttribute("d")) ? (e._gsPath || (e._gsPath = {}), t = e._gsPath[n], t && !t._dirty ? t : e._gsPath[n] = Lu(n)) : n ? jb(n) ? Lu(n) : AC(n[0]) ? [n] : n : console.warn("Expecting a <path> element or an SVG path data string")
}

function JO(n) {
    for (var e = [], t = 0; t < n.length; t++) e[t] = Kb(n[t], n[t].slice(0));
    return Kb(n, e)
}

function ZO(n) {
    var e = 0,
        t;
    for (n.reverse(); e < n.length; e += 2) t = n[e], n[e] = n[e + 1], n[e + 1] = t;
    n.reversed = !n.reversed
}
var eU = function (e, t) {
    var i = document.createElementNS("http://www.w3.org/2000/svg", "path"),
        s = [].slice.call(e.attributes),
        r = s.length,
        o;
    for (t = "," + t + ","; --r > -1;) o = s[r].nodeName.toLowerCase(), t.indexOf("," + o + ",") < 0 && i.setAttributeNS(null, o, s[r].nodeValue);
    return i
},
    tU = {
        rect: "rx,ry,x,y,width,height",
        circle: "r,cx,cy",
        ellipse: "rx,ry,cx,cy",
        line: "x1,x2,y1,y2"
    },
    iU = function (e, t) {
        for (var i = t ? t.split(",") : [], s = {}, r = i.length; --r > -1;) s[i[r]] = +e.getAttribute(i[r]) || 0;
        return s
    };

function nU(n, e) {
    var t = n.tagName.toLowerCase(),
        i = .552284749831,
        s, r, o, a, l, c, u, d, h, f, m, g, A, p, v, _, b, w, E, C, S, x;
    return t === "path" || !n.getBBox ? n : (c = eU(n, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), x = iU(n, tU[t]), t === "rect" ? (a = x.rx, l = x.ry || a, r = x.x, o = x.y, f = x.width - a * 2, m = x.height - l * 2, a || l ? (g = r + a * (1 - i), A = r + a, p = A + f, v = p + a * i, _ = p + a, b = o + l * (1 - i), w = o + l, E = w + m, C = E + l * i, S = E + l, s = "M" + _ + "," + w + " V" + E + " C" + [_, C, v, S, p, S, p - (p - A) / 3, S, A + (p - A) / 3, S, A, S, g, S, r, C, r, E, r, E - (E - w) / 3, r, w + (E - w) / 3, r, w, r, b, g, o, A, o, A + (p - A) / 3, o, p - (p - A) / 3, o, p, o, v, o, _, b, _, w].join(",") + "z") : s = "M" + (r + f) + "," + o + " v" + m + " h" + -f + " v" + -m + " h" + f + "z") : t === "circle" || t === "ellipse" ? (t === "circle" ? (a = l = x.r, d = a * i) : (a = x.rx, l = x.ry, d = l * i), r = x.cx, o = x.cy, u = a * i, s = "M" + (r + a) + "," + o + " C" + [r + a, o + d, r + u, o + l, r, o + l, r - u, o + l, r - a, o + d, r - a, o, r - a, o - d, r - u, o - l, r, o - l, r + u, o - l, r + a, o - d, r + a, o].join(",") + "z") : t === "line" ? s = "M" + x.x1 + "," + x.y1 + " L" + x.x2 + "," + x.y2 : (t === "polyline" || t === "polygon") && (h = (n.getAttribute("points") + "").match(zO) || [], r = h.shift(), o = h.shift(), s = "M" + r + "," + o + " L" + h.join(","), t === "polygon" && (s += "," + r + "," + o + "z")), c.setAttribute("d", E0(c._gsRawPath = Lu(s))), e && n.parentNode && (n.parentNode.insertBefore(c, n), n.parentNode.removeChild(n)), c)
}

function bC(n, e, t) {
    var i = n[e],
        s = n[e + 2],
        r = n[e + 4],
        o;
    return i += (s - i) * t, s += (r - s) * t, i += (s - i) * t, o = s + (r + (n[e + 6] - r) * t - s) * t - i, i = n[e + 1], s = n[e + 3], r = n[e + 5], i += (s - i) * t, s += (r - s) * t, i += (s - i) * t, yt(qO(s + (r + (n[e + 7] - r) * t - s) * t - i, o) * WO)
}

function xC(n, e, t) {
    t = $O(t) ? 1 : Yb(t) || 0, e = Yb(e) || 0;
    var i = Math.max(0, ~~(as(t - e) - 1e-8)),
        s = JO(n);
    if (e > t && (e = 1 - e, t = 1 - t, XO(s), s.totalLength = 0), e < 0 || t < 0) {
        var r = Math.abs(~~Math.min(e, t)) + 1;
        e += r, t += r
    }
    s.totalLength || pa(s);
    var o = t > 1,
        a = Jb(s, e, jO, !0),
        l = Jb(s, t, YO),
        c = l.segment,
        u = a.segment,
        d = l.segIndex,
        h = a.segIndex,
        f = l.i,
        m = a.i,
        g = h === d,
        A = f === m && g,
        p, v, _, b, w, E, C, S;
    if (o || i) {
        for (p = d < h || g && f < m || A && l.t < a.t, Xb(s, h, m, a.t) && (h++, p || (d++, A ? (l.t = (l.t - a.t) / (1 - a.t), f = 0) : g && (f -= m))), Math.abs(1 - (t - e)) < 1e-5 ? d = h - 1 : !l.t && d ? d-- : Xb(s, d, f, l.t) && p && h++, a.t === 1 && (h = (h + 1) % s.length), w = [], E = s.length, C = 1 + E * i, S = h, C += (E - h + d) % E, b = 0; b < C; b++) KO(w, s[S++ % E]);
        s = w
    } else if (_ = l.t === 1 ? 6 : Vg(c, f, l.t), e !== t)
        for (v = Vg(u, m, A ? a.t / l.t : a.t), g && (_ += v), c.splice(f + _ + 2), (v || m) && u.splice(0, m + v), b = s.length; b--;)(b < h || b > d) && s.splice(b, 1);
    else c.angle = bC(c, f + _, 0), f += _, a = c[f], l = c[f + 1], c.length = c.totalLength = 0, c.totalPoints = s.totalPoints = 8, c.push(a, l, a, l, a, l, a, l);
    return s.totalLength = 0, s
}

function sU(n, e, t) {
    e = e || 0, n.samples || (n.samples = [], n.lookup = []);
    var i = ~~n.resolution || 12,
        s = 1 / i,
        r = t ? e + t * 6 + 1 : n.length,
        o = n[e],
        a = n[e + 1],
        l = e ? e / 6 * i : 0,
        c = n.samples,
        u = n.lookup,
        d = (e ? n.minLength : Hg) || Hg,
        h = c[l + t * i - 1],
        f = e ? c[l - 1] : 0,
        m, g, A, p, v, _, b, w, E, C, S, x, y, P, T, R, D;
    for (c.length = u.length = 0, g = e + 2; g < r; g += 6) {
        if (A = n[g + 4] - o, p = n[g + 2] - o, v = n[g] - o, w = n[g + 5] - a, E = n[g + 3] - a, C = n[g + 1] - a, _ = b = S = x = 0, as(A) < .01 && as(w) < .01 && as(v) + as(C) < .01) n.length > 8 && (n.splice(g, 6), g -= 6, r -= 6);
        else
            for (m = 1; m <= i; m++) P = s * m, y = 1 - P, _ = b - (b = (P * P * A + 3 * y * (P * p + y * v)) * P), S = x - (x = (P * P * w + 3 * y * (P * E + y * C)) * P), R = ur(S * S + _ * _), R < d && (d = R), f += R, c[l++] = f;
        o += A, a += w
    }
    if (h)
        for (h -= f; l < c.length; l++) c[l] += h;
    if (c.length && d) {
        if (n.totalLength = D = c[c.length - 1] || 0, n.minLength = d, D / d < 9999)
            for (R = T = 0, m = 0; m < D; m += d) u[R++] = c[T] < m ? ++T : T
    } else n.totalLength = c[0] = 0;
    return e ? f - c[e / 2 - 1] : f
}

function pa(n, e) {
    var t, i, s;
    for (s = t = i = 0; s < n.length; s++) n[s].resolution = ~~e || 12, i += n[s].length, t += sU(n[s]);
    return n.totalPoints = i, n.totalLength = t, n
}

function Vg(n, e, t) {
    if (t <= 0 || t >= 1) return 0;
    var i = n[e],
        s = n[e + 1],
        r = n[e + 2],
        o = n[e + 3],
        a = n[e + 4],
        l = n[e + 5],
        c = n[e + 6],
        u = n[e + 7],
        d = i + (r - i) * t,
        h = r + (a - r) * t,
        f = s + (o - s) * t,
        m = o + (l - o) * t,
        g = d + (h - d) * t,
        A = f + (m - f) * t,
        p = a + (c - a) * t,
        v = l + (u - l) * t;
    return h += (p - h) * t, m += (v - m) * t, n.splice(e + 2, 4, yt(d), yt(f), yt(g), yt(A), yt(g + (h - g) * t), yt(A + (m - A) * t), yt(h), yt(m), yt(p), yt(v)), n.samples && n.samples.splice(e / 6 * n.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6
}

function Jb(n, e, t, i) {
    t = t || {}, n.totalLength || pa(n), (e < 0 || e > 1) && (e = _C(e));
    var s = 0,
        r = n[0],
        o, a, l, c, u, d, h;
    if (!e) h = d = s = 0, r = n[0];
    else if (e === 1) h = 1, s = n.length - 1, r = n[s], d = r.length - 8;
    else {
        if (n.length > 1) {
            for (l = n.totalLength * e, u = d = 0;
                (u += n[d++].totalLength) < l;) s = d;
            r = n[s], c = u - r.totalLength, e = (l - c) / (u - c) || 0
        }
        o = r.samples, a = r.resolution, l = r.totalLength * e, d = r.lookup.length ? r.lookup[~~(l / r.minLength)] || 0 : vC(o, l, e), c = d ? o[d - 1] : 0, u = o[d], u < l && (c = u, u = o[++d]), h = 1 / a * ((l - c) / (u - c) + d % a), d = ~~(d / a) * 6, i && h === 1 && (d + 6 < r.length ? (d += 6, h = 0) : s + 1 < n.length && (d = h = 0, r = n[++s]))
    }
    return t.t = h, t.i = d, t.path = n, t.segment = r, t.segIndex = s, t
}

function Zb(n, e, t, i) {
    var s = n[0],
        r = i || {},
        o, a, l, c, u, d, h, f, m;
    if ((e < 0 || e > 1) && (e = _C(e)), s.lookup || pa(n), n.length > 1) {
        for (l = n.totalLength * e, u = d = 0;
            (u += n[d++].totalLength) < l;) s = n[d];
        c = u - s.totalLength, e = (l - c) / (u - c) || 0
    }
    return o = s.samples, a = s.resolution, l = s.totalLength * e, d = s.lookup.length ? s.lookup[e < 1 ? ~~(l / s.minLength) : s.lookup.length - 1] || 0 : vC(o, l, e), c = d ? o[d - 1] : 0, u = o[d], u < l && (c = u, u = o[++d]), h = 1 / a * ((l - c) / (u - c) + d % a) || 0, m = 1 - h, d = ~~(d / a) * 6, f = s[d], r.x = yt((h * h * (s[d + 6] - f) + 3 * m * (h * (s[d + 4] - f) + m * (s[d + 2] - f))) * h + f), r.y = yt((h * h * (s[d + 7] - (f = s[d + 1])) + 3 * m * (h * (s[d + 5] - f) + m * (s[d + 3] - f))) * h + f), t && (r.angle = s.totalLength ? bC(s, d, h >= 1 ? 1 - 1e-9 : h || 1e-9) : s.angle || 0), r
}

function _l(n, e, t, i, s, r, o) {
    for (var a = n.length, l, c, u, d, h; --a > -1;)
        for (l = n[a], c = l.length, u = 0; u < c; u += 2) d = l[u], h = l[u + 1], l[u] = d * e + h * i + r, l[u + 1] = d * t + h * s + o;
    return n._dirty = 1, n
}

function rU(n, e, t, i, s, r, o, a, l) {
    if (!(n === a && e === l)) {
        t = as(t), i = as(i);
        var c = s % 360 * VO,
            u = Xd(c),
            d = Yd(c),
            h = Math.PI,
            f = h * 2,
            m = (n - a) / 2,
            g = (e - l) / 2,
            A = u * m + d * g,
            p = -d * m + u * g,
            v = A * A,
            _ = p * p,
            b = v / (t * t) + _ / (i * i);
        b > 1 && (t = ur(b) * t, i = ur(b) * i);
        var w = t * t,
            E = i * i,
            C = (w * E - w * _ - E * v) / (w * _ + E * v);
        C < 0 && (C = 0);
        var S = (r === o ? -1 : 1) * ur(C),
            x = S * (t * p / i),
            y = S * -(i * A / t),
            P = (n + a) / 2,
            T = (e + l) / 2,
            R = P + (u * x - d * y),
            D = T + (d * x + u * y),
            U = (A - x) / t,
            Q = (p - y) / i,
            F = (-A - x) / t,
            L = (-p - y) / i,
            W = U * U + Q * Q,
            k = (Q < 0 ? -1 : 1) * Math.acos(U / ur(W)),
            $ = (U * L - Q * F < 0 ? -1 : 1) * Math.acos((U * F + Q * L) / ur(W * (F * F + L * L)));
        isNaN($) && ($ = h), !o && $ > 0 ? $ -= f : o && $ < 0 && ($ += f), k %= f, $ %= f;
        var X = Math.ceil(as($) / (f / 4)),
            le = [],
            K = $ / X,
            te = 4 / 3 * Yd(K / 2) / (1 + Xd(K / 2)),
            ue = u * t,
            fe = d * t,
            Me = d * -i,
            Be = u * i,
            Ce;
        for (Ce = 0; Ce < X; Ce++) s = k + Ce * K, A = Xd(s), p = Yd(s), U = Xd(s += K), Q = Yd(s), le.push(A - te * p, p + te * A, U + te * Q, Q - te * U, U, Q);
        for (Ce = 0; Ce < le.length; Ce += 2) A = le[Ce], p = le[Ce + 1], le[Ce] = A * ue + p * Me + R, le[Ce + 1] = A * fe + p * Be + D;
        return le[Ce - 2] = a, le[Ce - 1] = l, le
    }
}

function Lu(n) {
    var e = (n + "").replace(GO, function (x) {
        var y = +x;
        return y < 1e-4 && y > -1e-4 ? 0 : y
    }).match(QO) || [],
        t = [],
        i = 0,
        s = 0,
        r = 2 / 3,
        o = e.length,
        a = 0,
        l = "ERROR: malformed path: " + n,
        c, u, d, h, f, m, g, A, p, v, _, b, w, E, C, S = function (y, P, T, R) {
            v = (T - y) / 3, _ = (R - P) / 3, g.push(y + v, P + _, T - v, R - _, T, R)
        };
    if (!n || !isNaN(e[0]) || isNaN(e[1])) return console.log(l), t;
    for (c = 0; c < o; c++)
        if (w = f, isNaN(e[c]) ? (f = e[c].toUpperCase(), m = f !== e[c]) : c--, d = +e[c + 1], h = +e[c + 2], m && (d += i, h += s), c || (A = d, p = h), f === "M") g && (g.length < 8 ? t.length -= 1 : a += g.length), i = A = d, s = p = h, g = [d, h], t.push(g), c += 2, f = "L";
        else if (f === "C") g || (g = [0, 0]), m || (i = s = 0), g.push(d, h, i + e[c + 3] * 1, s + e[c + 4] * 1, i += e[c + 5] * 1, s += e[c + 6] * 1), c += 6;
        else if (f === "S") v = i, _ = s, (w === "C" || w === "S") && (v += i - g[g.length - 4], _ += s - g[g.length - 3]), m || (i = s = 0), g.push(v, _, d, h, i += e[c + 3] * 1, s += e[c + 4] * 1), c += 4;
        else if (f === "Q") v = i + (d - i) * r, _ = s + (h - s) * r, m || (i = s = 0), i += e[c + 3] * 1, s += e[c + 4] * 1, g.push(v, _, i + (d - i) * r, s + (h - s) * r, i, s), c += 4;
        else if (f === "T") v = i - g[g.length - 4], _ = s - g[g.length - 3], g.push(i + v, s + _, d + (i + v * 1.5 - d) * r, h + (s + _ * 1.5 - h) * r, i = d, s = h), c += 2;
        else if (f === "H") S(i, s, i = d, s), c += 1;
        else if (f === "V") S(i, s, i, s = d + (m ? s - i : 0)), c += 1;
        else if (f === "L" || f === "Z") f === "Z" && (d = A, h = p, g.closed = !0), (f === "L" || as(i - d) > .5 || as(s - h) > .5) && (S(i, s, d, h), f === "L" && (c += 2)), i = d, s = h;
        else if (f === "A") {
            if (E = e[c + 4], C = e[c + 5], v = e[c + 6], _ = e[c + 7], u = 7, E.length > 1 && (E.length < 3 ? (_ = v, v = C, u--) : (_ = C, v = E.substr(2), u -= 2), C = E.charAt(1), E = E.charAt(0)), b = rU(i, s, +e[c + 1], +e[c + 2], +e[c + 3], +E, +C, (m ? i : 0) + v * 1, (m ? s : 0) + _ * 1), c += u, b)
                for (u = 0; u < b.length; u++) g.push(b[u]);
            i = g[g.length - 2], s = g[g.length - 1]
        } else console.log(l);
    return c = g.length, c < 6 ? (t.pop(), c = 0) : g[0] === g[c - 2] && g[1] === g[c - 1] && (g.closed = !0), t.totalPoints = a + c, t
}

function oU(n, e) {
    e === void 0 && (e = 1);
    for (var t = n[0], i = 0, s = [t, i], r = 2; r < n.length; r += 2) s.push(t, i, n[r], i = (n[r] - t) * e / 2, t = n[r], -i);
    return s
}

function Wg(n, e) {
    as(n[0] - n[2]) < 1e-4 && as(n[1] - n[3]) < 1e-4 && (n = n.slice(2));
    var t = n.length - 2,
        i = +n[0],
        s = +n[1],
        r = +n[2],
        o = +n[3],
        a = [i, s, i, s],
        l = r - i,
        c = o - s,
        u = Math.abs(n[t] - i) < .001 && Math.abs(n[t + 1] - s) < .001,
        d, h, f, m, g, A, p, v, _, b, w, E, C, S, x;
    for (u && (n.push(r, o), r = i, o = s, i = n[t - 2], s = n[t - 1], n.unshift(i, s), t += 4), e = e || e === 0 ? +e : 1, f = 2; f < t; f += 2) d = i, h = s, i = r, s = o, r = +n[f + 2], o = +n[f + 3], !(i === r && s === o) && (m = l, g = c, l = r - i, c = o - s, A = ur(m * m + g * g), p = ur(l * l + c * c), v = ur(Math.pow(l / p + m / A, 2) + Math.pow(c / p + g / A, 2)), _ = (A + p) * e * .25 / v, b = i - (i - d) * (A ? _ / A : 0), w = i + (r - i) * (p ? _ / p : 0), E = i - (b + ((w - b) * (A * 3 / (A + p) + .5) / 4 || 0)), C = s - (s - h) * (A ? _ / A : 0), S = s + (o - s) * (p ? _ / p : 0), x = s - (C + ((S - C) * (A * 3 / (A + p) + .5) / 4 || 0)), (i !== d || s !== h) && a.push(yt(b + E), yt(C + x), yt(i), yt(s), yt(w + E), yt(S + x)));
    return i !== r || s !== o || a.length < 4 ? a.push(yt(r), yt(o), yt(r), yt(o)) : a.length -= 2, a.length === 2 ? a.push(i, s, i, s, i, s) : u && (a.splice(0, 6), a.length = a.length - 6), a
}

function E0(n) {
    AC(n[0]) && (n = [n]);
    var e = "",
        t = n.length,
        i, s, r, o;
    for (s = 0; s < t; s++) {
        for (o = n[s], e += "M" + yt(o[0]) + "," + yt(o[1]) + " C", i = o.length, r = 2; r < i; r++) e += yt(o[r++]) + "," + yt(o[r++]) + " " + yt(o[r++]) + "," + yt(o[r++]) + " " + yt(o[r++]) + "," + yt(o[r]) + " ";
        o.closed && (e += "z")
    }
    return e
}
/*!
 * matrix 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var mr, ma, w0, Wf, Pc, Ih, df, tu, Es = "transform",
    qg = Es + "Origin",
    yC, EC = function (e) {
        var t = e.ownerDocument || e;
        for (!(Es in e.style) && ("msTransform" in e.style) && (Es = "msTransform", qg = Es + "Origin"); t.parentNode && (t = t.parentNode););
        if (ma = window, df = new ku, t) {
            mr = t, w0 = t.documentElement, Wf = t.body, tu = mr.createElementNS("http://www.w3.org/2000/svg", "g"), tu.style.transform = "none";
            var i = t.createElement("div"),
                s = t.createElement("div"),
                r = t && (t.body || t.firstElementChild);
            r && r.appendChild && (r.appendChild(i), i.appendChild(s), i.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), yC = s.offsetParent !== i, r.removeChild(i))
        }
        return t
    },
    aU = function (e) {
        for (var t, i; e && e !== Wf;) i = e._gsap, i && i.uncache && i.get(e, "x"), i && !i.scaleX && !i.scaleY && i.renderTransform && (i.scaleX = i.scaleY = 1e-4, i.renderTransform(1, i), t ? t.push(i) : t = [i]), e = e.parentNode;
        return t
    },
    wC = [],
    CC = [],
    lU = function () {
        return ma.pageYOffset || mr.scrollTop || w0.scrollTop || Wf.scrollTop || 0
    },
    cU = function () {
        return ma.pageXOffset || mr.scrollLeft || w0.scrollLeft || Wf.scrollLeft || 0
    },
    C0 = function (e) {
        return e.ownerSVGElement || ((e.tagName + "").toLowerCase() === "svg" ? e : null)
    },
    uU = function n(e) {
        if (ma.getComputedStyle(e).position === "fixed") return !0;
        if (e = e.parentNode, e && e.nodeType === 1) return n(e)
    },
    Am = function n(e, t) {
        if (e.parentNode && (mr || EC(e))) {
            var i = C0(e),
                s = i ? i.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                r = i ? t ? "rect" : "g" : "div",
                o = t !== 2 ? 0 : 100,
                a = t === 3 ? 100 : 0,
                l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                c = mr.createElementNS ? mr.createElementNS(s.replace(/^https/, "http"), r) : mr.createElement(r);
            return t && (i ? (Ih || (Ih = n(e)), c.setAttribute("width", .01), c.setAttribute("height", .01), c.setAttribute("transform", "translate(" + o + "," + a + ")"), Ih.appendChild(c)) : (Pc || (Pc = n(e), Pc.style.cssText = l), c.style.cssText = l + "width:0.1px;height:0.1px;top:" + a + "px;left:" + o + "px", Pc.appendChild(c))), c
        }
        throw "Need document and parent."
    },
    dU = function (e) {
        for (var t = new ku, i = 0; i < e.numberOfItems; i++) t.multiply(e.getItem(i).matrix);
        return t
    },
    hU = function (e) {
        var t = e.getCTM(),
            i;
        return t || (i = e.style[Es], e.style[Es] = "none", e.appendChild(tu), t = tu.getCTM(), e.removeChild(tu), i ? e.style[Es] = i : e.style.removeProperty(Es.replace(/([A-Z])/g, "-$1").toLowerCase())), t || df.clone()
    },
    fU = function (e, t) {
        var i = C0(e),
            s = e === i,
            r = i ? wC : CC,
            o = e.parentNode,
            a, l, c, u, d, h;
        if (e === ma) return e;
        if (r.length || r.push(Am(e, 1), Am(e, 2), Am(e, 3)), a = i ? Ih : Pc, i) s ? (c = hU(e), u = -c.e / c.a, d = -c.f / c.d, l = df) : e.getBBox ? (c = e.getBBox(), l = e.transform ? e.transform.baseVal : {}, l = l.numberOfItems ? l.numberOfItems > 1 ? dU(l) : l.getItem(0).matrix : df, u = l.a * c.x + l.c * c.y, d = l.b * c.x + l.d * c.y) : (l = new ku, u = d = 0), t && e.tagName.toLowerCase() === "g" && (u = d = 0), (s ? i : o).appendChild(a), a.setAttribute("transform", "matrix(" + l.a + "," + l.b + "," + l.c + "," + l.d + "," + (l.e + u) + "," + (l.f + d) + ")");
        else {
            if (u = d = 0, yC)
                for (l = e.offsetParent, c = e; c && (c = c.parentNode) && c !== l && c.parentNode;)(ma.getComputedStyle(c)[Es] + "").length > 4 && (u = c.offsetLeft, d = c.offsetTop, c = 0);
            if (h = ma.getComputedStyle(e), h.position !== "absolute" && h.position !== "fixed")
                for (l = e.offsetParent; o && o !== l;) u += o.scrollLeft || 0, d += o.scrollTop || 0, o = o.parentNode;
            c = a.style, c.top = e.offsetTop - d + "px", c.left = e.offsetLeft - u + "px", c[Es] = h[Es], c[qg] = h[qg], c.position = h.position === "fixed" ? "fixed" : "absolute", e.parentNode.appendChild(a)
        }
        return a
    },
    _m = function (e, t, i, s, r, o, a) {
        return e.a = t, e.b = i, e.c = s, e.d = r, e.e = o, e.f = a, e
    },
    ku = function () {
        function n(t, i, s, r, o, a) {
            t === void 0 && (t = 1), i === void 0 && (i = 0), s === void 0 && (s = 0), r === void 0 && (r = 1), o === void 0 && (o = 0), a === void 0 && (a = 0), _m(this, t, i, s, r, o, a)
        }
        var e = n.prototype;
        return e.inverse = function () {
            var i = this.a,
                s = this.b,
                r = this.c,
                o = this.d,
                a = this.e,
                l = this.f,
                c = i * o - s * r || 1e-10;
            return _m(this, o / c, -s / c, -r / c, i / c, (r * l - o * a) / c, -(i * l - s * a) / c)
        }, e.multiply = function (i) {
            var s = this.a,
                r = this.b,
                o = this.c,
                a = this.d,
                l = this.e,
                c = this.f,
                u = i.a,
                d = i.c,
                h = i.b,
                f = i.d,
                m = i.e,
                g = i.f;
            return _m(this, u * s + h * o, u * r + h * a, d * s + f * o, d * r + f * a, l + m * s + g * o, c + m * r + g * a)
        }, e.clone = function () {
            return new n(this.a, this.b, this.c, this.d, this.e, this.f)
        }, e.equals = function (i) {
            var s = this.a,
                r = this.b,
                o = this.c,
                a = this.d,
                l = this.e,
                c = this.f;
            return s === i.a && r === i.b && o === i.c && a === i.d && l === i.e && c === i.f
        }, e.apply = function (i, s) {
            s === void 0 && (s = {});
            var r = i.x,
                o = i.y,
                a = this.a,
                l = this.b,
                c = this.c,
                u = this.d,
                d = this.e,
                h = this.f;
            return s.x = r * a + o * c + d || 0, s.y = r * l + o * u + h || 0, s
        }, n
    }();

function Dl(n, e, t, i) {
    if (!n || !n.parentNode || (mr || EC(n)).documentElement === n) return new ku;
    var s = aU(n),
        r = C0(n),
        o = r ? wC : CC,
        a = fU(n, t),
        l = o[0].getBoundingClientRect(),
        c = o[1].getBoundingClientRect(),
        u = o[2].getBoundingClientRect(),
        d = a.parentNode,
        h = !i && uU(n),
        f = new ku((c.left - l.left) / 100, (c.top - l.top) / 100, (u.left - l.left) / 100, (u.top - l.top) / 100, l.left + (h ? 0 : cU()), l.top + (h ? 0 : lU()));
    if (d.removeChild(a), s)
        for (l = s.length; l--;) c = s[l], c.scaleX = c.scaleY = 0, c.renderTransform(1, c);
    return e ? f.inverse() : f
}
/*!
 * MotionPathPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var pU = "x,translateX,left,marginLeft,xPercent".split(","),
    mU = "y,translateY,top,marginTop,yPercent".split(","),
    gU = Math.PI / 180,
    es, SC, ol, $g, vm, ex, AU = function () {
        return es || typeof window < "u" && (es = window.gsap) && es.registerPlugin && es
    },
    yc = function (e, t, i, s) {
        for (var r = t.length, o = s === 2 ? 0 : s, a = 0; a < r; a++) e[o] = parseFloat(t[a][i]), s === 2 && (e[o + 1] = 0), o += 2;
        return e
    },
    vl = function (e, t, i) {
        return parseFloat(e._gsap.get(e, t, i || "px")) || 0
    },
    MC = function (e) {
        var t = e[0],
            i = e[1],
            s;
        for (s = 2; s < e.length; s += 2) t = e[s] += t, i = e[s + 1] += i
    },
    tx = function (e, t, i, s, r, o, a, l, c) {
        if (a.type === "cubic") t = [t];
        else {
            a.fromCurrent !== !1 && t.unshift(vl(i, s, l), r ? vl(i, r, c) : 0), a.relative && MC(t);
            var u = r ? Wg : oU;
            t = [u(t, a.curviness)]
        }
        return t = o(TC(t, i, a)), hf(e, i, s, t, "x", l), r && hf(e, i, r, t, "y", c), pa(t, a.resolution || (a.curviness === 0 ? 20 : 12))
    },
    _U = function (e) {
        return e
    },
    vU = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g,
    ix = function (e, t, i) {
        var s = Dl(e),
            r = 0,
            o = 0,
            a;
        return (e.tagName + "").toLowerCase() === "svg" ? (a = e.viewBox.baseVal, a.width || (a = {
            width: +e.getAttribute("width"),
            height: +e.getAttribute("height")
        })) : a = t && e.getBBox && e.getBBox(), t && t !== "auto" && (r = t.push ? t[0] * (a ? a.width : e.offsetWidth || 0) : t.x, o = t.push ? t[1] * (a ? a.height : e.offsetHeight || 0) : t.y), i.apply(r || o ? s.apply({
            x: r,
            y: o
        }) : {
            x: s.e,
            y: s.f
        })
    },
    jg = function (e, t, i, s) {
        var r = Dl(e.parentNode, !0, !0),
            o = r.clone().multiply(Dl(t)),
            a = ix(e, i, r),
            l = ix(t, s, r),
            c = l.x,
            u = l.y,
            d;
        return o.e = o.f = 0, s === "auto" && t.getTotalLength && t.tagName.toLowerCase() === "path" && (d = t.getAttribute("d").match(vU) || [], d = o.apply({
            x: +d[0],
            y: +d[1]
        }), c += d.x, u += d.y), d && (d = o.apply(t.getBBox()), c -= d.x, u -= d.y), o.e = c - a.x, o.f = u - a.y, o
    },
    TC = function (e, t, i) {
        var s = i.align,
            r = i.matrix,
            o = i.offsetX,
            a = i.offsetY,
            l = i.alignOrigin,
            c = e[0][0],
            u = e[0][1],
            d = vl(t, "x"),
            h = vl(t, "y"),
            f, m, g;
        return !e || !e.length ? Th("M0,0L0,0") : (s && (s === "self" || (f = $g(s)[0] || t) === t ? _l(e, 1, 0, 0, 1, d - c, h - u) : (l && l[2] !== !1 ? es.set(t, {
            transformOrigin: l[0] * 100 + "% " + l[1] * 100 + "%"
        }) : l = [vl(t, "xPercent") / -100, vl(t, "yPercent") / -100], m = jg(t, f, l, "auto"), g = m.apply({
            x: c,
            y: u
        }), _l(e, m.a, m.b, m.c, m.d, d + m.e - (g.x - m.e), h + m.f - (g.y - m.f)))), r ? _l(e, r.a, r.b, r.c, r.d, r.e, r.f) : (o || a) && _l(e, 1, 0, 0, 1, o || 0, a || 0), e)
    },
    hf = function (e, t, i, s, r, o) {
        var a = t._gsap,
            l = a.harness,
            c = l && l.aliases && l.aliases[i],
            u = c && c.indexOf(",") < 0 ? c : i,
            d = e._pt = new SC(e._pt, t, u, 0, 0, _U, 0, a.set(t, u, e));
        d.u = ol(a.get(t, u, o)) || 0, d.path = s, d.pp = r, e._props.push(u)
    },
    bU = function (e, t) {
        return function (i) {
            return e || t !== 1 ? xC(i, e, t) : i
        }
    },
    IC = {
        version: "3.12.5",
        name: "motionPath",
        register: function (e, t, i) {
            es = e, ol = es.utils.getUnit, $g = es.utils.toArray, vm = es.core.getStyleSaver, ex = es.core.reverting || function () { }, SC = i
        },
        init: function (e, t, i) {
            if (!es) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1;
            (!(typeof t == "object" && !t.style) || !t.path) && (t = {
                path: t
            });
            var s = [],
                r = t,
                o = r.path,
                a = r.autoRotate,
                l = r.unitX,
                c = r.unitY,
                u = r.x,
                d = r.y,
                h = o[0],
                f = bU(t.start, "end" in t ? t.end : 1),
                m, g;
            if (this.rawPaths = s, this.target = e, this.tween = i, this.styles = vm && vm(e, "transform"), (this.rotate = a || a === 0) && (this.rOffset = parseFloat(a) || 0, this.radians = !!t.useRadians, this.rProp = t.rotation || "rotation", this.rSet = e._gsap.set(e, this.rProp, this), this.ru = ol(e._gsap.get(e, this.rProp)) || 0), Array.isArray(o) && !("closed" in o) && typeof h != "number") {
                for (g in h) !u && ~pU.indexOf(g) ? u = g : !d && ~mU.indexOf(g) && (d = g);
                u && d ? s.push(tx(this, yc(yc([], o, u, 0), o, d, 1), e, u, d, f, t, l || ol(o[0][u]), c || ol(o[0][d]))) : u = d = 0;
                for (g in h) g !== u && g !== d && s.push(tx(this, yc([], o, g, 2), e, g, 0, f, t, ol(o[0][g])))
            } else m = f(TC(Th(t.path), e, t)), pa(m, t.resolution), s.push(m), hf(this, e, t.x || "x", m, "x", t.unitX || "px"), hf(this, e, t.y || "y", m, "y", t.unitY || "px")
        },
        render: function (e, t) {
            var i = t.rawPaths,
                s = i.length,
                r = t._pt;
            if (t.tween._time || !ex()) {
                for (e > 1 ? e = 1 : e < 0 && (e = 0); s--;) Zb(i[s], e, !s && t.rotate, i[s]);
                for (; r;) r.set(r.t, r.p, r.path[r.pp] + r.u, r.d, e), r = r._next;
                t.rotate && t.rSet(t.target, t.rProp, i[0].angle * (t.radians ? gU : 1) + t.rOffset + t.ru, t, e)
            } else t.styles.revert()
        },
        getLength: function (e) {
            return pa(Th(e)).totalLength
        },
        sliceRawPath: xC,
        getRawPath: Th,
        pointsToSegment: Wg,
        stringToRawPath: Lu,
        rawPathToString: E0,
        transformRawPath: _l,
        getGlobalMatrix: Dl,
        getPositionOnPath: Zb,
        cacheRawPathMeasurements: pa,
        convertToPath: function (e, t) {
            return $g(e).map(function (i) {
                return nU(i, t !== !1)
            })
        },
        convertCoordinates: function (e, t, i) {
            var s = Dl(t, !0, !0).multiply(Dl(e));
            return i ? s.apply(i) : s
        },
        getAlignMatrix: jg,
        getRelativePosition: function (e, t, i, s) {
            var r = jg(e, t, i, s);
            return {
                x: r.e,
                y: r.f
            }
        },
        arrayToRawPath: function (e, t) {
            t = t || {};
            var i = yc(yc([], e, t.x || "x", 0), e, t.y || "y", 1);
            return t.relative && MC(i), [t.type === "cubic" ? i : Wg(i, t.curviness)]
        }
    };
AU() && es.registerPlugin(IC);
class Ro {
    constructor() {
        this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
    }
    setSize() { }
    render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.")
    }
    dispose() { }
}
const xU = new ju(-1, 1, 1, -1, 0, 1);
class yU extends Gi {
    constructor() {
        super(), this.setAttribute("position", new xi([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new xi([0, 2, 0, 0, 2, 0], 2))
    }
}
const EU = new yU;
class Xu {
    constructor(e) {
        this._mesh = new Ri(EU, e)
    }
    dispose() {
        this._mesh.geometry.dispose()
    }
    render(e) {
        e.render(this._mesh, xU)
    }
    get material() {
        return this._mesh.material
    }
    set material(e) {
        this._mesh.material = e
    }
}
class wU extends Ro {
    constructor(e, t, i = null, s = null, r = null) {
        super(), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = s, this.clearAlpha = r, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Ue
    }
    render(e, t, i) {
        const s = e.autoClear;
        e.autoClear = !1;
        let r, o;
        this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor)), this.clearAlpha !== null && (r = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(r), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = s
    }
}
class BC extends Ro {
    constructor(e, t) {
        super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof ti ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = wo.clone(e.uniforms), this.material = new ti({
            name: e.name !== void 0 ? e.name : "unspecified",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        })), this.fsQuad = new Xu(this.material)
    }
    render(e, t, i) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e))
    }
    dispose() {
        this.material.dispose(), this.fsQuad.dispose()
    }
}
const RC = {
    name: "CopyShader",
    uniforms: {
        tDiffuse: {
            value: null
        },
        opacity: {
            value: 1
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
},
    CU = {
        name: "LuminosityHighPassShader",
        shaderID: "luminosityHighPass",
        uniforms: {
            tDiffuse: {
                value: null
            },
            luminosityThreshold: {
                value: 1
            },
            smoothWidth: {
                value: 1
            },
            defaultColor: {
                value: new Ue(0)
            },
            defaultOpacity: {
                value: 0
            }
        },
        vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
        fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
    };
class Xl extends Ro {
    constructor(e, t, i, s) {
        super(), this.strength = t !== void 0 ? t : 1, this.radius = i, this.threshold = s, this.resolution = e !== void 0 ? new _e(e.x, e.y) : new _e(256, 256), this.clearColor = new Ue(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
        let r = Math.round(this.resolution.x / 2),
            o = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new mn(r, o, {
            type: yi
        }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
        for (let d = 0; d < this.nMips; d++) {
            const h = new mn(r, o, {
                type: yi
            });
            h.texture.name = "UnrealBloomPass.h" + d, h.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(h);
            const f = new mn(r, o, {
                type: yi
            });
            f.texture.name = "UnrealBloomPass.v" + d, f.texture.generateMipmaps = !1, this.renderTargetsVertical.push(f), r = Math.round(r / 2), o = Math.round(o / 2)
        }
        const a = CU;
        this.highPassUniforms = wo.clone(a.uniforms), this.highPassUniforms.luminosityThreshold.value = s, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new ti({
            uniforms: this.highPassUniforms,
            vertexShader: a.vertexShader,
            fragmentShader: a.fragmentShader
        }), this.separableBlurMaterials = [];
        const l = [3, 5, 7, 9, 11];
        r = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2);
        for (let d = 0; d < this.nMips; d++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[d])), this.separableBlurMaterials[d].uniforms.invSize.value = new _e(1 / r, 1 / o), r = Math.round(r / 2), o = Math.round(o / 2);
        this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1;
        const c = [1, .8, .6, .4, .2];
        this.compositeMaterial.uniforms.bloomFactors.value = c, this.bloomTintColors = [new z(1, 1, 1), new z(1, 1, 1), new z(1, 1, 1), new z(1, 1, 1), new z(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
        const u = RC;
        this.copyUniforms = wo.clone(u.uniforms), this.blendMaterial = new ti({
            uniforms: this.copyUniforms,
            vertexShader: u.vertexShader,
            fragmentShader: u.fragmentShader,
            blending: Kh,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Ue, this.oldClearAlpha = 1, this.basic = new pr, this.fsQuad = new Xu(null)
    }
    dispose() {
        for (let e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
        for (let e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
        this.renderTargetBright.dispose();
        for (let e = 0; e < this.separableBlurMaterials.length; e++) this.separableBlurMaterials[e].dispose();
        this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose()
    }
    setSize(e, t) {
        let i = Math.round(e / 2),
            s = Math.round(t / 2);
        this.renderTargetBright.setSize(i, s);
        for (let r = 0; r < this.nMips; r++) this.renderTargetsHorizontal[r].setSize(i, s), this.renderTargetsVertical[r].setSize(i, s), this.separableBlurMaterials[r].uniforms.invSize.value = new _e(1 / i, 1 / s), i = Math.round(i / 2), s = Math.round(s / 2)
    }
    render(e, t, i, s, r) {
        e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
        const o = e.autoClear;
        e.autoClear = !1, e.setClearColor(this.clearColor, 0), r && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
        let a = this.renderTargetBright;
        for (let l = 0; l < this.nMips; l++) this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[l].uniforms.direction.value = Xl.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = Xl.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), a = this.renderTargetsVertical[l];
        this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = o
    }
    getSeperableBlurMaterial(e) {
        const t = [];
        for (let i = 0; i < e; i++) t.push(.39894 * Math.exp(-.5 * i * i / (e * e)) / e);
        return new ti({
            defines: {
                KERNEL_RADIUS: e
            },
            uniforms: {
                colorTexture: {
                    value: null
                },
                invSize: {
                    value: new _e(.5, .5)
                },
                direction: {
                    value: new _e(.5, .5)
                },
                gaussianCoefficients: {
                    value: t
                }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
        })
    }
    getCompositeMaterial(e) {
        return new ti({
            defines: {
                NUM_MIPS: e
            },
            uniforms: {
                blurTexture1: {
                    value: null
                },
                blurTexture2: {
                    value: null
                },
                blurTexture3: {
                    value: null
                },
                blurTexture4: {
                    value: null
                },
                blurTexture5: {
                    value: null
                },
                bloomStrength: {
                    value: 1
                },
                bloomFactors: {
                    value: null
                },
                bloomTintColors: {
                    value: null
                },
                bloomRadius: {
                    value: 0
                }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
        })
    }
}
Xl.BlurDirectionX = new _e(1, 0);
Xl.BlurDirectionY = new _e(0, 1);
const SU = {
    name: "OutputShader",
    uniforms: {
        tDiffuse: {
            value: null
        },
        toneMappingExposure: {
            value: 1
        }
    },
    vertexShader: `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
};
class MU extends Ro {
    constructor() {
        super();
        const e = SU;
        this.uniforms = wo.clone(e.uniforms), this.material = new nN({
            name: e.name,
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        }), this.fsQuad = new Xu(this.material), this._outputColorSpace = null, this._toneMapping = null
    }
    render(e, t, i) {
        this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, (this._outputColorSpace !== e.outputColorSpace || this._toneMapping !== e.toneMapping) && (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, vt.getTransfer(this._outputColorSpace) === Lt && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === KA ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === JA ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === ZA ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === e0 ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === t0 ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === Zh && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e))
    }
    dispose() {
        this.material.dispose(), this.fsQuad.dispose()
    }
}
const PC = `
		#ifdef USE_SKINNING
		#ifdef BONE_TEXTURE
			uniform sampler2D prevBoneTexture;
			mat4 getPrevBoneMatrix( const in float i ) {
				float j = i * 4.0;
				float x = mod( j, float( boneTextureSize ) );
				float y = floor( j / float( boneTextureSize ) );
				float dx = 1.0 / float( boneTextureSize );
				float dy = 1.0 / float( boneTextureSize );
				y = dy * ( y + 0.5 );
				vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );
				vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );
				vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );
				vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );
				mat4 bone = mat4( v1, v2, v3, v4 );
				return bone;
			}
		#else
			uniform mat4 prevBoneMatrices[ MAX_BONES ];
			mat4 getPrevBoneMatrix( const in float i ) {
				mat4 bone = prevBoneMatrices[ int(i) ];
				return bone;
			}
		#endif
		#endif
	`,
    DC = `
		vec3 transformed;

		// Get the normal
		${Je.skinbase_vertex}
		${Je.beginnormal_vertex}
		${Je.skinnormal_vertex}
		${Je.defaultnormal_vertex}

		// Get the current vertex position
		transformed = vec3( position );
		${Je.skinning_vertex}
		newPosition = modelViewMatrix * vec4(transformed, 1.0);

		// Get the previous vertex position
		transformed = vec3( position );
		${Je.skinbase_vertex.replace(/mat4 /g, "").replace(/getBoneMatrix/g, "getPrevBoneMatrix")}
		${Je.skinning_vertex.replace(/vec4 /g, "")}
		prevPosition = prevModelViewMatrix * vec4(transformed, 1.0);

		// The delta between frames
		vec3 delta = newPosition.xyz - prevPosition.xyz;
		vec3 direction = normalize(delta);

		// Stretch along the velocity axes
		// TODO: Can we combine the stretch and expand
		float stretchDot = dot(direction, transformedNormal);
		vec4 expandDir = vec4(direction, 0.0) * stretchDot * expandGeometry * length(delta);
		vec4 newPosition2 =  projectionMatrix * (newPosition + expandDir);
		vec4 prevPosition2 = prevProjectionMatrix * (prevPosition + expandDir);

		newPosition =  projectionMatrix * newPosition;
		prevPosition = prevProjectionMatrix * prevPosition;

		gl_Position = mix(newPosition2, prevPosition2, interpolateGeometry * (1.0 - step(0.0, stretchDot) ) );

	`,
    bm = {
        uniforms: {
            prevProjectionMatrix: {
                value: new Xe
            },
            prevModelViewMatrix: {
                value: new Xe
            },
            prevBoneTexture: {
                value: null
            },
            expandGeometry: {
                value: 0
            },
            interpolateGeometry: {
                value: 1
            },
            smearIntensity: {
                value: 1
            }
        },
        vertexShader: `
			${Je.skinning_pars_vertex}
			${PC}

			uniform mat4 prevProjectionMatrix;
			uniform mat4 prevModelViewMatrix;
			uniform float expandGeometry;
			uniform float interpolateGeometry;
			varying vec4 prevPosition;
			varying vec4 newPosition;

			void main() {

				${DC}

			}
		`,
        fragmentShader: `
			uniform float smearIntensity;
			varying vec4 prevPosition;
			varying vec4 newPosition;

			void main() {

				// NOTE: It seems the velociyt is incorrectly calculated here -- see the velocity pass
				// in shader replacement to see how to compute velocities in screen uv space.
				vec3 vel;
				vel = (newPosition.xyz / newPosition.w) - (prevPosition.xyz / prevPosition.w);

				gl_FragColor = vec4(vel * smearIntensity, 1.0);
			}
		`
    },
    xm = {
        uniforms: {
            prevProjectionMatrix: {
                value: new Xe
            },
            prevModelViewMatrix: {
                value: new Xe
            },
            prevBoneTexture: {
                value: null
            },
            expandGeometry: {
                value: 0
            },
            interpolateGeometry: {
                value: 1
            },
            smearIntensity: {
                value: 1
            }
        },
        vertexShader: `
			${Je.skinning_pars_vertex}
			${PC}

			uniform mat4 prevProjectionMatrix;
			uniform mat4 prevModelViewMatrix;
			uniform float expandGeometry;
			uniform float interpolateGeometry;
			varying vec4 prevPosition;
			varying vec4 newPosition;
			varying vec3 color;

			void main() {

				${DC}

				color = (modelViewMatrix * vec4(normal.xyz, 0)).xyz;
				color = normalize(color);

			}
		`,
        fragmentShader: `
			varying vec3 color;

			void main() {
				gl_FragColor = vec4(color, 1);
			}
		`
    },
    TU = {
        defines: {
            SAMPLES: 30,
            JITTER_STRATEGY: 1,
            BLUENOISE_SIZE: "32.0"
        },
        uniforms: {
            sourceBuffer: {
                value: null
            },
            velocityBuffer: {
                value: null
            },
            jitter: {
                value: 1
            },
            blueNoiseTex: {
                value: null
            }
        },
        vertexShader: `
			varying vec2 vUv;
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		`,
        fragmentShader: `
			varying vec2 vUv;
			uniform sampler2D sourceBuffer;
			uniform sampler2D velocityBuffer;
			uniform float jitter;

			#if JITTER_STRATEGY == 2 // blue noise
			uniform sampler2D blueNoiseTex;
			#endif

			#include <common>
			void main() {

				vec2 vel = texture2D( velocityBuffer, vUv ).xy;

				#if JITTER_STRATEGY == 0 // Regular Jitter
				float jitterValue = mod( ( gl_FragCoord.x + gl_FragCoord.y ) * 0.25, 1.0 );
				#elif JITTER_STRATEGY == 1 // Random Jitter
				float jitterValue = rand( gl_FragCoord.xy * 0.01 );
				#elif JITTER_STRATEGY == 2 // Blue Noise Jitter
				float jitterValue = texture2D( blueNoiseTex, gl_FragCoord.xy / BLUENOISE_SIZE ).r;
				#endif

				vec2 jitterOffset = jitter * vel * vec2( jitterValue ) / float( SAMPLES );
				vec4 result;

				vec2 startUv = clamp( vUv - vel * 0.5 + jitterOffset, 0.0, 1.0 );
				vec2 endUv = clamp( vUv + vel * 0.5 + jitterOffset, 0.0, 1.0 );
				for( int i = 0; i < SAMPLES; i ++ ) {

					vec2 sampleUv = mix( startUv, endUv, float( i ) / float( SAMPLES ) );
					result += texture2D( sourceBuffer, sampleUv );

				}

				result /= float( SAMPLES );

				gl_FragColor = result;

			}
		`
    };

function IU(n, e = Math.random) {
    for (let t = n.length - 1; t > 0; t--) {
        const i = ~~((e() - 1e-6) * t),
            s = n[t];
        n[t] = n[i], n[i] = s
    }
}

function BU(n, e) {
    n.fill(0);
    for (let t = 0; t < e; t++) n[t] = 1
}
class nx {
    constructor(e) {
        this.count = 0, this.size = -1, this.sigma = -1, this.radius = -1, this.lookupTable = null, this.score = null, this.binaryPattern = null, this.resize(e), this.setSigma(1.5)
    }
    findVoid() {
        const {
            score: e,
            binaryPattern: t
        } = this;
        let i = 1 / 0,
            s = -1;
        for (let r = 0, o = t.length; r < o; r++) {
            if (t[r] !== 0) continue;
            const a = e[r];
            a < i && (i = a, s = r)
        }
        return s
    }
    findCluster() {
        const {
            score: e,
            binaryPattern: t
        } = this;
        let i = -1 / 0,
            s = -1;
        for (let r = 0, o = t.length; r < o; r++) {
            if (t[r] !== 1) continue;
            const a = e[r];
            a > i && (i = a, s = r)
        }
        return s
    }
    setSigma(e) {
        if (e === this.sigma) return;
        const t = ~~(Math.sqrt(10 * 2 * e ** 2) + 1),
            i = 2 * t + 1,
            s = new Float32Array(i * i),
            r = e * e;
        for (let o = -t; o <= t; o++)
            for (let a = -t; a <= t; a++) {
                const l = (t + a) * i + o + t,
                    c = o * o + a * a;
                s[l] = Math.E ** (-c / (2 * r))
            }
        this.lookupTable = s, this.sigma = e, this.radius = t
    }
    resize(e) {
        this.size !== e && (this.size = e, this.score = new Float32Array(e * e), this.binaryPattern = new Uint8Array(e * e))
    }
    invert() {
        const {
            binaryPattern: e,
            score: t,
            size: i
        } = this;
        t.fill(0);
        for (let s = 0, r = e.length; s < r; s++)
            if (e[s] === 0) {
                const o = ~~(s / i),
                    a = s - o * i;
                this.updateScore(a, o, 1), e[s] = 1
            } else e[s] = 0
    }
    updateScore(e, t, i) {
        const {
            size: s,
            score: r,
            lookupTable: o
        } = this, a = this.radius, l = 2 * a + 1;
        for (let c = -a; c <= a; c++)
            for (let u = -a; u <= a; u++) {
                const d = (a + u) * l + c + a,
                    h = o[d];
                let f = e + c;
                f = f < 0 ? s + f : f % s;
                let m = t + u;
                m = m < 0 ? s + m : m % s;
                const g = m * s + f;
                r[g] += i * h
            }
    }
    addPointIndex(e) {
        this.binaryPattern[e] = 1;
        const t = this.size,
            i = ~~(e / t),
            s = e - i * t;
        this.updateScore(s, i, 1), this.count++
    }
    removePointIndex(e) {
        this.binaryPattern[e] = 0;
        const t = this.size,
            i = ~~(e / t),
            s = e - i * t;
        this.updateScore(s, i, -1), this.count--
    }
    copy(e) {
        this.resize(e.size), this.score.set(e.score), this.binaryPattern.set(e.binaryPattern), this.setSigma(e.sigma), this.count = e.count
    }
}
class RU {
    constructor() {
        this.random = Math.random, this.sigma = 1.5, this.size = 64, this.majorityPointsRatio = .1, this.samples = new nx(1), this.savedSamples = new nx(1)
    }
    generate() {
        const {
            samples: e,
            savedSamples: t,
            sigma: i,
            majorityPointsRatio: s,
            size: r
        } = this;
        e.resize(r), e.setSigma(i);
        const o = Math.floor(r * r * s),
            a = e.binaryPattern;
        BU(a, o), IU(a, this.random);
        for (let d = 0, h = a.length; d < h; d++) a[d] === 1 && e.addPointIndex(d);
        for (; ;) {
            const d = e.findCluster();
            e.removePointIndex(d);
            const h = e.findVoid();
            if (d === h) {
                e.addPointIndex(d);
                break
            }
            e.addPointIndex(h)
        }
        const l = new Uint32Array(r * r);
        t.copy(e);
        let c;
        for (c = e.count - 1; c >= 0;) {
            const d = e.findCluster();
            e.removePointIndex(d), l[d] = c, c--
        }
        const u = r * r;
        for (c = t.count; c < u / 2;) {
            const d = t.findVoid();
            t.addPointIndex(d), l[d] = c, c++
        }
        for (t.invert(); c < u;) {
            const d = t.findCluster();
            t.removePointIndex(d), l[d] = c, c++
        }
        return {
            data: l,
            maxValue: u
        }
    }
}
class PU {
    constructor() {
        this.clearAlpha = 0, this.clearColor = new Ue, this.renderTarget = null, this.outputColorSpace = Wt, this.overrideMaterial = null, this.shadowsEnabled = !1, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.background = null, this.autoUpdate = !0
    }
    copy(e, t) {
        e && (this.clearAlpha = e.getClearAlpha(), this.clearColor = e.getClearColor(this.clearColor), this.renderTarget = e.getRenderTarget(), this.shadowsEnabled = e.shadowMap.enabled, this.outputColorSpace = e.outputColorSpace, this.autoClear = e.autoClear, this.autoClearColor = e.autoClearColor, this.autoClearDepth = e.autoClearDepth, this.autoClearStencil = e.autoClearStencil), t && (this.overrideMaterial = t.overrideMaterial, this.background = t.background, this.autoUpdate = t.autoUpdate)
    }
    restore(e, t) {
        e && (e.setClearAlpha(this.clearAlpha), e.setClearColor(this.clearColor), e.setRenderTarget(this.renderTarget), e.shadowMap.enabled = this.shadowsEnabled, e.outputColorSpace = this.outputColorSpace, e.autoClear = this.autoClear, e.autoClearColor = this.autoClearColor, e.autoClearDepth = this.autoClearDepth, e.autoClearStencil = this.autoClearStencil), t && (t.overrideMaterial = this.overrideMaterial, t.background = this.background, t.autoUpdate = this.autoUpdate), this.renderTarget = null, this.overrideMaterial = null
    }
}

function LC(n, e) {
    if (n.visible) {
        (n.isMesh || n.isSkinnedMesh) && e(n);
        const t = n.children;
        for (let i = 0, s = t.length; i < s; i++) LC(t[i], e)
    }
}
const DU = new Ue(0, 0, 0),
    LU = {},
    sx = new PU,
    ff = new RU;
ff.size = 32;
const kC = new Uint8Array(32 ** 2 * 4);
for (let n = 0, e = 1; n < e; n++) {
    const t = ff.generate(),
        i = t.data,
        s = t.maxValue;
    for (let r = 0, o = i.length; r < o; r++) {
        const a = 255 * (i[r] / s);
        kC[r * 3 + n] = a
    }
}
const qf = new Bo(kC, ff.size, ff.size, Jt);
qf.wrapS = Eo;
qf.wrapT = Eo;
qf.minFilter = Pt;
class Ni extends Ro {
    constructor(t, i, s = {}) {
        super();
        Ae(this, "state", Ms.getInstance());
        Ae(this, "debug", $s.getInstance());
        this.enabled = !0, this.needsSwap = !0, this.samples = "samples" in s ? s.samples : 15, this.expandGeometry = "expandGeometry" in s ? s.expandGeometry : 0, this.interpolateGeometry = "interpolateGeometry" in s ? s.interpolateGeometry : 1, this.smearIntensity = "smearIntensity" in s ? s.smearIntensity : 1, this.blurTransparent = "blurTransparent" in s ? s.blurTransparent : !1, this.renderCameraBlur = "renderCameraBlur" in s ? s.renderCameraBlur : !0, this.renderTargetScale = "renderTargetScale" in s ? s.renderTargetScale : 1, this.jitter = "jitter" in s ? s.jitter : 1, this.jitterStrategy = "jitterStrategy" in s ? s.jitterStrategy : Ni.RANDOM_JITTER, this.debug = {
            display: Ni.DEFAULT,
            dontUpdateState: !1
        }, this.scene = t, this.camera = i, this._prevPosMap = new Map, this._currentFrameMod = 0, this._frustum = new Qf, this._projScreenMatrix = new Xe, this._cameraMatricesNeedInitializing = !0, this._prevCamProjection = new Xe, this._prevCamWorldInverse = new Xe, this._velocityBuffer = new mn(256, 256, {
            minFilter: Pt,
            magFilter: Pt,
            format: Jt,
            type: yi
        }), this._velocityBuffer.texture.name = "MotionBlurPass.Velocity", this._velocityBuffer.texture.generateMipmaps = !1, this._compositeMaterial = new ti(TU), this._compositeQuad = new Xu(this._compositeMaterial)
    }
    get enabled() {
        return this._enabled
    }
    set enabled(t) {
        t === !1 && (this._prevPosMap.clear(), this._cameraMatricesNeedInitializing = !0), this._enabled = t
    }
    dispose() {
        this._compositeQuad.dispose(), this._velocityBuffer.dispose(), this._prevPosMap.clear()
    }
    setSize(t, i) {
        const s = this.renderTargetScale;
        this._velocityBuffer.setSize(t * s, i * s)
    }
    render(t, i, s) {
        const r = this.debug,
            o = this.scene,
            a = this.camera,
            l = this._compositeQuad,
            c = this.renderToScreen ? null : i;
        switch (sx.copy(t, o), t.autoClear = !1, t.setClearColor(DU, 0), t.compile(o, a), this._ensurePrevCameraTransform(), r.display) {
            case Ni.GEOMETRY:
                {
                    t.setRenderTarget(c),
                        t.clear(),
                        this._drawAllMeshes(t, Ni.GEOMETRY, !r.dontUpdateState);
                    break
                }
            case Ni.VELOCITY:
                {
                    t.setRenderTarget(c),
                        t.clear(),
                        this._drawAllMeshes(t, Ni.VELOCITY, !r.dontUpdateState);
                    break
                }
            case Ni.DEFAULT:
                {
                    const u = this._velocityBuffer; t.setRenderTarget(u),
                        t.clear(),
                        this._drawAllMeshes(t, Ni.VELOCITY, !r.dontUpdateState);
                    const d = this._compositeMaterial,
                        h = d.uniforms; h.sourceBuffer.value = s.texture,
                            h.velocityBuffer.value = this._velocityBuffer.texture,
                            h.jitter.value = this.jitter,
                            h.blueNoiseTex.value = qf,
                            d.defines.SAMPLES !== this.samples && (d.defines.SAMPLES = Math.max(0, Math.floor(this.samples)), d.needsUpdate = !0),
                            d.defines.JITTER_STRATEGY !== this.jitterStrategy && (d.defines.JITTER_STRATEGY = this.jitterStrategy, d.needsUpdate = !0),
                            t.setRenderTarget(c),
                            l.render(t);
                    break
                }
        }
        this._prevCamWorldInverse.copy(a.matrixWorldInverse), this._prevCamProjection.copy(a.projectionMatrix), sx.restore(t, o)
    }
    _getPreviousFrameState(t) {
        const i = this._prevPosMap;
        let s = i.get(t);
        s === void 0 && (s = {
            lastUsedFrame: -1,
            matrixWorld: t.matrixWorld.clone(),
            geometryMaterial: new ti({
                uniforms: wo.clone(xm.uniforms),
                vertexShader: xm.vertexShader,
                fragmentShader: xm.fragmentShader
            }),
            velocityMaterial: new ti({
                uniforms: wo.clone(bm.uniforms),
                vertexShader: bm.vertexShader,
                fragmentShader: bm.fragmentShader
            }),
            boneMatrices: null,
            boneTexture: null
        }, i.set(t, s));
        const r = t.type === "SkinnedMesh" && t.skeleton && t.skeleton.bones && t.skeleton.boneMatrices;
        s.geometryMaterial.skinning = r, s.velocityMaterial.skinning = r;
        const o = t.skeleton,
            a = s.boneMatrices === null || s.boneMatrices.length !== o.boneMatrices.length;
        if (r && a) {
            const l = new Float32Array(o.boneMatrices.length);
            l.set(o.boneMatrices), s.boneMatrices = l;
            const c = Math.sqrt(o.boneMatrices.length / 4),
                u = new Bo(l, c, c, Jt, ei);
            u.needsUpdate = !0, s.geometryMaterial.uniforms.prevBoneTexture.value = u, s.velocityMaterial.uniforms.prevBoneTexture.value = u, s.boneTexture = u
        }
        return s
    }
    _saveCurrentObjectState(t) {
        const s = this._prevPosMap.get(t);
        s.boneMatrices !== null && (s.boneMatrices.set(t.skeleton.boneMatrices), s.boneTexture.needsUpdate = !0), s.matrixWorld.copy(t.matrixWorld)
    }
    _drawAllMeshes(t, i, s) {
        this._currentFrameMod = (this._currentFrameMod + 1) % 2;
        const r = this._currentFrameMod,
            o = this._prevPosMap;
        LC(this.scene, a => {
            this._drawMesh(t, a, i, s), o.has(a) && (o.get(a).lastUsedFrame = r)
        }), o.forEach((a, l) => {
            a.lastUsedFrame !== r && (a.geometryMaterial.dispose(), a.velocityMaterial.dispose(), a.boneTexture && a.boneTexture.dispose(), o.delete(l))
        })
    }
    _drawMesh(t, i, s, r) {
        const o = i.motionBlur || LU;
        let a = this.blurTransparent,
            l = this.renderCameraBlur,
            c = this.expandGeometry,
            u = this.interpolateGeometry,
            d = this.smearIntensity;
        a = "blurTransparent" in o ? o.blurTransparent : this.blurTransparent, l = "renderCameraBlur" in o ? o.renderCameraBlur : this.renderCameraBlur, c = "expandGeometry" in o ? o.expandGeometry : this.expandGeometry, u = "interpolateGeometry" in o ? o.interpolateGeometry : this.interpolateGeometry, d = "smearIntensity" in o ? o.smearIntensity : this.smearIntensity;
        const h = i.material.transparent || i.material.alpha < 1,
            f = i.frustumCulled && !this._frustum.intersectsObject(i);
        if (a === !1 && h || f) this._prevPosMap.has(i) && r && this._saveCurrentObjectState(i);
        else {
            const g = this.camera,
                A = this._getPreviousFrameState(i),
                p = s === Ni.GEOMETRY ? A.geometryMaterial : A.velocityMaterial,
                v = p.uniforms;
            v.expandGeometry.value = c, v.interpolateGeometry.value = u, v.smearIntensity.value = d;
            const _ = l ? this._prevCamProjection : g.projectionMatrix,
                b = l ? this._prevCamWorldInverse : g.matrixWorldInverse;
            v.prevProjectionMatrix.value.copy(_), v.prevModelViewMatrix.value.multiplyMatrices(b, A.matrixWorld), i.matrixWorld.elements[13] += 1e-6, t.renderBufferDirect(g, null, i.geometry, p, i, null), r && this._saveCurrentObjectState(i)
        }
    }
    _ensurePrevCameraTransform() {
        const t = this.camera,
            i = this._projScreenMatrix;
        this._cameraMatricesNeedInitializing && (this._prevCamWorldInverse.copy(t.matrixWorldInverse), this._prevCamProjection.copy(t.projectionMatrix), this._cameraMatricesNeedInitializing = !1), i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i)
    }
}
Ni.DEFAULT = 0;
Ni.VELOCITY = 1;
Ni.GEOMETRY = 2;
Ni.REGULAR_JITTER = 0;
Ni.RANDOM_JITTER = 1;
Ni.BLUENOISE_JITTER = 2;
const kU = {
    name: "BokehShader",
    defines: {
        DEPTH_PACKING: 1,
        PERSPECTIVE_CAMERA: 1
    },
    uniforms: {
        tColor: {
            value: null
        },
        tDepth: {
            value: null
        },
        focus: {
            value: 1
        },
        aspect: {
            value: 1
        },
        aperture: {
            value: .025
        },
        maxblur: {
            value: .01
        },
        nearClip: {
            value: 1
        },
        farClip: {
            value: 1e3
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`
};
class FU extends Ro {
    constructor(e, t, i) {
        super(), this.scene = e, this.camera = t;
        const s = i.focus !== void 0 ? i.focus : 1,
            r = i.aperture !== void 0 ? i.aperture : .025,
            o = i.maxblur !== void 0 ? i.maxblur : 1;
        this.renderTargetDepth = new mn(1, 1, {
            minFilter: Kt,
            magFilter: Kt,
            type: yi
        }), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new Mw, this.materialDepth.depthPacking = uw, this.materialDepth.blending = Hs;
        const a = kU,
            l = wo.clone(a.uniforms);
        l.tDepth.value = this.renderTargetDepth.texture, l.focus.value = s, l.aspect.value = t.aspect, l.aperture.value = r, l.maxblur.value = o, l.nearClip.value = t.near, l.farClip.value = t.far, this.materialBokeh = new ti({
            defines: Object.assign({}, a.defines),
            uniforms: l,
            vertexShader: a.vertexShader,
            fragmentShader: a.fragmentShader
        }), this.uniforms = l, this.fsQuad = new Xu(this.materialBokeh), this._oldClearColor = new Ue
    }
    render(e, t, i) {
        this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this._oldClearColor);
        const s = e.getClearAlpha(),
            r = e.autoClear;
        e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = i.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), e.clear(), this.fsQuad.render(e)), this.scene.overrideMaterial = null, e.setClearColor(this._oldClearColor), e.setClearAlpha(s), e.autoClear = r
    }
    setSize(e, t) {
        this.materialBokeh.uniforms.aspect.value = e / t, this.renderTargetDepth.setSize(e, t)
    }
    dispose() {
        this.renderTargetDepth.dispose(), this.materialDepth.dispose(), this.materialBokeh.dispose(), this.fsQuad.dispose()
    }
}
class rx extends Ro {
    constructor(e, t) {
        super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1
    }
    render(e, t, i) {
        const s = e.getContext(),
            r = e.state;
        r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0);
        let o, a;
        this.inverse ? (o = 0, a = 1) : (o = 1, a = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), r.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), r.buffers.stencil.setClear(a), r.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.color.setMask(!0), r.buffers.depth.setMask(!0), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), r.buffers.stencil.setLocked(!0)
    }
}
class NU extends Ro {
    constructor() {
        super(), this.needsSwap = !1
    }
    render(e) {
        e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1)
    }
}
class ox {
    constructor(e, t) {
        if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
            const i = e.getSize(new _e);
            this._width = i.width, this._height = i.height, t = new mn(this._width * this._pixelRatio, this._height * this._pixelRatio, {
                type: yi
            }), t.texture.name = "EffectComposer.rt1"
        } else this._width = t.width, this._height = t.height;
        this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new BC(RC), this.copyPass.material.blending = Hs, this.clock = new Ww
    }
    swapBuffers() {
        const e = this.readBuffer;
        this.readBuffer = this.writeBuffer, this.writeBuffer = e
    }
    addPass(e) {
        this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    insertPass(e, t) {
        this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    removePass(e) {
        const t = this.passes.indexOf(e);
        t !== -1 && this.passes.splice(t, 1)
    }
    isLastEnabledPass(e) {
        for (let t = e + 1; t < this.passes.length; t++)
            if (this.passes[t].enabled) return !1;
        return !0
    }
    render(e) {
        e === void 0 && (e = this.clock.getDelta());
        const t = this.renderer.getRenderTarget();
        let i = !1;
        for (let s = 0, r = this.passes.length; s < r; s++) {
            const o = this.passes[s];
            if (o.enabled !== !1) {
                if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), o.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), o.needsSwap) {
                    if (i) {
                        const a = this.renderer.getContext(),
                            l = this.renderer.state.buffers.stencil;
                        l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(a.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                rx !== void 0 && (o instanceof rx ? i = !0 : o instanceof NU && (i = !1))
            }
        }
        this.renderer.setRenderTarget(t)
    }
    reset(e) {
        if (e === void 0) {
            const t = this.renderer.getSize(new _e);
            this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
    }
    setSize(e, t) {
        this._width = e, this._height = t;
        const i = this._width * this._pixelRatio,
            s = this._height * this._pixelRatio;
        this.renderTarget1.setSize(i, s), this.renderTarget2.setSize(i, s);
        for (let r = 0; r < this.passes.length; r++) this.passes[r].setSize(i, s)
    }
    setPixelRatio(e) {
        this._pixelRatio = e, this.setSize(this._width, this._height)
    }
    dispose() {
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose()
    }
}
const io = class io {
    constructor() {
        Ae(this, "experience", ai.getInstance());
        Ae(this, "renderer", this.experience.renderer);
        Ae(this, "state", Ms.getInstance());
        Ae(this, "floatType", this.state.floatType);
        if (io._instance) return io._instance;
        io._instance = this, this.experience = ai.getInstance(), this.sizes = Ss.getInstance(), this.renderer = this.experience.renderer, this.debug = this.experience.debug
    }
    static getInstance() {
        return io._instance || new io
    }
    createRenderTarget(e, t, i = !1, s = !1, r = 0) {
        return new mn(e, t, {
            wrapS: pn,
            wrapT: pn,
            magFilter: i ? Kt : Pt,
            minFilter: i ? Kt : Pt,
            type: s ? this.floatType : hi,
            anisotropy: 0,
            colorSpace: Wt,
            depthBuffer: !0,
            stencilBuffer: !1,
            samples: this.sizes.pixelRatio <= 2 ? r : 0,
            depthTexture: new u0
        })
    }
    setInstance() { }
    setDebug() { }
};
Ae(io, "_instance", null);
let Yg = io;
var OU = `varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    UU = `uniform sampler2D baseTexture;
uniform sampler2D bloomTexture;

varying vec2 vUv;

void main() {

    gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

    
}`,
    QU = `varying vec2 vUv;
uniform sampler2D blurTexture1;
uniform sampler2D blurTexture2;
uniform sampler2D blurTexture3;
uniform sampler2D blurTexture4;
uniform sampler2D blurTexture5;
uniform sampler2D dirtTexture;
uniform float bloomStrength;
uniform float bloomRadius;
uniform float bloomFactors[NUM_MIPS];
uniform vec3 bloomTintColors[NUM_MIPS];
uniform vec3 uTintColor;
uniform float uTintStrength;

float lerpBloomFactor(const in float factor) {
    float mirrorFactor = 1.2 - factor;
    return mix(factor, mirrorFactor, bloomRadius);
}

void main() {
    vec4 color = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
    lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
    lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
    lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
    lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );

    color.rgb = mix(color.rgb, uTintColor, uTintStrength);
    gl_FragColor = color;
}`;
class zU {
    constructor(e) {
        Ae(this, "experience", ai.getInstance());
        Ae(this, "debug", $s.getInstance());
        Ae(this, "sizes", Ss.getInstance());
        Ae(this, "state", Ms.getInstance());
        Ae(this, "materials", Du.getInstance());
        Ae(this, "fbo", Yg.getInstance());
        Ae(this, "rendererClass", this.experience.renderer);
        Ae(this, "scene", experience.scene);
        Ae(this, "time", experience.time);
        Ae(this, "camera", experience.camera.instance);
        Ae(this, "resources", experience.resources);
        Ae(this, "timeline", experience.time.timeline);
        Ae(this, "container", new Hn);
        this.renderer = e, this.setComposer(), this.setDebug()
    }
    setComposer() {
        this.renderPass = new wU(this.scene, this.camera), this.bloomComposer = this._bloomComposer(), this.mixPass = this._mixPass(), this.outputPass = new MU, this.bokehPass = this._bokehPass(), this.renderTarget = this.fbo.createRenderTarget(this.sizes.width, this.sizes.height, !1, !1, 0), this.composer = new ox(this.renderer, this.renderTarget), this.composer.setSize(this.sizes.width, this.sizes.height), this.composer.setPixelRatio(this.sizes.pixelRatio), this.composer.addPass(this.renderPass), this.composer.addPass(this.mixPass), this.composer.addPass(this.unrealBloomPass), this.composer.addPass(this.bokehPass), this.composer.addPass(this.outputPass)
    }
    _bloomComposer() {
        this.renderTargetBloom = this.fbo.createRenderTarget(this.sizes.width, this.sizes.height, !1, !1, 0), this.unrealBloomPass = this._bloomPass();
        const e = new ox(this.renderer, this.renderTargetBloom);
        return e.setSize(this.sizes.width, this.sizes.height), e.setPixelRatio(this.sizes.pixelRatio), e.renderToScreen = !1, e.addPass(this.renderPass), e.addPass(this.unrealBloomPass), e
    }
    _bloomPass() {
        const e = new Xl(new _e(this.sizes.width, this.sizes.height), this.state.unrealBloom.strength, this.state.unrealBloom.radius, this.state.unrealBloom.threshold);
        return e.enabled = this.state.unrealBloom.enabled, e.renderToScreen = !1, e.tintColor = {}, e.tintColor.value = this.state.unrealBloom.tintColor, e.tintColor.instance = new Ue(e.tintColor.value), e.compositeMaterial.uniforms.uTintColor = {
            value: e.tintColor.instance
        }, e.compositeMaterial.uniforms.uTintStrength = {
            value: this.state.unrealBloom.uTintStrength
        }, e.compositeMaterial.fragmentShader = QU, e
    }
    _mixPass() {
        const e = new BC(new ti({
            uniforms: {
                baseTexture: {
                    value: null
                },
                bloomTexture: {
                    value: this.bloomComposer.renderTarget2.texture
                }
            },
            vertexShader: OU,
            fragmentShader: UU,
            defines: {}
        }), "baseTexture");
        return e.needsSwap = !0, e
    }
    _motionBlurPass() {
        const e = new Ni(this.scene, this.camera);
        return e.enabled = this.state.motionBlur.enabled, e.samples = this.state.motionBlur.samples, e.expandGeometry = this.state.motionBlur.expandGeometry, e.interpolateGeometry = this.state.motionBlur.interpolateGeometry, e.renderCameraBlur = this.state.motionBlur.cameraBlur, e.smearIntensity = this.state.motionBlur.smearIntensity, e.jitter = this.state.motionBlur.jitter, e.jitterStrategy = this.state.motionBlur.jitterStrategy, e
    }
    _bokehPass() {
        return new FU(this.scene, this.camera, {
            focus: this.state.bokeh.focus,
            aperture: this.state.bokeh.aperture * 1e-5,
            maxblur: this.state.bokeh.maxblur
        })
    }
    resize() {
        var e, t;
        this.composer.setSize(this.sizes.width, this.sizes.height), this.composer.setPixelRatio(this.sizes.pixelRatio), (e = this.bloomComposer) == null || e.setSize(this.sizes.width, this.sizes.height), (t = this.bloomComposer) == null || t.setPixelRatio(this.sizes.pixelRatio)
    }
    setDebug() {
        if (this.debug.active && this.debug.panel) {
            const e = this.debug.panel.addFolder("PostProcess"),
                t = e.addFolder("UnrealBloomPass");
            t.add(this.unrealBloomPass, "enabled").name("Enabled").onChange(() => {
                this.mixPass.enabled = this.unrealBloomPass.enabled
            }), t.add(this.unrealBloomPass, "strength").min(0).max(5).step(.001).name("Strength"), t.add(this.unrealBloomPass, "radius").min(-2).max(1).step(.001).name("Radius"), t.add(this.unrealBloomPass, "threshold").min(0).max(1).step(.001).name("Threshold"), t.addColor(this.unrealBloomPass.tintColor, "value").name("Tint Color").onChange(() => {
                this.unrealBloomPass.tintColor.instance.set(this.unrealBloomPass.tintColor.value)
            }), t.add(this.unrealBloomPass.compositeMaterial.uniforms.uTintStrength, "value").name("Tint Strength").min(0).max(1).step(.001);
            const i = e.addFolder("Bokeh"),
                s = () => {
                    this.bokehPass.uniforms.focus.value = this.state.bokeh.focus, this.bokehPass.uniforms.aperture.value = this.state.bokeh.aperture * 1e-5, this.bokehPass.uniforms.maxblur.value = this.state.bokeh.maxblur
                };
            i.add(this.state.bokeh, "enabled").name("Enabled").onChange(() => {
                this.bokehPass.enabled = this.state.bokeh.enabled
            }), i.add(this.state.bokeh, "focus", 0, 300).step(.001).onChange(s), i.add(this.state.bokeh, "aperture", 0, 10).step(.1).onChange(s), i.add(this.state.bokeh, "maxblur", 0, .09).step(.001).onChange(s)
        }
    }
    bloomRender() {
        this.unrealBloomPass.enabled && (this.scene.traverse(this.materials._darkenNonBloomed), this.bloomComposer.render(), this.scene.traverse(this.materials._restoreMaterial))
    }
    productionRender() {
        this.state.postprocessing ? (this.bloomRender(), this.composer.render()) : this.renderer.render(this.scene, this.camera)
    }
    debugRender() {
        this.state.postprocessing ? (this.bloomRender(), this.renderer.autoClear = !1, this.composer.render(), this.renderer.clearDepth()) : (this.renderer.autoClear = !1, this.renderer.clearColor(this.rendererClass.clearColor), this.renderer.render(this.scene, this.camera), this.renderer.clearDepth())
    }
    update(e) {
        this.debug.active ? this.debugRender() : this.productionRender()
    }
}
const no = class no extends rc {
    constructor(t) {
        super();
        Ae(this, "appLoaded", !1);
        Ae(this, "firstRender", !1);
        if (no._instance) return no._instance;
        if (no._instance = this, window.experience = this, window.addEventListener("3d-app:loaded", () => {
            this.appLoaded = !0
        }), this.html = {}, this.html.preloader = document.getElementById("preloader"), this.html.playButton = document.getElementById("play-button"), this.canvas = t, vt.enabled = !1, !this.canvas) {
            console.warn("Missing 'Canvas' property");
            return
        }
        this.setDefaultCode(), this.resources = new NO(UO), this.init()
    }
    static getInstance() {
        return no._instance || new no
    }
    init() {
        this.debug = new $s, this.sizes = new Ss, this.time = new cf, this.input = new Pu, this.scene = new d0, this.camera = new m3, this.renderer = new g3, this.state = new Ms, this.sound = new OO, this.world = new B3, this.postProcess = new zU(this.renderer.instance), this.setListeners(), this.trigger("classesReady")
    }
    postInit() { }
    resize() {
        this.camera.resize(), this.world.resize(), this.renderer.resize(), this.postProcess.resize(), this.debug.resize()
    }
    update() {
        this.camera.update(this.time.delta), this.world.update(this.time.delta), this.state.postprocessing ? this.postProcess.update(this.time.delta) : this.renderer.update(this.time.delta), this.debug.active && this.debug.update(this.time.delta), this.postUpdate()
    }
    postUpdate() {
        this.firstRender === !0 && (window.dispatchEvent(new CustomEvent("app:models-loaded")), this.firstRender = 2), this.resources.loadedAll && this.appLoaded && this.firstRender === !1 && (this.firstRender = !0)
    }
    setListeners() {
        this.sizes.on("resize", () => {
            this.resize()
        }), this.time.on("tick", () => {
            var t, i;
            this.update(), (i = (t = this.debug) == null ? void 0 : t.stats) == null || i.update()
        })
    }
    setDefaultCode() {
        document.ondblclick = function (t) {
            t.preventDefault()
        }, bt.registerPlugin(IC), this.isMobile()
    }
    isMobile() {
        let t = !1;
        return function (i) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(i) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(i.substr(0, 4))) && (t = !0)
        }(navigator.userAgent || navigator.vendor || window.opera), this.isMobile = t, t
    }
    destroy() {
        this.sizes.off("resize"), this.time.off("tick"), this.scene.traverse(t => {
            if (t instanceof Ri) {
                t.geometry.dispose();
                for (const i in t.material) {
                    const s = t.material[i];
                    s && typeof s.dispose == "function" && s.dispose()
                }
            }
        }), this.camera.controls.dispose(), this.renderer.instance.dispose(), this.debug.active && this.debug.ui.destroy()
    }
};
Ae(no, "_instance", null);
let ai = no;
const GU = ({
    canvas: n
}) => {
    new ai(n)
},
    HU = {
        name: "AppThreeCanvas",
        mounted() {
            this.$nextTick(() => {
                const {
                    canvas: n
                } = this.$refs;
                GU({
                    canvas: n
                })
            })
        }
    },
    VU = {
        ref: "canvas",
        class: "app-three-scene"
    };

function WU(n, e, t, i, s, r) {
    return Ge(), st("canvas", VU, null, 512)
}
const qU = ki(HU, [
    ["render", WU]
]),
    Tr = {
        methods: {
            ...RA(gn, ["setCurrentSectionId"]),
            setCurrentSection() {
                this.setCurrentSectionId(this.$el.id)
            }
        }
    },
    $U = {
        name: "SectionHero",
        mixins: [Tr],
        computed: {
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        onEnter: this.setCurrentSection,
                        onEnterBack: this.setCurrentSection
                    },
                    callback: this.createMainTimeline
                }]
            }
        },
        methods: {
            createMainTimeline() {
                const n = this.$refs.header,
                    e = this.$refs["desc-text"],
                    t = this.$refs["desc-btn"];
                bt.to(n.children[0], {
                    y: 0,
                    duration: 1,
                    opacity: 1,
                    delay: .3
                }), bt.to(n.children[1], {
                    y: 0,
                    duration: 1,
                    opacity: 1,
                    delay: .7
                }), bt.to(e, {
                    y: 0,
                    duration: 1,
                    opacity: 1,
                    delay: 1.3
                }), bt.to(t, {
                    y: 0,
                    duration: 1,
                    opacity: 1,
                    delay: 1.8
                })
            }
        },
        mounted() {
            this.$nextTick(() => {
                const n = this.$refs.header,
                    e = this.$refs["desc-text"],
                    t = this.$refs["desc-btn"];
                bt.set(n.children[0], {
                    y: 50,
                    opacity: 0
                }), bt.set(n.children[1], {
                    y: 50,
                    opacity: 0
                }), bt.set(e, {
                    y: -20,
                    opacity: 0
                }), bt.set(t, {
                    y: -20,
                    opacity: 0
                })
            })
        }
    },
    jU = {
        class: "section-hero"
    },
    YU = {
        class: "container"
    },
    XU = {
        class: "section-hero__content"
    },
    KU = {
        class: "section-hero__header"
    },
    JU = {
        ref: "header",
        class: "section-hero__header-text"
    },
    ZU = ie("span", {
        class: "first"
    }, "AI —", -1),
    eQ = ie("span", {
        class: "second"
    }, "Any Inu", -1),
    tQ = [ZU, eQ],
    iQ = {
        class: "section-hero__desc"
    },
    nQ = {
        ref: "desc-text",
        class: "section-hero__desc-text"
    },
    sQ = {
        ref: "desc-btn",
        class: "section-hero__desc-button g-button g-button--default g-button--animation",
        href: "https://matcha.xyz/tokens/ethereum/0x2598c30330d5771ae9f983979209486ae26de875?sellChain=1&sellAddress=0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
        target: "_blank"
    },
    rQ = {
        class: "icon-wrap"
    };

function oQ(n, e, t, i, s, r) {
    const o = Mt("g-arrow-down-right"),
        a = Mt("g-layout-section");
    return Ge(), yn(a, {
        id: "hero",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", jU, [ie("div", YU, [ie("div", XU, [ie("div", KU, [ie("h1", JU, tQ, 512)]), ie("div", iQ, [ie("p", nQ, " It's where smarts meet wags – Any Inu, the dog that's leading the crypto pack – and beyond! ", 512), ie("a", sQ, [bo(" Buy Now "), ie("div", rQ, [gt(o)])], 512)])])])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const aQ = ki($U, [
    ["render", oQ]
]),
    lQ = [{
        title: "Multichain Mayhem",
        desc: `Meet the "Multichain Mutt", strutting across 17 EVM chains and Solana like it owns the place. With Axelar's Interchain service as its leash, $AI hops from chain to chain with the ease of a frisky pup at a dog park. This wide-ranging presence makes $AI the ultimate party animal in the blockchain world.`
    }, {
        title: "Fair Play, No Dog Tricks",
        desc: `Forget the old "fetch the stick" game. $AI plays fair, with no tax, no presales, and absolutely no whitelist shenanigans. Think of it as the good boy of the crypto world – no hidden treats, just a fixed supply of 420,690,000,000 tokens, all wagging their tails equally. Contracts renounced? Check. Initial LP burnt to a crisp? Check. This is $AI's pledge for a tail-waggingly transparent community.`
    }, {
        title: "Paws and Reflect: Community at Heart",
        desc: "$AI isn't just a token; it's a community where dog lovers and tech geeks unite in a howl of joy. With the Diamond Hands app, hodlers are more than just number-crunchers; they're part of a pack. Think of it as a loyalty program, but with more woofs and less snooze. Add to that the promise of Composable Interchain NFTs, and you've got a token that's not just a financial fling but a lifelong furry friend."
    }];

function Po(n, e) {
    return n.addLabel("begin"), e.forEach(({
        elem: t,
        y: i = -20,
        delay: s = 0
    }) => {
        bt.set(t, {
            y: i,
            opacity: 0
        }), n.to(t, {
            y: 0,
            opacity: 1,
            delay: s
        }, "begin")
    }), n
}
const cQ = {
    name: "SectionWhyWe",
    mixins: [Tr],
    data: () => ({
        list: lQ,
        snapConfig: {
            snapTo: "labels",
            duration: {
                min: 2,
                max: 3
            },
            ease: "power1.in"
        }
    }),
    computed: {
        ...fs(gn, ["activeBreakpoint", "breakpoints"]),
        timelinesOptions() {
            return [{
                scrollTrigger: {
                    pin: !0,
                    markers: !1,
                    scrub: !0,
                    snap: this.snapConfig,
                    end: this.calculateEndSection,
                    onEnter: this.setCurrentSection,
                    onEnterBack: this.setCurrentSection
                },
                media: {
                    isDesktop: `(min-width: ${this.breakpoints.xl + .5}px)`,
                    isTablet: `(min-width: ${this.breakpoints.md + .5}px)`,
                    isDestroy: `(max-width: ${this.breakpoints.md}px)`
                },
                callback: this.createMainTimeline
            }, {
                scrollTrigger: {
                    markers: !1,
                    start: "top top"
                },
                media: {
                    isDesktop: `(min-width: ${this.breakpoints.md + .5}px)`
                },
                callback: this.createSecondaryTimeline
            }, {
                scrollTrigger: {
                    markers: !1,
                    start: "top-=200 top"
                },
                media: {
                    isMobile: `(max-width: ${this.breakpoints.md}px)`
                },
                callback: this.createSecondaryTimeline
            }]
        }
    },
    methods: {
        createMainTimeline(n, e) {
            const {
                isDesktop: s,
                isDestroy: r
            } = e.conditions;
            if (!r) {
                const {
                    cards: o
                } = this.$refs;
                let a = 50;
                s && (a = 50), n.addLabel("begin"), n.addLabel("afterBegin"), o.forEach((l, c) => {
                    const u = c + 1,
                        d = Math.ceil(o.length / 2),
                        h = (u - d) * a;
                    bt.set(l, {
                        yPercent: -50,
                        y: window.innerHeight / 3,
                        opacity: 0
                    }), n.addLabel(`start_${u}`), n.to(l, {
                        yPercent: -50,
                        y: h,
                        opacity: 1
                    }, `start_${u}+=1`)
                }), n.addLabel("end"), n.pause()
            }
        },
        createSecondaryTimeline(n) {
            const {
                title: e,
                desc: t
            } = this.$refs;
            Po(n, [{
                elem: e
            }, {
                elem: t,
                delay: .2
            }])
        },
        calculateEndSection() {
            const {
                cards: n,
                header: e
            } = this.$refs, t = n.reduce((i, s) => i + s.offsetHeight, 0);
            return (e.offsetHeight + t) * 1.5
        }
    }
},
    uQ = {
        class: "section-why-we"
    },
    dQ = {
        class: "container"
    },
    hQ = {
        class: "section-why-we__content"
    },
    fQ = {
        ref: "header",
        class: "section-why-we__header"
    },
    pQ = {
        ref: "title",
        class: "section-why-we__header-title"
    },
    mQ = {
        ref: "desc",
        class: "section-why-we__header-desc"
    },
    gQ = {
        class: "section-why-we__cards"
    },
    AQ = {
        class: "section-why-we__card-title"
    },
    _Q = {
        class: "section-why-we__card-desc"
    };

function vQ(n, e, t, i, s, r) {
    const o = Mt("g-layout-section");
    return Ge(), yn(o, {
        id: "why-we",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", uQ, [ie("div", dQ, [ie("div", hQ, [ie("div", fQ, [ie("h2", pQ, " Why Any Inu? – Unleash the Distinctive Bark in the Crypto Park ", 512), ie("p", mQ, " Dive into the quirky and innovative world of Any Inu, where cutting-edge technology meets a community with a sense of humor. ", 512)], 512), ie("div", gQ, [(Ge(!0), st(Bt, null, xn(n.list, (a, l) => (Ge(), st("div", {
            ref_for: !0,
            ref: "cards",
            class: "section-why-we__card",
            key: l
        }, [ie("h3", AQ, Pi(a.title), 1), ie("p", _Q, Pi(a.desc), 1)]))), 128))])])])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const bQ = ki(cQ, [
    ["render", vQ]
]),
    xQ = [{
        title: "Phase 1",
        date: "22/10/2023",
        infoList: [{
            head: "Explorer/Dex Information :",
            text: "Sniffing out the best insights."
        }, {
            head: "Stats Dashboard :",
            text: "Shiny as a freshly groomed pup."
        }, {
            head: "Gecko/CMC listings :",
            text: "Jumping higher than a dog after its favorite frisbee."
        }, {
            head: "Socials Verification :",
            text: "Barking loud and proud across all platforms."
        }]
    }, {
        title: "Phase 2",
        date: "22/10/2023",
        infoList: [{
            head: "Community Incentivized Campaigns :",
            text: "Treats for every tail-wagger in our pack."
        }, {
            head: "Diamond Hands DApp :",
            text: "For those who stick with us longer than a dog with its favorite bone."
        }, {
            head: "1st CEX Listing :",
            text: "Catching our first big break like a pro fetch champion."
        }, {
            head: "Wrapped on BTC :",
            text: "Cuddling up with Bitcoin for those cozy crypto nights."
        }]
    }, {
        title: "Phase 3",
        date: "22/10/2023",
        infoList: [{
            head: "Support on Cosmos EVM :",
            text: "Expanding our territory to the stars and beyond."
        }, {
            head: "Composable Interchain NFTs :",
            text: "Flexing our tricks in the NFT playground."
        }, {
            head: "2nd CEX Listing :",
            text: "Another leap for Any Inu, another giant fetch for crypto-kind."
        }, {
            head: "Any Inu Artificial Intelligence :",
            text: "Redefining the term 'smart dog'."
        }]
    }, {
        title: "Phase 4",
        date: "22/10/2023",
        infoList: [{
            head: "Support on any EVM :",
            text: "Playing fetch across every blockchain park."
        }, {
            head: "Gaming with $AI :",
            text: "Unleashing the playful pup in all of us."
        }, {
            head: "Further CEX Listings :",
            text: "Chasing more listings like a dog after endless sticks."
        }, {
            head: "Interchain Utilities (Bot-based) :",
            text: "Sniffing around every corner of the blockchain universe."
        }]
    }, {
        title: "Phase 5",
        date: "22/10/2023",
        infoList: [{
            head: "Support on non-EVM chains :",
            text: "Venturing into new realms without leaving our comfy kennel."
        }, {
            head: "Community Governance :",
            text: "Every dog owner gets a say - Woof!"
        }, {
            head: "1,000,000+ Holders :",
            text: "A pack that any dog would envy."
        }, {
            head: "Interchain DApps :",
            text: "Building the ultimate dog park in the crypto space."
        }]
    }],
    yQ = {
        name: "SectionRoadmap",
        mixins: [Tr],
        data: () => ({
            list: xQ,
            points: [],
            items: [],
            snapConfig: {
                snapTo: "labelsDirectional",
                duration: {
                    min: .1,
                    max: 3
                },
                ease: "expo.out"
            },
            activeIndexItem: -1,
            activePointPercentPosition: 0
        }),
        watch: {
            activeIndexItem() {
                this.getActivePositionPoint()
            }
        },
        computed: {
            ...fs(gn, ["breakpoints"]),
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        pin: !0,
                        markers: !1,
                        scrub: !0,
                        snap: this.snapConfig,
                        end: this.calculateEndSection,
                        onUpdate: this.onUpdateSection,
                        onEnter: this.setCurrentSection,
                        onEnterBack: this.setCurrentSection
                    },
                    callback: this.createMainTimeline
                }, {
                    scrollTrigger: {
                        markers: !1,
                        start: "top-=200 top"
                    },
                    callback: this.createSecondaryTimeline
                }]
            }
        },
        mounted() {
            this.$nextTick(() => {
                this.points = this.$refs.points || [], this.items = this.$refs.items || [], setTimeout(() => {
                    this.checkPositionsPoints(), this.getActivePositionPoint()
                }, 100), window.addEventListener("resize", this.resize.bind(this))
            })
        },
        unmounted() {
            window.removeEventListener("resize", this.resize.bind(this))
        },
        methods: {
            resize() {
                this.checkPositionsPoints(), this.getActivePositionPoint()
            },
            createMainTimeline(n) {
                const {
                    items: e,
                    itemsContainer: t,
                    laserLine: i
                } = this.$refs;
                bt.set(i, {
                    opacity: 0
                }), n.to(i, {
                    opacity: 1
                }), n.addLabel("begin"), e.forEach((s, r) => {
                    const o = s.querySelector(".section-roadmap__item-title"),
                        a = s.querySelector(".section-roadmap__item-info"),
                        l = e[r - 1] || e[0];
                    e[r + 1] || e[e.length - 1];
                    const c = l.querySelector(".section-roadmap__item-title"),
                        u = l.querySelector(".section-roadmap__item-info");
                    bt.set(o, {
                        y: 20,
                        opacity: 0
                    }), bt.set(a, {
                        y: 10,
                        opacity: 0
                    });
                    const d = r + 1;
                    n.addLabel(`start_${d}`), r === 0 ? (n.to(o, {
                        y: 0,
                        opacity: 1,
                        onStart: () => {
                            this.activeIndexItem = r
                        },
                        onReverseComplete: () => {
                            this.activeIndexItem = r - 1
                        }
                    }), n.to(a, {
                        y: 0,
                        opacity: 1
                    })) : (n.to(t, {
                        y: `-=${s.offsetHeight + 20}`,
                        onStart: () => {
                            this.activeIndexItem = r
                        },
                        onReverseComplete: () => {
                            this.activeIndexItem = r - 1
                        }
                    }, `start_${d}+=0.1`), n.to(o, {
                        opacity: 1,
                        y: 0
                    }, "-=0.1"), n.to(a, {
                        opacity: 1,
                        y: 0
                    }, "-=0.1"), n.to(c, {
                        opacity: 0,
                        y: -20
                    }, `start_${d}-=0.05`), n.to(u, {
                        opacity: 0,
                        y: -20
                    }, `start_${d}-=0.05`))
                }), n.addLabel("end")
            },
            createSecondaryTimeline(n) {
                const {
                    title: e,
                    desc: t
                } = this.$refs;
                Po(n, [{
                    elem: e
                }, {
                    elem: t,
                    delay: .2
                }])
            },
            calculateEndSection() {
                const {
                    body: n
                } = this.$refs;
                return n.offsetHeight * 5
            },
            getActivePositionPoint() {
                var n, e;
                if (this.activeIndexItem <= this.points.length - 1) {
                    const t = (n = this.$refs) == null ? void 0 : n.laserLine,
                        i = (t == null ? void 0 : t.scrollHeight) || 0,
                        r = (((e = this.points[this.activeIndexItem]) == null ? void 0 : e.offsetTop) || 0) / i * 100;
                    this.activePointPercentPosition = r || 0
                } else this.activePointPercentPosition = 100
            },
            checkPositionsPoints() {
                const n = window.innerWidth > 768 ? 8 : 3;
                this.items.forEach((e, t) => {
                    const {
                        offsetTop: i
                    } = e, s = this.points[t];
                    s.style.top = `${i + n}px`
                })
            },
            onUpdateSection(n) { }
        }
    },
    EQ = {
        class: "section-roadmap"
    },
    wQ = {
        class: "container"
    },
    CQ = {
        class: "section-roadmap__content"
    },
    SQ = {
        class: "section-roadmap__header"
    },
    MQ = {
        ref: "title",
        class: "section-roadmap__header-title"
    },
    TQ = {
        ref: "desc",
        class: "section-roadmap__header-desc"
    },
    IQ = {
        ref: "body",
        class: "section-roadmap__body"
    },
    BQ = {
        ref: "itemsContainer",
        class: "section-roadmap__wrap-transform"
    },
    RQ = {
        class: "section-roadmap__laser"
    },
    PQ = {
        ref: "laserLine",
        class: "section-roadmap__laser-line"
    },
    DQ = ie("div", {
        class: "section-roadmap__laser-dot"
    }, null, -1),
    LQ = [DQ],
    kQ = {
        class: "section-roadmap__laser-points"
    },
    FQ = ie("div", {
        class: "circle outer-circle"
    }, [ie("div", {
        class: "circle inner-circle"
    }, [ie("div", {
        class: "circle center-circle"
    })])], -1),
    NQ = [FQ],
    OQ = {
        class: "section-roadmap__list"
    },
    UQ = {
        class: "section-roadmap__item-header"
    },
    QQ = {
        class: "section-roadmap__item-title"
    },
    zQ = {
        class: "section-roadmap__item-info"
    },
    GQ = {
        class: "head"
    },
    HQ = {
        class: "text"
    };

function VQ(n, e, t, i, s, r) {
    const o = Mt("g-layout-section");
    return Ge(), yn(o, {
        id: "roadmap",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", EQ, [ie("div", wQ, [ie("div", CQ, [ie("div", SQ, [ie("h2", MQ, "Project Roadmap", 512), ie("p", TQ, " Dive into the fun-filled journey of Any Inu. Here's our roadmap, showcasing how we're evolving into the alpha dog of the crypto world. ", 512)]), ie("div", IQ, [ie("div", BQ, [ie("div", RQ, [ie("div", PQ, [ie("div", {
            class: "section-roadmap__laser-line--active",
            style: Cf(`height: calc(${n.activePointPercentPosition}% + var(--offset-circle))`)
        }, LQ, 4), ie("div", kQ, [(Ge(!0), st(Bt, null, xn(n.list, (a, l) => (Ge(), st("div", {
            ref_for: !0,
            ref: "points",
            class: xr(["section-roadmap__laser-point", {
                active: l <= n.activeIndexItem
            }]),
            key: l
        }, NQ, 2))), 128))])], 512)]), ie("div", OQ, [(Ge(!0), st(Bt, null, xn(n.list, (a, l) => (Ge(), st("div", {
            ref_for: !0,
            ref: "items",
            class: xr(["section-roadmap__item", {
                reverse: l % 2
            }]),
            key: l
        }, [ie("div", UQ, [ie("h4", QQ, Pi(a.title), 1)]), ie("div", zQ, [(Ge(!0), st(Bt, null, xn(a.infoList, (c, u) => (Ge(), st("div", {
            class: "section-roadmap__item-row",
            key: u
        }, [ie("b", GQ, Pi(c.head) + "  ", 1), ie("span", HQ, Pi(c.text), 1)]))), 128))])], 2))), 128))])], 512)], 512)])])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const WQ = ki(yQ, [
    ["render", VQ]
]),
    qQ = [{
        image: "ethereum.svg",
        title: "Ethereum",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://app.uniswap.org/swap?outputCurrency=0x2598c30330d5771ae9f983979209486ae26de875&inputCurrency=ETH",
        explorer: "https://etherscan.io/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "solana.png",
        title: "Solana",
        token: "ACeWC77UeW2DBZMe7YBsuXoxLvk4dHMnPzneApau1Au6",
        link: "https://jup.ag/swap/SOL-AI_ACeWC77UeW2DBZMe7YBsuXoxLvk4dHMnPzneApau1Au6",
        explorer: "https://solscan.io/token/ACeWC77UeW2DBZMe7YBsuXoxLvk4dHMnPzneApau1Au6#holders"
    }, {
        image: "binance-chain.png",
        title: "BinanceChain",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://pancakeswap.finance/swap?chain=bsc&outputCurrency=0x2598c30330D5771AE9F983979209486aE26dE875",
        explorer: "https://bscscan.com/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "polygon.png",
        title: "Polygon",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://matcha.xyz/tokens/polygon/0x2598c30330d5771ae9f983979209486ae26de875?sellChain=137&sellAddress=0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
        explorer: "https://polygonscan.com/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "avalanche.png",
        title: "Avalanche",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://matcha.xyz/tokens/avalanche/0x2598c30330d5771ae9f983979209486ae26de875?sellChain=43114&sellAddress=0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
        explorer: "https://snowtrace.io/token/0x2598c30330D5771AE9F983979209486aE26dE875/balances?chainId=43114"
    }, {
        image: "arbitrum.svg",
        title: "Arbitrum",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://matcha.xyz/tokens/arbitrum/0x2598c30330d5771ae9f983979209486ae26de875?sellChain=42161&sellAddress=0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
        explorer: "https://arbiscan.io/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "base.png",
        title: "Base",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://app.uniswap.org/swap?outputCurrency=0x2598c30330d5771ae9f983979209486ae26de875&inputCurrency=0x4200000000000000000000000000000000000006",
        explorer: "https://basescan.org/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "fantom.png",
        title: "Fantom",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://swap.spiritswap.finance/#/exchange/swap?outputCurrency=0x2598c30330d5771ae9f983979209486ae26de875&inputCurrency=0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
        explorer: "https://ftmscan.com/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "optimism.png",
        title: "Optimism",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "https://app.uniswap.org/swap?outputCurrency=0x2598c30330d5771ae9f983979209486ae26de875&inputCurrency=0x4200000000000000000000000000000000000006",
        explorer: "https://optimistic.etherscan.io/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "mantle.png",
        title: "Mantle",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://explorer.mantle.xyz/address/0x2598c30330D5771AE9F983979209486aE26dE875#address-tabs"
    }, {
        image: "moonbeam.png",
        title: "Moonbeam",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://moonscan.io/token/0x2598c30330d5771ae9f983979209486ae26de875#balances"
    }, {
        image: "filecoin.png",
        title: "Filecoin",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://filfox.info/en/address/0x2598c30330D5771AE9F983979209486aE26dE875?t=0"
    }, {
        image: "celo.png",
        title: "Celo",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://celoscan.io/token/0x2598c30330d5771ae9f983979209486ae26de875#balances"
    }, {
        image: "kava.png",
        title: "Kava",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://kavascan.com/token/0x2598c30330D5771AE9F983979209486aE26dE875?t=balances"
    }, {
        image: "scroll.png",
        title: "Scroll",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://scrollscan.com/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "linea.png",
        title: "Linea",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://lineascan.build/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }, {
        image: "blast.png",
        title: "Blast",
        token: "0x764933fbAd8f5D04Ccd088602096655c2ED9879F",
        link: "https://app.thruster.finance/?token1=0x0000000000000000000000000000000000000000&token2=0x764933fbAd8f5D04Ccd088602096655c2ED9879F",
        explorer: "https://blastscan.io/token/0x764933fbad8f5d04ccd088602096655c2ed9879f#balances"
    }, {
        image: "fraxtal.png",
        title: "Fraxtal",
        token: "0x2598c30330D5771AE9F983979209486aE26dE875",
        link: "/",
        explorer: "https://fraxscan.com/token/0x2598c30330D5771AE9F983979209486aE26dE875#balances"
    }],
    $Q = {
        name: "SectionConverter",
        mixins: [Tr],
        data: () => ({
            list: qQ,
            enableCoinsListScroll: !1
        }),
        computed: {
            ...fs(gn, ["breakpoints"]),
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        pin: !0,
                        markers: !1,
                        scrub: !0,
                        snap: "labelsDirectional",
                        onEnter: this.setCurrentSection,
                        onEnterBack: this.setCurrentSection
                    },
                    media: {
                        isDesktop: `(min-width: ${this.breakpoints.xl + .5}px)`
                    },
                    callback: this.createMainTimeline
                }, {
                    scrollTrigger: {
                        markers: !1,
                        start: "top-=200 top"
                    },
                    callback: this.createSecondaryTimeline
                }]
            }
        },
        beforeUnmount() {
            this.$refs.coinsList.removeEventListener("wheel", this.handleScroll)
        },
        methods: {
            createMainTimeline(n) {
                const {
                    info: e,
                    list: t
                } = this.$refs;
                bt.set(t, {
                    yPercent: 100,
                    opacity: 0
                }), n.addLabel("begin").addLabel("show_list", "+=0.5").to(e, {
                    yPercent: -150,
                    opacity: 0
                }, "show_list").to(t, {
                    yPercent: 0,
                    opacity: 1
                }, "show_list").addLabel("end")
            },
            createSecondaryTimeline(n) {
                const {
                    title: e,
                    desc: t,
                    link: i
                } = this.$refs;
                Po(n, [{
                    elem: e
                }, {
                    elem: t,
                    delay: .2
                }, {
                    elem: i,
                    delay: .2
                }])
            },
            pointerenter({
                target: n
            }) {
                n.scrollHeight > n.offsetHeight && (n.addEventListener("wheel", this.handleScroll), this.enableCoinsListScroll = !0)
            },
            pointerleave({
                target: n
            }) {
                n.removeEventListener("wheel", this.handleScroll), this.enableCoinsListScroll = !1
            },
            handleScroll({
                currentTarget: n,
                deltaY: e
            }) {
                const t = n.scrollTop,
                    i = n.scrollHeight - n.clientHeight - 5;
                t === 0 && e < 0 || t >= i && e > 0 ? this.enableCoinsListScroll = !1 : this.enableCoinsListScroll = !0
            }
        }
    },
    jQ = {
        class: "section-converter-coins"
    },
    YQ = {
        class: "container"
    },
    XQ = {
        class: "section-converter-coins__content"
    },
    KQ = {
        ref: "info",
        class: "section-converter-coins__info"
    },
    JQ = {
        ref: "title",
        class: "section-converter-coins__info-title"
    },
    ZQ = {
        ref: "desc",
        class: "section-converter-coins__info-desc font-fira-code"
    },
    ez = {
        ref: "link",
        class: "section-converter-coins__info-button g-button g-button--default",
        href: "https://stats.anyinu.xyz/",
        target: "_blank"
    },
    tz = {
        class: "icon-wrap"
    },
    iz = ie("div", {
        class: "section-converter-coins__widget"
    }, [ie("iframe", {
        class: "section-converter-coins__iframe",
        width: "440",
        height: "690",
        src: "https://widget.squidrouter.com/iframe?config=%7B%22integratorId%22%3A%22any-inu-8ba9fded-f6fc-41b2-8bb5-2078ddd0308b%22%2C%22companyName%22%3A%22Any%20Inu%22%2C%22style%22%3A%7B%22neutralContent%22%3A%22%236A61FF%22%2C%22baseContent%22%3A%22%23FDFDFD%22%2C%22base100%22%3A%22%23342C90%22%2C%22base200%22%3A%22%23181C63%22%2C%22base300%22%3A%22%2313164E%22%2C%22error%22%3A%22%23ED6A5E%22%2C%22warning%22%3A%22%23FFB155%22%2C%22success%22%3A%22%232EAEB0%22%2C%22primary%22%3A%22%236C5BE0%22%2C%22secondary%22%3A%22%234030FA%22%2C%22secondaryContent%22%3A%22%23F6F7FB%22%2C%22neutral%22%3A%22%230C1536%22%2C%22roundedBtn%22%3A%228px%22%2C%22roundedCornerBtn%22%3A%22999px%22%2C%22roundedBox%22%3A%2212px%22%2C%22roundedDropDown%22%3A%228px%22%7D%2C%22slippage%22%3A1.5%2C%22infiniteApproval%22%3Afalse%2C%22enableExpress%22%3Atrue%2C%22apiUrl%22%3A%22https%3A%2F%2Fapi.squidrouter.com%22%2C%22mainLogoUrl%22%3A%22https%3A%2F%2Fraw.githubusercontent.com%2Fanyinu%2FMediaAssets%2Ff660da8963f55e249353f62522d0b479d6dbc7a0%2Fai.svg%22%2C%22comingSoonChainIds%22%3A%5B%5D%2C%22titles%22%3A%7B%22swap%22%3A%22Swap%22%2C%22settings%22%3A%22Settings%22%2C%22wallets%22%3A%22Wallets%22%2C%22tokens%22%3A%22Select%20Token%22%2C%22chains%22%3A%22Select%20Chain%22%2C%22history%22%3A%22History%22%2C%22transaction%22%3A%22Transaction%22%2C%22allTokens%22%3A%22Select%20Token%22%2C%22destination%22%3A%22Destination%20address%22%2C%22depositAddress%22%3A%22Deposit%20address%22%7D%2C%22priceImpactWarnings%22%3A%7B%22warning%22%3A3%2C%22critical%22%3A5%7D%2C%22environment%22%3A%22mainnet%22%2C%22showOnRampLink%22%3Atrue%2C%22defaultTokens%22%3A%5B%5D%7D",
        frameborder: "0"
    })], -1),
    nz = {
        ref: "list",
        class: "section-converter-coins__wrap-list"
    },
    sz = ["data-lenis-prevent"],
    rz = {
        class: "section-converter-coins__item-icon"
    },
    oz = ["src", "alt"],
    az = {
        class: "section-converter-coins__item-desc"
    },
    lz = {
        class: "section-converter-coins__item-title"
    },
    cz = ["href"],
    uz = ["href"],
    dz = {
        class: "icon-wrap"
    };

function hz(n, e, t, i, s, r) {
    const o = Mt("g-arrow-down-right"),
        a = Mt("g-layout-section");
    return Ge(), yn(a, {
        id: "chains",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", jQ, [ie("div", YQ, [ie("div", XQ, [ie("div", KQ, [ie("h2", JQ, " Galactic Gateway to Crypto Glory - Any Inu's Interstellar Express! ", 512), ie("p", ZQ, " Embark on an odyssey through the cryptoverse with Any Inu's Interstellar Express. Why settle for one blockchain when you can romp through a cosmic playground of 15+ chains? Explore like never before, purchase with a tap, and track your journey across the infinite possibilities. ", 512), ie("a", ez, [bo(" Stats Dashboard "), ie("div", tz, [gt(o)])], 512)], 512), iz, ie("div", nz, [ie("div", {
            ref: "coinsList",
            "data-lenis-prevent": n.enableCoinsListScroll ? "" : null,
            class: "section-converter-coins__list custom-scrollbar",
            onPointerenter: e[0] || (e[0] = (...l) => r.pointerenter && r.pointerenter(...l)),
            onPointerleave: e[1] || (e[1] = (...l) => r.pointerleave && r.pointerleave(...l))
        }, [(Ge(!0), st(Bt, null, xn(n.list, (l, c) => (Ge(), st("div", {
            class: "section-converter-coins__item",
            key: c
        }, [ie("div", rz, [ie("img", {
            class: "img",
            src: `/images/coins/${l.image}`,
            alt: l.title
        }, null, 8, oz)]), ie("div", az, [ie("h4", lz, Pi(l.title), 1), ie("a", {
            class: "section-converter-coins__item-token font-fira-code",
            href: `${l.explorer}`,
            target: "_blank"
        }, Pi(l.token), 9, cz)]), ie("a", {
            class: "section-converter-coins__item-button g-button g-button--default",
            href: l.link,
            target: "_blank"
        }, [bo(" Buy Now "), ie("div", dz, [gt(o)])], 8, uz)]))), 128))], 40, sz)], 512)])])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const fz = ki($Q, [
    ["render", hz]
]),
    pz = [{
        title: "Lock & Rock",
        desc: "Secure your $AI tokens like a bulldog with a bone. Choose from a week to a two-year term and watch your commitment grow!",
        icon: "/images/features/icon-lock.svg"
    }, {
        title: "Soulbound Swag",
        desc: "Get soulbound receipt tokens that are the envy of the kennel. It's like a badge of honor for your digital wallet!",
        icon: "/images/features/icon-label.svg"
    }, {
        title: "Leaderboard Legends",
        desc: "Climb the global multichain leaderboard where everyone can see who's the top dog in the long-term hodl game.",
        icon: "/images/features/icon-star.svg"
    }, {
        title: "Multiplier Magic",
        desc: "The longer you lock, the larger your multiplier – from a single tail wag (1x) to a full howl at the moon (5x)!",
        icon: "/images/features/icon-magic.svg"
    }, {
        title: "Renounced & Released",
        desc: "The app is the ultimate free spirit – no meddling developers here, just you and your tokens, free as a leashless pup.",
        icon: "/images/features/icon-ship.svg"
    }, {
        title: "Every Chain's a Home",
        desc: "Available on all EVM chains with liquidity, because why should any dog be limited to one backyard?",
        icon: "/images/features/icon-home.svg"
    }, {
        title: "Airdrops for the Alpha",
        desc: "Secure a spot for exclusive airdrops, governance votes, and community events. It’s like the VIP section at the dog park.",
        icon: "/images/features/icon-airdrop.svg"
    }, {
        title: "Community Collars",
        desc: "The more you lock, the higher your rank in the Any Inu pack. It's like collecting collars, but way cooler.",
        icon: "/images/features/icon-people.svg"
    }],
    mz = {
        list: pz
    },
    gz = {
        name: "SectionFeatures",
        mixins: [Tr],
        data: () => ({
            list: mz.list
        }),
        computed: {
            ...fs(gn, ["breakpoints", "activeBreakpoint"]),
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        pin: !0,
                        markers: !1,
                        scrub: !0,
                        snap: "labelsDirectional",
                        onEnter: this.setCurrentSection,
                        onEnterBack: this.setCurrentSection
                    },
                    media: {
                        isDesktop: `(min-width: ${this.breakpoints.xl + .5}px)`
                    },
                    callback: this.createMainTimeline
                }, {
                    scrollTrigger: {
                        markers: !1,
                        start: "top-=200 top"
                    },
                    callback: this.createSecondaryTimeline
                }]
            },
            sliderBreakpoints() {
                return {
                    [this.breakpoints.xl + .5]: {
                        allowTouchMove: !1
                    }
                }
            }
        },
        methods: {
            createMainTimeline(n, e) {
                const {
                    isDesktop: t
                } = e.conditions;
                t && (n.addLabel("begin"), this.list.forEach((i, s) => {
                    n.add(() => {
                        var r;
                        (r = this.$refs.swiperEl.swiper) == null || r.slideTo(s)
                    }, "+=1").addLabel(`slide_${s}`)
                }), n.addLabel("end"))
            },
            createSecondaryTimeline(n) {
                const {
                    title: e,
                    desc: t,
                    link: i
                } = this.$refs;
                Po(n, [{
                    elem: e
                }, {
                    elem: t,
                    delay: .2
                }, {
                    elem: i,
                    delay: .2
                }])
            }
        }
    },
    Az = {
        class: "section-features"
    },
    _z = {
        class: "container"
    },
    vz = {
        class: "section-features__content"
    },
    bz = {
        ref: "title",
        class: "section-features__title center"
    },
    xz = {
        ref: "desc",
        class: "section-features__desc center font-fira-code"
    },
    yz = {
        ref: "link",
        href: "https://app.anyinu.xyz/",
        class: "section-features__link g-button g-button--default"
    },
    Ez = {
        class: "icon-wrap"
    },
    wz = {
        class: "section-features__list-wrapper"
    },
    Cz = {
        ref: "featuresList",
        class: "container"
    },
    Sz = ["breakpoints", "injectStyles"],
    Mz = {
        class: "section-features__item-icon"
    },
    Tz = ["src"],
    Iz = {
        class: "section-features__item-title"
    },
    Bz = {
        class: "section-features__item-desc font-fira-code"
    };

function Rz(n, e, t, i, s, r) {
    const o = Mt("g-arrow-down-right"),
        a = Mt("g-layout-section");
    return Ge(), yn(a, {
        id: "diamond-hands",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", Az, [ie("div", _z, [ie("div", vz, [ie("h2", bz, " Diamond Hands App: The Ultimate Loyalty Program for the Crypto Canine Enthusiast! ", 512), ie("p", xz, " Lock your $AI and let the Diamond Hands app be the trusty leash that keeps your tokens safe and sound. It's like a digital doghouse for your tokens, but with a lot more treats! ", 512), ie("a", yz, [bo(" Enter Diamond Hands "), ie("span", Ez, [gt(o)])], 512)])]), ie("div", wz, [ie("div", Cz, [ie("swiper-container", {
            ref: "swiperEl",
            "space-between": 20,
            breakpoints: r.sliderBreakpoints,
            injectStyles: [".swiper {overflow: visible;}"],
            "slides-per-view": "auto",
            class: "section-features__list"
        }, [(Ge(!0), st(Bt, null, xn(n.list, (l, c) => (Ge(), st("swiper-slide", {
            key: c,
            class: "section-features__item"
        }, [ie("div", Mz, [ie("img", {
            src: l.icon,
            alt: ""
        }, null, 8, Tz)]), ie("h3", Iz, Pi(l.title), 1), ie("p", Bz, Pi(l.desc), 1)]))), 128))], 8, Sz)], 512)])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const Pz = ki(gz, [
    ["render", Rz]
]),
    Dz = {
        name: "SectionTokenSpecifics",
        mixins: [Tr],
        computed: {
            ...fs(gn, ["breakpoints", "activeBreakpoint"]),
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        pin: !0,
                        markers: !1,
                        start: "top top",
                        end: "bottom+=300 bottom",
                        onEnter: this.setCurrentSection,
                        onEnterBack: this.setCurrentSection
                    },
                    media: {
                        isDesktop: `(min-width: ${this.breakpoints.xl + .5}px)`
                    },
                    callback: this.createTimeline
                }, {
                    scrollTrigger: {
                        markers: !1,
                        start: "top-=300 top"
                    },
                    media: {
                        isMobile: `(max-width: ${this.breakpoints.xl}px)`
                    },
                    callback: this.createTimeline
                }]
            }
        },
        methods: {
            createTimeline(n) {
                const {
                    title: e,
                    desc: t,
                    link: i
                } = this.$refs;
                Po(n, [{
                    elem: e
                }, {
                    elem: t,
                    delay: .2
                }, {
                    elem: i,
                    delay: .2
                }])
            }
        }
    },
    Lz = {
        class: "section-token-specifics"
    },
    kz = {
        class: "container"
    },
    Fz = {
        class: "section-token-specifics__content"
    },
    Nz = {
        class: "section-token-specifics__header"
    },
    Oz = {
        ref: "title",
        class: "section-token-specifics__header-title"
    },
    Uz = {
        ref: "desc",
        class: "section-token-specifics__header-desc font-fira-code"
    },
    Qz = {
        ref: "link",
        class: "section-token-specifics__header-button g-button g-button--default",
        href: "https://docs.anyinu.xyz/technical/token-specifics",
        target: "_blank"
    },
    zz = {
        class: "icon-wrap"
    };

function Gz(n, e, t, i, s, r) {
    const o = Mt("g-arrow-down-right"),
        a = Mt("g-layout-section");
    return Ge(), yn(a, {
        id: "token-specifics",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", Lz, [ie("div", kz, [ie("div", Fz, [ie("div", Nz, [ie("h2", Oz, " Token Specifics ", 512), ie("p", Uz, " Embark on an odyssey through the cryptoverse with Any Inu's Interstellar Express. Why settle for one blockchain when you can romp through a cosmic playground of 15+ chains? Explore like never before, purchase with a tap, and track your journey across the infinite possibilities. ", 512), ie("a", Qz, [bo(" Learn more "), ie("div", zz, [gt(o)])], 512)])])])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const Hz = ki(Dz, [
    ["render", Gz]
]),
    Vz = [{
        title: "AI Doggos",
        info: "@AnyInuCoin"
    }, {
        title: "AI Doggos",
        info: "@AnyInuCoin"
    }, {
        title: "AI Doggos",
        info: "@AnyInuCoin"
    }, {
        title: "AI Doggos",
        info: "@AnyInuCoin"
    }, {
        title: "AI Doggos",
        info: "@AnyInuCoin"
    }],
    FC = {
        test: Vz
    },
    Wz = {
        name: "SectionMainCollection",
        mixins: [Tr],
        data: () => ({
            collection: FC.test,
            snapConfig: {
                snapTo: "labels",
                duration: {
                    min: .1,
                    max: 3
                },
                ease: "expo.out"
            }
        }),
        computed: {
            ...fs(gn, ["breakpoints", "activeBreakpoint"]),
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        pin: !0,
                        markers: !1,
                        scrub: 1,
                        snap: this.snapConfig,
                        onEnter: this.setCurrentSection,
                        onEnterBack: this.setCurrentSection
                    },
                    media: {
                        isDesktop: `(min-width: ${this.breakpoints.xl + .5}px)`
                    },
                    callback: this.createMainTimeline
                }, {
                    scrollTrigger: {
                        markers: !1,
                        start: "top-=200 top"
                    },
                    media: {
                        isMobile: `(max-width: ${this.breakpoints.xl}px)`
                    },
                    callback: this.createSecondaryTimeline
                }]
            },
            filteredCollection() {
                return this.collection.slice(0, 4)
            },
            sliderBreakpoints() {
                return {
                    [this.breakpoints.xl + .5]: {
                        slidesPerView: 4
                    }
                }
            }
        },
        methods: {
            createMainTimeline(n) {
                const {
                    title: e,
                    desc: t,
                    link: i,
                    items: s
                } = this.$refs;
                bt.set(e, {
                    y: -20,
                    opacity: 0
                }), bt.set(t, {
                    y: -20,
                    opacity: 0
                }), bt.set(i, {
                    y: -20,
                    opacity: 0
                }), n.addLabel("begin"), n.addLabel("rotate"), s.forEach((r, o) => {
                    const a = r.querySelector(".section-main-collection__item-wrapper");
                    bt.set(a, {
                        rotationY: 0
                    }), o === 0 ? n.to(a, {
                        rotationY: 50,
                        backgroundImage: "linear-gradient(273deg, rgba(0, 0, 0, 0.16) 2.7%, rgba(0, 0, 0, 0.80) 50.25%)",
                        duration: 1
                    }, "rotate") : o === 1 ? n.to(a, {
                        rotationY: 44,
                        backgroundImage: "linear-gradient(90deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 96.63%)",
                        xPercent: -60,
                        duration: 1
                    }, "rotate") : o === 2 ? n.to(a, {
                        rotationY: -44,
                        backgroundImage: "linear-gradient(90deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 96.63%)",
                        xPercent: 60,
                        duration: 1
                    }, "rotate") : n.to(a, {
                        rotationY: -50,
                        backgroundImage: "linear-gradient(273deg, rgba(0, 0, 0, 0.16) 2.7%, rgba(0, 0, 0, 0.80) 50.25%)",
                        duration: 1
                    }, "rotate")
                }), n.addLabel("beforeEnd"), n.to(e, {
                    y: 0,
                    opacity: 1
                }, "-=0.5"), n.to(t, {
                    y: 0,
                    opacity: 1,
                    delay: .1
                }, "-=0.5"), n.to(i, {
                    y: 0,
                    opacity: 1,
                    delay: .15
                }, "-=0.5"), n.addLabel("end")
            },
            createSecondaryTimeline(n) {
                const {
                    title: e,
                    desc: t,
                    link: i
                } = this.$refs;
                Po(n, [{
                    elem: e
                }, {
                    elem: t,
                    delay: .2
                }, {
                    elem: i,
                    delay: .2
                }])
            }
        }
    },
    qz = {
        class: "section-main-collection"
    },
    $z = {
        class: "section-main-collection__container container"
    },
    jz = {
        class: "section-main-collection__content"
    },
    Yz = {
        class: "section-main-collection__main"
    },
    Xz = {
        ref: "title",
        class: "section-main-collection__title center"
    },
    Kz = {
        ref: "desc",
        class: "section-main-collection__desc center font-fira-code"
    },
    Jz = {
        ref: "link",
        href: "https://app.mintlabz.io/minting/ai-doggos",
        target: "_blank",
        class: "section-main-collection__link g-button g-button--default"
    },
    Zz = {
        class: "icon-wrap"
    },
    eG = {
        class: "section-main-collection__list-wrapper"
    },
    tG = ["breakpoints", "injectStyles"],
    iG = {
        class: "section-main-collection__item-wrapper"
    },
    nG = {
        class: "section-main-collection__item-image"
    },
    sG = ["src", "alt"],
    rG = {
        class: "section-main-collection__item-body"
    },
    oG = {
        class: "section-main-collection__item-info font-fira-code"
    },
    aG = {
        class: "section-main-collection__item-title"
    };

function lG(n, e, t, i, s, r) {
    const o = Mt("g-arrow-down-right"),
        a = Mt("g-layout-section");
    return Ge(), yn(a, {
        id: "collection-gallery",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", qz, [ie("div", $z, [ie("div", jz, [ie("div", Yz, [ie("h2", Xz, "AI Doggos", 512), ie("p", Kz, " Introducing AI Doggos! A playful and unique PFP collection where adorable canines meet cutting-edge technology. These AI-powered pups exist across multiple blockchains, ready to be your loyal companions in the digital world. AI Doggos aren't just about the art – they're a key to a vibrant community. 100% of funds collected by Any Inu will go towards CEX listings and marketing. ", 512), ie("a", Jz, [bo(" See all "), ie("span", Zz, [gt(o)])], 512)]), ie("div", eG, [ie("swiper-container", {
            "space-between": 20,
            breakpoints: r.sliderBreakpoints,
            injectStyles: [".swiper {overflow: visible;}"],
            "slides-per-view": "auto",
            class: "section-main-collection__list"
        }, [(Ge(!0), st(Bt, null, xn(r.filteredCollection, (l, c) => (Ge(), st("swiper-slide", {
            ref_for: !0,
            ref: "items",
            key: c,
            class: "section-main-collection__item"
        }, [ie("div", iG, [ie("div", nG, [ie("img", {
            src: `/images/collections/${c + 1}.jpg`,
            alt: l.title
        }, null, 8, sG)]), ie("div", rG, [ie("p", oG, Pi(l.info), 1), ie("h3", aG, Pi(l.title), 1)])])]))), 128))], 8, tG)])])])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const cG = ki(Wz, [
    ["render", lG]
]),
    uG = {
        name: "SectionCollection",
        mixins: [Tr],
        data: () => ({
            collection: FC.test
        }),
        computed: {
            ...fs(gn, ["breakpoints"]),
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        pin: !0,
                        markers: !1,
                        scrub: !0,
                        snap: "labelsDirectional",
                        end: this.calculateEndSection,
                        onEnter: this.setCurrentSection,
                        onEnterBack: this.setCurrentSection
                    },
                    media: {
                        isDesktop: `(min-width: ${this.breakpoints.md + .5}px)`
                    },
                    callback: this.createMainTimeline
                }, {
                    scrollTrigger: {
                        markers: !1,
                        start: "top top"
                    },
                    media: {
                        isDesktop: `(min-width: ${this.breakpoints.md + .5}px)`
                    },
                    callback: this.createSecondaryTimeline
                }, {
                    scrollTrigger: {
                        markers: !1,
                        start: "top-=200 top"
                    },
                    media: {
                        isMobile: `(max-width: ${this.breakpoints.md}px)`
                    },
                    callback: this.createSecondaryTimeline
                }]
            },
            sliderBreakpoints() {
                return {
                    [this.breakpoints.md + .5]: {
                        direction: "vertical",
                        spaceBetween: 50,
                        allowTouchMove: !1
                    },
                    [this.breakpoints.xl + .5]: {
                        direction: "vertical",
                        spaceBetween: 70,
                        allowTouchMove: !1
                    }
                }
            }
        },
        methods: {
            createMainTimeline(n) {
                n.addLabel("begin"), this.collection.forEach((e, t) => {
                    n.add(() => {
                        var i;
                        (i = this.$refs.swiperEl.swiper) == null || i.slideTo(t)
                    }, "+=1").addLabel(`slide_${t}`)
                }), n.addLabel("end")
            },
            createSecondaryTimeline(n) {
                const {
                    title: e,
                    desc: t,
                    link: i
                } = this.$refs;
                Po(n, [{
                    elem: e
                }, {
                    elem: t,
                    delay: .2
                }, {
                    elem: i,
                    delay: .2
                }])
            },
            calculateEndSection() {
                const {
                    items: n,
                    body: e
                } = this.$refs, t = e.offsetHeight, i = n.reduce((s, r) => s += r.offsetHeight / 2, 0);
                return `+=${t + i}`
            }
        }
    },
    dG = {
        ref: "body",
        class: "section-collection"
    },
    hG = {
        class: "section-collection__container container"
    },
    fG = {
        class: "section-collection__content"
    },
    pG = {
        class: "section-collection__main"
    },
    mG = {
        ref: "title",
        class: "section-collection__title"
    },
    gG = {
        ref: "desc",
        class: "section-collection__desc font-fira-code"
    },
    AG = {
        ref: "link",
        href: "https://opensea.io/collection/dognexus404",
        class: "section-collection__link g-button g-button--default"
    },
    _G = {
        class: "icon-wrap"
    },
    vG = {
        class: "section-collection__list-wrapper"
    },
    bG = ["breakpoints"],
    xG = {
        class: "section-collection__item-image"
    },
    yG = ["src", "alt"];

function EG(n, e, t, i, s, r) {
    const o = Mt("g-arrow-down-right"),
        a = Mt("g-layout-section");
    return Ge(), yn(a, {
        id: "collection",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", dG, [ie("div", hG, [ie("div", fG, [ie("div", pG, [ie("h2", mG, "DogNexus 404", 512), ie("p", gG, " The first gas efficient erc20 + erc721 hybrid token. A house for your doggo or your coins. ", 512), ie("a", AG, [bo(" See all "), ie("span", _G, [gt(o)])], 512)]), ie("div", vG, [ie("swiper-container", {
            ref: "swiperEl",
            centeredSlides: !0,
            "space-between": 50,
            breakpoints: r.sliderBreakpoints,
            "slides-per-view": "auto",
            class: "section-collection__list"
        }, [(Ge(!0), st(Bt, null, xn(n.collection, (l, c) => (Ge(), st("swiper-slide", {
            ref_for: !0,
            ref: "items",
            key: c,
            class: "swiper-slide section-collection__item"
        }, [ie("div", xG, [ie("img", {
            src: `/images/collections/dognexus_404/${c + 1}.jpg`,
            alt: l.title
        }, null, 8, yG)])]))), 128))], 8, bG)])])])], 512)]),
        _: 1
    }, 8, ["timelines-options"])
}
const wG = ki(uG, [
    ["render", EG]
]),
    CG = [{
        title: "What is Any Inu?",
        content: "Any Inu is the most multichain dog on 17+ chains and 13+ DEXs. An Inclusive token for dog lovers that welcomes ANYone from ANY chain. Artificial Intelligence is at the heart of the Any Inu community. $AI is love '爱'"
    }, {
        title: "How was Any Inu launched? What are Any Inu’s tokenomics?",
        content: "There is a 420,690,000,000 fixed supply of tokens initially split across 15 chains. 414,690,000,000 tokens were initially added to liquidity on 9 chains at the same time. 6,000,000 was reserved for CEX liquidity and onchain LP incentives. There is no tax. There were no presales or whitelists. AnyToshi and all community members running socials and building for Any Inu bought tokens from the LP on their own accord. All initial LP is burnt or locked for a hundred years."
    }, {
        title: "Who are the devs? What makes it a community coin and how can I get involved?",
        content: 'AnyToshi setup the token, communities, and initial LPs. We encourage you the read their <a href="https://twitter.com/AnyInuCoin/status/1743185397318816126" target="_blank">first memo to the community here</a>. Reach out on twitter, tg, discord, at <a href="mailto:anyinucoin@gmail.com">anyinucoin@gmail.com</a>, or in-person at the dog park.'
    }, {
        title: "How does Any Inu Work?",
        content: "Axelar's Interchain token service powers the seamless bridging of $AI. The total token supply always remains fixed as chains are added and tokens are bridged. Additional chains are supported using permissionless bridge providers. These other bridges can be setup by ANYone by wrapping $AI on an Axelar ITS supported chain."
    }, {
        title: "Why do some tools incorrectly give warnings about Bridgeable tokens?",
        content: "There is no token owner. The token is only mintable by the Axelar ITS bridge. The ITS bridge burns tokens on the source chain and mints an equal amount on the destination chain when a bridging transaction happens. Wormhole works similarly, but instead of burning, wraps tokens on the source chain."
    }, {
        title: "Where can I contribute to community outreach efforts?",
        content: 'Your time and skills are always appreciated. If you think you could contribute to $AI, then reach out to any of the mods or contact social owners directly. The community has set up a <a href="https://app.safe.global/home?safe=bnb:0x64788B63fdD109225a38D4199C399640b7d8C491" target="_blank">6 person multisig on BSC</a> to safely pool funds for things like content creation, giveaways, web hosting, and outreach associated expenses. The address is <a href="https://bscscan.com/address/0x64788B63fdD109225a38D4199C399640b7d8C491" target="_blank">bnb:0x64788B63fdD109225a38D4199C399640b7d8C491</a>'
    }],
    SG = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M10%203.75V16.25M16.25%2010L3.75%2010'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e",
    MG = {
        name: "SectionFAQ",
        mixins: [Tr],
        data: () => ({
            list: CG,
            activeIndexItem: -1,
            accordionList: []
        }),
        computed: {
            ...fs(gn, ["breakpoints", "activeBreakpoint"]),
            timelinesOptions() {
                return [{
                    scrollTrigger: {
                        markers: !1,
                        start: "top-=200 top"
                    },
                    callback: this.createTimeline
                }]
            }
        },
        mounted() {
            this.$nextTick(() => {
                var n;
                this.accordionList = ((n = this.$refs) == null ? void 0 : n.accordionList) || []
            })
        },
        methods: {
            createTimeline(n) {
                const {
                    title: e,
                    items: t
                } = this.$refs;
                Po(n, [{
                    elem: e
                }, ...t.map((i, s) => ({
                    elem: i,
                    delay: (s + 1) * .1
                }))])
            },
            toggleAccordion(n) {
                const e = this.accordionList[this.activeIndexItem],
                    t = this.accordionList[n];
                e && (e.style.maxHeight = "0px"), t && (this.activeIndexItem === n ? this.activeIndexItem = -1 : (this.activeIndexItem = n, t.style.maxHeight = `${t.scrollHeight}px`))
            }
        }
    },
    TG = {
        class: "section-faq"
    },
    IG = {
        class: "container"
    },
    BG = {
        class: "section-faq__content"
    },
    RG = {
        class: "section-faq__header"
    },
    PG = {
        class: "section-faq__header-title",
        ref: "title"
    },
    DG = {
        class: "section-faq__list"
    },
    LG = ["onClick"],
    kG = {
        class: "section-faq__item-number font-fira-code"
    },
    FG = {
        class: "section-faq__item-title"
    },
    NG = ie("img", {
        class: "section-faq__item-icon",
        src: SG,
        alt: "plus"
    }, null, -1),
    OG = ["innerHTML"];

function UG(n, e, t, i, s, r) {
    const o = Mt("g-layout-section");
    return Ge(), yn(o, {
        id: "faq",
        "timelines-options": r.timelinesOptions
    }, {
        default: Ts(() => [ie("div", TG, [ie("div", IG, [ie("div", BG, [ie("div", RG, [ie("h2", PG, " Fetching Answers to Bark Worthy Questions - The Any Inu FAQ Pack! ", 512)]), ie("div", DG, [(Ge(!0), st(Bt, null, xn(n.list, (a, l) => (Ge(), st("div", {
            ref_for: !0,
            ref: "items",
            class: xr(["section-faq__item", {
                active: l === n.activeIndexItem
            }]),
            key: l
        }, [ie("div", {
            class: "section-faq__item-header",
            onClick: c => r.toggleAccordion(l)
        }, [ie("div", kG, " //" + Pi((l + 1).toString().padStart(2, "0")), 1), ie("h4", FG, Pi(a.title), 1), NG], 8, LG), ie("p", {
            ref_for: !0,
            ref: "accordionList",
            class: "section-faq__item-desc font-fira-code",
            innerHTML: a.content
        }, null, 8, OG)], 2))), 128))])])])])]),
        _: 1
    }, 8, ["timelines-options"])
}
const QG = ki(MG, [
    ["render", UG]
]);
/*!
 * CustomEase 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var bn, NC, OC = function () {
    return bn || typeof window < "u" && (bn = window.gsap) && bn.registerPlugin && bn
},
    ax = function () {
        bn = OC(), bn ? (bn.registerEase("_CE", $f.create), NC = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
    },
    zG = 1e20,
    Kd = function (e) {
        return ~~(e * 1e3 + (e < 0 ? -.5 : .5)) / 1e3
    },
    GG = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi,
    HG = /[cLlsSaAhHvVtTqQ]/g,
    VG = function (e) {
        var t = e.length,
            i = zG,
            s;
        for (s = 1; s < t; s += 6) + e[s] < i && (i = +e[s]);
        return i
    },
    WG = function (e, t, i) {
        !i && i !== 0 && (i = Math.max(+e[e.length - 1], +e[1]));
        var s = +e[0] * -1,
            r = -i,
            o = e.length,
            a = 1 / (+e[o - 2] + s),
            l = -t || (Math.abs(+e[o - 1] - +e[1]) < .01 * (+e[o - 2] - +e[0]) ? VG(e) + r : +e[o - 1] + r),
            c;
        for (l ? l = 1 / l : l = -a, c = 0; c < o; c += 2) e[c] = (+e[c] + s) * a, e[c + 1] = (+e[c + 1] + r) * l
    },
    qG = function n(e, t, i, s, r, o, a, l, c, u, d) {
        var h = (e + i) / 2,
            f = (t + s) / 2,
            m = (i + r) / 2,
            g = (s + o) / 2,
            A = (r + a) / 2,
            p = (o + l) / 2,
            v = (h + m) / 2,
            _ = (f + g) / 2,
            b = (m + A) / 2,
            w = (g + p) / 2,
            E = (v + b) / 2,
            C = (_ + w) / 2,
            S = a - e,
            x = l - t,
            y = Math.abs((i - a) * x - (s - l) * S),
            P = Math.abs((r - a) * x - (o - l) * S),
            T;
        return u || (u = [{
            x: e,
            y: t
        }, {
            x: a,
            y: l
        }], d = 1), u.splice(d || u.length - 1, 0, {
            x: E,
            y: C
        }), (y + P) * (y + P) > c * (S * S + x * x) && (T = u.length, n(e, t, h, f, v, _, E, C, c, u, d), n(E, C, b, w, A, p, a, l, c, u, d + 1 + (u.length - T))), u
    },
    $f = function () {
        function n(t, i, s) {
            NC || ax(), this.id = t, this.setData(i, s)
        }
        var e = n.prototype;
        return e.setData = function (i, s) {
            s = s || {}, i = i || "0,0,1,1";
            var r = i.match(GG),
                o = 1,
                a = [],
                l = [],
                c = s.precision || 1,
                u = c <= 1,
                d, h, f, m, g, A, p, v, _;
            if (this.data = i, (HG.test(i) || ~i.indexOf("M") && i.indexOf("C") < 0) && (r = Lu(i)[0]), d = r.length, d === 4) r.unshift(0, 0), r.push(1, 1), d = 8;
            else if ((d - 2) % 6) throw "Invalid CustomEase";
            for ((+r[0] != 0 || +r[d - 2] != 1) && WG(r, s.height, s.originY), this.segment = r, m = 2; m < d; m += 6) h = {
                x: +r[m - 2],
                y: +r[m - 1]
            }, f = {
                x: +r[m + 4],
                y: +r[m + 5]
            }, a.push(h, f), qG(h.x, h.y, +r[m], +r[m + 1], +r[m + 2], +r[m + 3], f.x, f.y, 1 / (c * 2e5), a, a.length - 1);
            for (d = a.length, m = 0; m < d; m++) p = a[m], v = a[m - 1] || p, (p.x > v.x || v.y !== p.y && v.x === p.x || p === v) && p.x <= 1 ? (v.cx = p.x - v.x, v.cy = p.y - v.y, v.n = p, v.nx = p.x, u && m > 1 && Math.abs(v.cy / v.cx - a[m - 2].cy / a[m - 2].cx) > 2 && (u = 0), v.cx < o && (v.cx ? o = v.cx : (v.cx = .001, m === d - 1 && (v.x -= .001, o = Math.min(o, .001), u = 0)))) : (a.splice(m--, 1), d--);
            if (d = 1 / o + 1 | 0, g = 1 / d, A = 0, p = a[0], u) {
                for (m = 0; m < d; m++) _ = m * g, p.nx < _ && (p = a[++A]), h = p.y + (_ - p.x) / p.cx * p.cy, l[m] = {
                    x: _,
                    cx: g,
                    y: h,
                    cy: 0,
                    nx: 9
                }, m && (l[m - 1].cy = h - l[m - 1].y);
                l[d - 1].cy = a[a.length - 1].y - h
            } else {
                for (m = 0; m < d; m++) p.nx < m * g && (p = a[++A]), l[m] = p;
                A < a.length - 1 && (l[m - 1] = a[a.length - 2])
            }
            return this.ease = function (b) {
                var w = l[b * d | 0] || l[d - 1];
                return w.nx < b && (w = w.n), w.y + (b - w.x) / w.cx * w.cy
            }, this.ease.custom = this, this.id && bn && bn.registerEase(this.id, this.ease), this
        }, e.getSVGData = function (i) {
            return n.getSVGData(this, i)
        }, n.create = function (i, s, r) {
            return new n(i, s, r).ease
        }, n.register = function (i) {
            bn = i, ax()
        }, n.get = function (i) {
            return bn.parseEase(i)
        }, n.getSVGData = function (i, s) {
            s = s || {};
            var r = s.width || 100,
                o = s.height || 100,
                a = s.x || 0,
                l = (s.y || 0) + o,
                c = bn.utils.toArray(s.path)[0],
                u, d, h, f, m, g, A, p, v, _;
            if (s.invert && (o = -o, l = 0), typeof i == "string" && (i = bn.parseEase(i)), i.custom && (i = i.custom), i instanceof n) u = E0(_l([i.segment], r, 0, 0, -o, a, l));
            else {
                for (u = [a, l], A = Math.max(5, (s.precision || 1) * 200), f = 1 / A, A += 2, p = 5 / A, v = Kd(a + f * r), _ = Kd(l + i(f) * -o), d = (_ - l) / (v - a), h = 2; h < A; h++) m = Kd(a + h * f * r), g = Kd(l + i(h * f) * -o), (Math.abs((g - _) / (m - v) - d) > p || h === A - 1) && (u.push(v, _), d = (g - _) / (m - v)), v = m, _ = g;
                u = "M" + u.join(",")
            }
            return c && c.setAttribute("d", u), u
        }, n
    }();
OC() && bn.registerPlugin($f);
$f.version = "3.12.5";

function lx(n, e) {
    for (var t = 0; t < e.length; t++) {
        var i = e[t];
        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i)
    }
}

function $G(n, e, t) {
    return e && lx(n.prototype, e), t && lx(n, t), n
}
/*!
 * Observer 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Ui, Bh, zn, lo, co, Ll, UC, Ko, iu, QC, gr, As, zC, GC = function () {
    return Ui || typeof window < "u" && (Ui = window.gsap) && Ui.registerPlugin && Ui
},
    HC = 1,
    bl = [],
    ut = [],
    Vs = [],
    nu = Date.now,
    Xg = function (e, t) {
        return t
    },
    jG = function () {
        var e = iu.core,
            t = e.bridge || {},
            i = e._scrollers,
            s = e._proxies;
        i.push.apply(i, ut), s.push.apply(s, Vs), ut = i, Vs = s, Xg = function (o, a) {
            return t[o](a)
        }
    },
    go = function (e, t) {
        return ~Vs.indexOf(e) && Vs[Vs.indexOf(e) + 1][t]
    },
    su = function (e) {
        return !!~QC.indexOf(e)
    },
    sn = function (e, t, i, s, r) {
        return e.addEventListener(t, i, {
            passive: s !== !1,
            capture: !!r
        })
    },
    tn = function (e, t, i, s) {
        return e.removeEventListener(t, i, !!s)
    },
    Jd = "scrollLeft",
    Zd = "scrollTop",
    Kg = function () {
        return gr && gr.isPressed || ut.cache++
    },
    pf = function (e, t) {
        var i = function s(r) {
            if (r || r === 0) {
                HC && (zn.history.scrollRestoration = "manual");
                var o = gr && gr.isPressed;
                r = s.v = Math.round(r) || (gr && gr.iOS ? 1 : 0), e(r), s.cacheID = ut.cache, o && Xg("ss", r)
            } else (t || ut.cache !== s.cacheID || Xg("ref")) && (s.cacheID = ut.cache, s.v = e());
            return s.v + s.offset
        };
        return i.offset = 0, e && i
    },
    dn = {
        s: Jd,
        p: "left",
        p2: "Left",
        os: "right",
        os2: "Right",
        d: "width",
        d2: "Width",
        a: "x",
        sc: pf(function (n) {
            return arguments.length ? zn.scrollTo(n, bi.sc()) : zn.pageXOffset || lo[Jd] || co[Jd] || Ll[Jd] || 0
        })
    },
    bi = {
        s: Zd,
        p: "top",
        p2: "Top",
        os: "bottom",
        os2: "Bottom",
        d: "height",
        d2: "Height",
        a: "y",
        op: dn,
        sc: pf(function (n) {
            return arguments.length ? zn.scrollTo(dn.sc(), n) : zn.pageYOffset || lo[Zd] || co[Zd] || Ll[Zd] || 0
        })
    },
    vn = function (e, t) {
        return (t && t._ctx && t._ctx.selector || Ui.utils.toArray)(e)[0] || (typeof e == "string" && Ui.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
    },
    Co = function (e, t) {
        var i = t.s,
            s = t.sc;
        su(e) && (e = lo.scrollingElement || co);
        var r = ut.indexOf(e),
            o = s === bi.sc ? 1 : 2;
        !~r && (r = ut.push(e) - 1), ut[r + o] || sn(e, "scroll", Kg);
        var a = ut[r + o],
            l = a || (ut[r + o] = pf(go(e, i), !0) || (su(e) ? s : pf(function (c) {
                return arguments.length ? e[i] = c : e[i]
            })));
        return l.target = e, a || (l.smooth = Ui.getProperty(e, "scrollBehavior") === "smooth"), l
    },
    Jg = function (e, t, i) {
        var s = e,
            r = e,
            o = nu(),
            a = o,
            l = t || 50,
            c = Math.max(500, l * 3),
            u = function (m, g) {
                var A = nu();
                g || A - o > l ? (r = s, s = m, a = o, o = A) : i ? s += m : s = r + (m - r) / (A - a) * (o - a)
            },
            d = function () {
                r = s = i ? 0 : s, a = o = 0
            },
            h = function (m) {
                var g = a,
                    A = r,
                    p = nu();
                return (m || m === 0) && m !== s && u(m), o === a || p - a > c ? 0 : (s + (i ? A : -A)) / ((i ? p : o) - g) * 1e3
            };
        return {
            update: u,
            reset: d,
            getVelocity: h
        }
    },
    Ec = function (e, t) {
        return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
    },
    cx = function (e) {
        var t = Math.max.apply(Math, e),
            i = Math.min.apply(Math, e);
        return Math.abs(t) >= Math.abs(i) ? t : i
    },
    VC = function () {
        iu = Ui.core.globals().ScrollTrigger, iu && iu.core && jG()
    },
    WC = function (e) {
        return Ui = e || GC(), !Bh && Ui && typeof document < "u" && document.body && (zn = window, lo = document, co = lo.documentElement, Ll = lo.body, QC = [zn, lo, co, Ll], Ui.utils.clamp, zC = Ui.core.context || function () { }, Ko = "onpointerenter" in Ll ? "pointer" : "mouse", UC = ri.isTouch = zn.matchMedia && zn.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in zn || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, As = ri.eventTypes = ("ontouchstart" in co ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in co ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () {
            return HC = 0
        }, 500), VC(), Bh = 1), Bh
    };
dn.op = bi;
ut.cache = 0;
var ri = function () {
    function n(t) {
        this.init(t)
    }
    var e = n.prototype;
    return e.init = function (i) {
        Bh || WC(Ui) || console.warn("Please gsap.registerPlugin(Observer)"), iu || VC();
        var s = i.tolerance,
            r = i.dragMinimum,
            o = i.type,
            a = i.target,
            l = i.lineHeight,
            c = i.debounce,
            u = i.preventDefault,
            d = i.onStop,
            h = i.onStopDelay,
            f = i.ignore,
            m = i.wheelSpeed,
            g = i.event,
            A = i.onDragStart,
            p = i.onDragEnd,
            v = i.onDrag,
            _ = i.onPress,
            b = i.onRelease,
            w = i.onRight,
            E = i.onLeft,
            C = i.onUp,
            S = i.onDown,
            x = i.onChangeX,
            y = i.onChangeY,
            P = i.onChange,
            T = i.onToggleX,
            R = i.onToggleY,
            D = i.onHover,
            U = i.onHoverEnd,
            Q = i.onMove,
            F = i.ignoreCheck,
            L = i.isNormalizer,
            W = i.onGestureStart,
            k = i.onGestureEnd,
            $ = i.onWheel,
            X = i.onEnable,
            le = i.onDisable,
            K = i.onClick,
            te = i.scrollSpeed,
            ue = i.capture,
            fe = i.allowClicks,
            Me = i.lockAxis,
            Be = i.onLockAxis;
        this.target = a = vn(a) || co, this.vars = i, f && (f = Ui.utils.toArray(f)), s = s || 1e-9, r = r || 0, m = m || 1, te = te || 1, o = o || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat(zn.getComputedStyle(Ll).lineHeight) || 22);
        var Ce, Z, ke, N, G, Y, se, M = this,
            I = 0,
            H = 0,
            V = i.passive || !u,
            j = Co(a, dn),
            q = Co(a, bi),
            he = j(),
            re = q(),
            de = ~o.indexOf("touch") && !~o.indexOf("pointer") && As[0] === "pointerdown",
            ge = su(a),
            ce = a.ownerDocument || lo,
            me = [0, 0, 0],
            xe = [0, 0, 0],
            ve = 0,
            we = function () {
                return ve = nu()
            },
            Pe = function (De, it) {
                return (M.event = De) && f && ~f.indexOf(De.target) || it && de && De.pointerType !== "touch" || F && F(De, it)
            },
            Ke = function () {
                M._vx.reset(), M._vy.reset(), Z.pause(), d && d(M)
            },
            Ve = function () {
                var De = M.deltaX = cx(me),
                    it = M.deltaY = cx(xe),
                    Ee = Math.abs(De) >= s,
                    $e = Math.abs(it) >= s;
                P && (Ee || $e) && P(M, De, it, me, xe), Ee && (w && M.deltaX > 0 && w(M), E && M.deltaX < 0 && E(M), x && x(M), T && M.deltaX < 0 != I < 0 && T(M), I = M.deltaX, me[0] = me[1] = me[2] = 0), $e && (S && M.deltaY > 0 && S(M), C && M.deltaY < 0 && C(M), y && y(M), R && M.deltaY < 0 != H < 0 && R(M), H = M.deltaY, xe[0] = xe[1] = xe[2] = 0), (N || ke) && (Q && Q(M), ke && (v(M), ke = !1), N = !1), Y && !(Y = !1) && Be && Be(M), G && ($(M), G = !1), Ce = 0
            },
            Le = function (De, it, Ee) {
                me[Ee] += De, xe[Ee] += it, M._vx.update(De), M._vy.update(it), c ? Ce || (Ce = requestAnimationFrame(Ve)) : Ve()
            },
            We = function (De, it) {
                Me && !se && (M.axis = se = Math.abs(De) > Math.abs(it) ? "x" : "y", Y = !0), se !== "y" && (me[2] += De, M._vx.update(De, !0)), se !== "x" && (xe[2] += it, M._vy.update(it, !0)), c ? Ce || (Ce = requestAnimationFrame(Ve)) : Ve()
            },
            Te = function (De) {
                if (!Pe(De, 1)) {
                    De = Ec(De, u);
                    var it = De.clientX,
                        Ee = De.clientY,
                        $e = it - M.x,
                        Qe = Ee - M.y,
                        je = M.isDragging;
                    M.x = it, M.y = Ee, (je || Math.abs(M.startX - it) >= r || Math.abs(M.startY - Ee) >= r) && (v && (ke = !0), je || (M.isDragging = !0), We($e, Qe), je || A && A(M))
                }
            },
            B = M.onPress = function (Ne) {
                Pe(Ne, 1) || Ne && Ne.button || (M.axis = se = null, Z.pause(), M.isPressed = !0, Ne = Ec(Ne), I = H = 0, M.startX = M.x = Ne.clientX, M.startY = M.y = Ne.clientY, M._vx.reset(), M._vy.reset(), sn(L ? a : ce, As[1], Te, V, !0), M.deltaX = M.deltaY = 0, _ && _(M))
            },
            ee = M.onRelease = function (Ne) {
                if (!Pe(Ne, 1)) {
                    tn(L ? a : ce, As[1], Te, !0);
                    var De = !isNaN(M.y - M.startY),
                        it = M.isDragging,
                        Ee = it && (Math.abs(M.x - M.startX) > 3 || Math.abs(M.y - M.startY) > 3),
                        $e = Ec(Ne);
                    !Ee && De && (M._vx.reset(), M._vy.reset(), u && fe && Ui.delayedCall(.08, function () {
                        if (nu() - ve > 300 && !Ne.defaultPrevented) {
                            if (Ne.target.click) Ne.target.click();
                            else if (ce.createEvent) {
                                var Qe = ce.createEvent("MouseEvents");
                                Qe.initMouseEvent("click", !0, !0, zn, 1, $e.screenX, $e.screenY, $e.clientX, $e.clientY, !1, !1, !1, !1, 0, null), Ne.target.dispatchEvent(Qe)
                            }
                        }
                    })), M.isDragging = M.isGesturing = M.isPressed = !1, d && it && !L && Z.restart(!0), p && it && p(M), b && b(M, Ee)
                }
            },
            pe = function (De) {
                return De.touches && De.touches.length > 1 && (M.isGesturing = !0) && W(De, M.isDragging)
            },
            be = function () {
                return (M.isGesturing = !1) || k(M)
            },
            Se = function (De) {
                if (!Pe(De)) {
                    var it = j(),
                        Ee = q();
                    Le((it - he) * te, (Ee - re) * te, 1), he = it, re = Ee, d && Z.restart(!0)
                }
            },
            et = function (De) {
                if (!Pe(De)) {
                    De = Ec(De, u), $ && (G = !0);
                    var it = (De.deltaMode === 1 ? l : De.deltaMode === 2 ? zn.innerHeight : 1) * m;
                    Le(De.deltaX * it, De.deltaY * it, 0), d && !L && Z.restart(!0)
                }
            },
            tt = function (De) {
                if (!Pe(De)) {
                    var it = De.clientX,
                        Ee = De.clientY,
                        $e = it - M.x,
                        Qe = Ee - M.y;
                    M.x = it, M.y = Ee, N = !0, d && Z.restart(!0), ($e || Qe) && We($e, Qe)
                }
            },
            xt = function (De) {
                M.event = De, D(M)
            },
            Tt = function (De) {
                M.event = De, U(M)
            },
            mt = function (De) {
                return Pe(De) || Ec(De, u) && K(M)
            };
        Z = M._dc = Ui.delayedCall(h || .25, Ke).pause(), M.deltaX = M.deltaY = 0, M._vx = Jg(0, 50, !0), M._vy = Jg(0, 50, !0), M.scrollX = j, M.scrollY = q, M.isDragging = M.isGesturing = M.isPressed = !1, zC(this), M.enable = function (Ne) {
            return M.isEnabled || (sn(ge ? ce : a, "scroll", Kg), o.indexOf("scroll") >= 0 && sn(ge ? ce : a, "scroll", Se, V, ue), o.indexOf("wheel") >= 0 && sn(a, "wheel", et, V, ue), (o.indexOf("touch") >= 0 && UC || o.indexOf("pointer") >= 0) && (sn(a, As[0], B, V, ue), sn(ce, As[2], ee), sn(ce, As[3], ee), fe && sn(a, "click", we, !0, !0), K && sn(a, "click", mt), W && sn(ce, "gesturestart", pe), k && sn(ce, "gestureend", be), D && sn(a, Ko + "enter", xt), U && sn(a, Ko + "leave", Tt), Q && sn(a, Ko + "move", tt)), M.isEnabled = !0, Ne && Ne.type && B(Ne), X && X(M)), M
        }, M.disable = function () {
            M.isEnabled && (bl.filter(function (Ne) {
                return Ne !== M && su(Ne.target)
            }).length || tn(ge ? ce : a, "scroll", Kg), M.isPressed && (M._vx.reset(), M._vy.reset(), tn(L ? a : ce, As[1], Te, !0)), tn(ge ? ce : a, "scroll", Se, ue), tn(a, "wheel", et, ue), tn(a, As[0], B, ue), tn(ce, As[2], ee), tn(ce, As[3], ee), tn(a, "click", we, !0), tn(a, "click", mt), tn(ce, "gesturestart", pe), tn(ce, "gestureend", be), tn(a, Ko + "enter", xt), tn(a, Ko + "leave", Tt), tn(a, Ko + "move", tt), M.isEnabled = M.isPressed = M.isDragging = !1, le && le(M))
        }, M.kill = M.revert = function () {
            M.disable();
            var Ne = bl.indexOf(M);
            Ne >= 0 && bl.splice(Ne, 1), gr === M && (gr = 0)
        }, bl.push(M), L && su(a) && (gr = M), M.enable(g)
    }, $G(n, [{
        key: "velocityX",
        get: function () {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function () {
            return this._vy.getVelocity()
        }
    }]), n
}();
ri.version = "3.12.5";
ri.create = function (n) {
    return new ri(n)
};
ri.register = WC;
ri.getAll = function () {
    return bl.slice()
};
ri.getById = function (n) {
    return bl.filter(function (e) {
        return e.vars.id === n
    })[0]
};
GC() && Ui.registerPlugin(ri);
/*!
 * ScrollTrigger 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Fe, al, ft, $t, _s, Ot, qC, mf, Fu, ru, Dc, eh, $i, jf, Zg, an, ux, dx, ll, $C, ym, jC, on, eA, YC, XC, zr, tA, S0, kl, M0, gf, iA, Em, th = 1,
    ji = Date.now,
    wm = ji(),
    ds = 0,
    Lc = 0,
    hx = function (e, t, i) {
        var s = Fn(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
        return i["_" + t + "Clamp"] = s, s ? e.substr(6, e.length - 7) : e
    },
    fx = function (e, t) {
        return t && (!Fn(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
    },
    YG = function n() {
        return Lc && requestAnimationFrame(n)
    },
    px = function () {
        return jf = 1
    },
    mx = function () {
        return jf = 0
    },
    Rs = function (e) {
        return e
    },
    kc = function (e) {
        return Math.round(e * 1e5) / 1e5 || 0
    },
    KC = function () {
        return typeof window < "u"
    },
    JC = function () {
        return Fe || KC() && (Fe = window.gsap) && Fe.registerPlugin && Fe
    },
    Ca = function (e) {
        return !!~qC.indexOf(e)
    },
    ZC = function (e) {
        return (e === "Height" ? M0 : ft["inner" + e]) || _s["client" + e] || Ot["client" + e]
    },
    eS = function (e) {
        return go(e, "getBoundingClientRect") || (Ca(e) ? function () {
            return kh.width = ft.innerWidth, kh.height = M0, kh
        } : function () {
            return dr(e)
        })
    },
    XG = function (e, t, i) {
        var s = i.d,
            r = i.d2,
            o = i.a;
        return (o = go(e, "getBoundingClientRect")) ? function () {
            return o()[s]
        } : function () {
            return (t ? ZC(r) : e["client" + r]) || 0
        }
    },
    KG = function (e, t) {
        return !t || ~Vs.indexOf(e) ? eS(e) : function () {
            return kh
        }
    },
    Qs = function (e, t) {
        var i = t.s,
            s = t.d2,
            r = t.d,
            o = t.a;
        return Math.max(0, (i = "scroll" + s) && (o = go(e, i)) ? o() - eS(e)()[r] : Ca(e) ? (_s[i] || Ot[i]) - ZC(s) : e[i] - e["offset" + s])
    },
    ih = function (e, t) {
        for (var i = 0; i < ll.length; i += 3)(!t || ~t.indexOf(ll[i + 1])) && e(ll[i], ll[i + 1], ll[i + 2])
    },
    Fn = function (e) {
        return typeof e == "string"
    },
    hn = function (e) {
        return typeof e == "function"
    },
    Fc = function (e) {
        return typeof e == "number"
    },
    Jo = function (e) {
        return typeof e == "object"
    },
    wc = function (e, t, i) {
        return e && e.progress(t ? 0 : 1) && i && e.pause()
    },
    Cm = function (e, t) {
        if (e.enabled) {
            var i = e._ctx ? e._ctx.add(function () {
                return t(e)
            }) : t(e);
            i && i.totalTime && (e.callbackAnimation = i)
        }
    },
    sl = Math.abs,
    tS = "left",
    iS = "top",
    T0 = "right",
    I0 = "bottom",
    ga = "width",
    Aa = "height",
    ou = "Right",
    au = "Left",
    lu = "Top",
    cu = "Bottom",
    ui = "padding",
    ts = "margin",
    Kl = "Width",
    B0 = "Height",
    _i = "px",
    is = function (e) {
        return ft.getComputedStyle(e)
    },
    JG = function (e) {
        var t = is(e).position;
        e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
    },
    gx = function (e, t) {
        for (var i in t) i in e || (e[i] = t[i]);
        return e
    },
    dr = function (e, t) {
        var i = t && is(e)[Zg] !== "matrix(1, 0, 0, 1, 0, 0)" && Fe.to(e, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0
        }).progress(1),
            s = e.getBoundingClientRect();
        return i && i.progress(0).kill(), s
    },
    Af = function (e, t) {
        var i = t.d2;
        return e["offset" + i] || e["client" + i] || 0
    },
    nS = function (e) {
        var t = [],
            i = e.labels,
            s = e.duration(),
            r;
        for (r in i) t.push(i[r] / s);
        return t
    },
    ZG = function (e) {
        return function (t) {
            return Fe.utils.snap(nS(e), t)
        }
    },
    R0 = function (e) {
        var t = Fe.utils.snap(e),
            i = Array.isArray(e) && e.slice(0).sort(function (s, r) {
                return s - r
            });
        return i ? function (s, r, o) {
            o === void 0 && (o = .001);
            var a;
            if (!r) return t(s);
            if (r > 0) {
                for (s -= o, a = 0; a < i.length; a++)
                    if (i[a] >= s) return i[a];
                return i[a - 1]
            } else
                for (a = i.length, s += o; a--;)
                    if (i[a] <= s) return i[a];
            return i[0]
        } : function (s, r, o) {
            o === void 0 && (o = .001);
            var a = t(s);
            return !r || Math.abs(a - s) < o || a - s < 0 == r < 0 ? a : t(r < 0 ? s - e : s + e)
        }
    },
    eH = function (e) {
        return function (t, i) {
            return R0(nS(e))(t, i.direction)
        }
    },
    nh = function (e, t, i, s) {
        return i.split(",").forEach(function (r) {
            return e(t, r, s)
        })
    },
    Ti = function (e, t, i, s, r) {
        return e.addEventListener(t, i, {
            passive: !s,
            capture: !!r
        })
    },
    Mi = function (e, t, i, s) {
        return e.removeEventListener(t, i, !!s)
    },
    sh = function (e, t, i) {
        i = i && i.wheelHandler, i && (e(t, "wheel", i), e(t, "touchmove", i))
    },
    Ax = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal"
    },
    rh = {
        toggleActions: "play",
        anticipatePin: 0
    },
    _f = {
        top: 0,
        left: 0,
        center: .5,
        bottom: 1,
        right: 1
    },
    Rh = function (e, t) {
        if (Fn(e)) {
            var i = e.indexOf("="),
                s = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
            ~i && (e.indexOf("%") > i && (s *= t / 100), e = e.substr(0, i - 1)), e = s + (e in _f ? _f[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
        }
        return e
    },
    oh = function (e, t, i, s, r, o, a, l) {
        var c = r.startColor,
            u = r.endColor,
            d = r.fontSize,
            h = r.indent,
            f = r.fontWeight,
            m = $t.createElement("div"),
            g = Ca(i) || go(i, "pinType") === "fixed",
            A = e.indexOf("scroller") !== -1,
            p = g ? Ot : i,
            v = e.indexOf("start") !== -1,
            _ = v ? c : u,
            b = "border-color:" + _ + ";font-size:" + d + ";color:" + _ + ";font-weight:" + f + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return b += "position:" + ((A || l) && g ? "fixed;" : "absolute;"), (A || l || !g) && (b += (s === bi ? T0 : I0) + ":" + (o + parseFloat(h)) + "px;"), a && (b += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), m._isStart = v, m.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), m.style.cssText = b, m.innerText = t || t === 0 ? e + "-" + t : e, p.children[0] ? p.insertBefore(m, p.children[0]) : p.appendChild(m), m._offset = m["offset" + s.op.d2], Ph(m, 0, s, v), m
    },
    Ph = function (e, t, i, s) {
        var r = {
            display: "block"
        },
            o = i[s ? "os2" : "p2"],
            a = i[s ? "p2" : "os2"];
        e._isFlipped = s, r[i.a + "Percent"] = s ? -100 : 0, r[i.a] = s ? "1px" : 0, r["border" + o + Kl] = 1, r["border" + a + Kl] = 0, r[i.p] = t + "px", Fe.set(e, r)
    },
    lt = [],
    nA = {},
    Nu, _x = function () {
        return ji() - ds > 34 && (Nu || (Nu = requestAnimationFrame(vr)))
    },
    rl = function () {
        (!on || !on.isPressed || on.startX > Ot.clientWidth) && (ut.cache++, on ? Nu || (Nu = requestAnimationFrame(vr)) : vr(), ds || Ma("scrollStart"), ds = ji())
    },
    Sm = function () {
        XC = ft.innerWidth, YC = ft.innerHeight
    },
    Nc = function () {
        ut.cache++, !$i && !jC && !$t.fullscreenElement && !$t.webkitFullscreenElement && (!eA || XC !== ft.innerWidth || Math.abs(ft.innerHeight - YC) > ft.innerHeight * .25) && mf.restart(!0)
    },
    Sa = {},
    tH = [],
    sS = function n() {
        return Mi(dt, "scrollEnd", n) || oa(!0)
    },
    Ma = function (e) {
        return Sa[e] && Sa[e].map(function (t) {
            return t()
        }) || tH
    },
    kn = [],
    rS = function (e) {
        for (var t = 0; t < kn.length; t += 5)(!e || kn[t + 4] && kn[t + 4].query === e) && (kn[t].style.cssText = kn[t + 1], kn[t].getBBox && kn[t].setAttribute("transform", kn[t + 2] || ""), kn[t + 3].uncache = 1)
    },
    P0 = function (e, t) {
        var i;
        for (an = 0; an < lt.length; an++) i = lt[an], i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
        gf = !0, t && rS(t), t || Ma("revert")
    },
    oS = function (e, t) {
        ut.cache++, (t || !ln) && ut.forEach(function (i) {
            return hn(i) && i.cacheID++ && (i.rec = 0)
        }), Fn(e) && (ft.history.scrollRestoration = S0 = e)
    },
    ln, _a = 0,
    vx, iH = function () {
        if (vx !== _a) {
            var e = vx = _a;
            requestAnimationFrame(function () {
                return e === _a && oa(!0)
            })
        }
    },
    aS = function () {
        Ot.appendChild(kl), M0 = !on && kl.offsetHeight || ft.innerHeight, Ot.removeChild(kl)
    },
    bx = function (e) {
        return Fu(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (t) {
            return t.style.display = e ? "none" : "block"
        })
    },
    oa = function (e, t) {
        if (ds && !e && !gf) {
            Ti(dt, "scrollEnd", sS);
            return
        }
        aS(), ln = dt.isRefreshing = !0, ut.forEach(function (s) {
            return hn(s) && ++s.cacheID && (s.rec = s())
        });
        var i = Ma("refreshInit");
        $C && dt.sort(), t || P0(), ut.forEach(function (s) {
            hn(s) && (s.smooth && (s.target.style.scrollBehavior = "auto"), s(0))
        }), lt.slice(0).forEach(function (s) {
            return s.refresh()
        }), gf = !1, lt.forEach(function (s) {
            if (s._subPinOffset && s.pin) {
                var r = s.vars.horizontal ? "offsetWidth" : "offsetHeight",
                    o = s.pin[r];
                s.revert(!0, 1), s.adjustPinSpacing(s.pin[r] - o), s.refresh()
            }
        }), iA = 1, bx(!0), lt.forEach(function (s) {
            var r = Qs(s.scroller, s._dir),
                o = s.vars.end === "max" || s._endClamp && s.end > r,
                a = s._startClamp && s.start >= r;
            (o || a) && s.setPositions(a ? r - 1 : s.start, o ? Math.max(a ? r : s.start + 1, r) : s.end, !0)
        }), bx(!1), iA = 0, i.forEach(function (s) {
            return s && s.render && s.render(-1)
        }), ut.forEach(function (s) {
            hn(s) && (s.smooth && requestAnimationFrame(function () {
                return s.target.style.scrollBehavior = "smooth"
            }), s.rec && s(s.rec))
        }), oS(S0, 1), mf.pause(), _a++, ln = 2, vr(2), lt.forEach(function (s) {
            return hn(s.vars.onRefresh) && s.vars.onRefresh(s)
        }), ln = dt.isRefreshing = !1, Ma("refresh")
    },
    sA = 0,
    Dh = 1,
    uu, vr = function (e) {
        if (e === 2 || !ln && !gf) {
            dt.isUpdating = !0, uu && uu.update(0);
            var t = lt.length,
                i = ji(),
                s = i - wm >= 50,
                r = t && lt[0].scroll();
            if (Dh = sA > r ? -1 : 1, ln || (sA = r), s && (ds && !jf && i - ds > 200 && (ds = 0, Ma("scrollEnd")), Dc = wm, wm = i), Dh < 0) {
                for (an = t; an-- > 0;) lt[an] && lt[an].update(0, s);
                Dh = 1
            } else
                for (an = 0; an < t; an++) lt[an] && lt[an].update(0, s);
            dt.isUpdating = !1
        }
        Nu = 0
    },
    rA = [tS, iS, I0, T0, ts + cu, ts + ou, ts + lu, ts + au, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    Lh = rA.concat([ga, Aa, "boxSizing", "max" + Kl, "max" + B0, "position", ts, ui, ui + lu, ui + ou, ui + cu, ui + au]),
    nH = function (e, t, i) {
        Fl(i);
        var s = e._gsap;
        if (s.spacerIsNative) Fl(s.spacerState);
        else if (e._gsap.swappedIn) {
            var r = t.parentNode;
            r && (r.insertBefore(e, t), r.removeChild(t))
        }
        e._gsap.swappedIn = !1
    },
    Mm = function (e, t, i, s) {
        if (!e._gsap.swappedIn) {
            for (var r = rA.length, o = t.style, a = e.style, l; r--;) l = rA[r], o[l] = i[l];
            o.position = i.position === "absolute" ? "absolute" : "relative", i.display === "inline" && (o.display = "inline-block"), a[I0] = a[T0] = "auto", o.flexBasis = i.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[ga] = Af(e, dn) + _i, o[Aa] = Af(e, bi) + _i, o[ui] = a[ts] = a[iS] = a[tS] = "0", Fl(s), a[ga] = a["max" + Kl] = i[ga], a[Aa] = a["max" + B0] = i[Aa], a[ui] = i[ui], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
        }
    },
    sH = /([A-Z])/g,
    Fl = function (e) {
        if (e) {
            var t = e.t.style,
                i = e.length,
                s = 0,
                r, o;
            for ((e.t._gsap || Fe.core.getCache(e.t)).uncache = 1; s < i; s += 2) o = e[s + 1], r = e[s], o ? t[r] = o : t[r] && t.removeProperty(r.replace(sH, "-$1").toLowerCase())
        }
    },
    ah = function (e) {
        for (var t = Lh.length, i = e.style, s = [], r = 0; r < t; r++) s.push(Lh[r], i[Lh[r]]);
        return s.t = e, s
    },
    rH = function (e, t, i) {
        for (var s = [], r = e.length, o = i ? 8 : 0, a; o < r; o += 2) a = e[o], s.push(a, a in t ? t[a] : e[o + 1]);
        return s.t = e.t, s
    },
    kh = {
        left: 0,
        top: 0
    },
    xx = function (e, t, i, s, r, o, a, l, c, u, d, h, f, m) {
        hn(e) && (e = e(l)), Fn(e) && e.substr(0, 3) === "max" && (e = h + (e.charAt(4) === "=" ? Rh("0" + e.substr(3), i) : 0));
        var g = f ? f.time() : 0,
            A, p, v;
        if (f && f.seek(0), isNaN(e) || (e = +e), Fc(e)) f && (e = Fe.utils.mapRange(f.scrollTrigger.start, f.scrollTrigger.end, 0, h, e)), a && Ph(a, i, s, !0);
        else {
            hn(t) && (t = t(l));
            var _ = (e || "0").split(" "),
                b, w, E, C;
            v = vn(t, l) || Ot, b = dr(v) || {}, (!b || !b.left && !b.top) && is(v).display === "none" && (C = v.style.display, v.style.display = "block", b = dr(v), C ? v.style.display = C : v.style.removeProperty("display")), w = Rh(_[0], b[s.d]), E = Rh(_[1] || "0", i), e = b[s.p] - c[s.p] - u + w + r - E, a && Ph(a, E, s, i - E < 20 || a._isStart && E > 20), i -= i - E
        }
        if (m && (l[m] = e || -.001, e < 0 && (e = 0)), o) {
            var S = e + i,
                x = o._isStart;
            A = "scroll" + s.d2, Ph(o, S, s, x && S > 20 || !x && (d ? Math.max(Ot[A], _s[A]) : o.parentNode[A]) <= S + 1), d && (c = dr(a), d && (o.style[s.op.p] = c[s.op.p] - s.op.m - o._offset + _i))
        }
        return f && v && (A = dr(v), f.seek(h), p = dr(v), f._caScrollDist = A[s.p] - p[s.p], e = e / f._caScrollDist * h), f && f.seek(g), f ? e : Math.round(e)
    },
    oH = /(webkit|moz|length|cssText|inset)/i,
    yx = function (e, t, i, s) {
        if (e.parentNode !== t) {
            var r = e.style,
                o, a;
            if (t === Ot) {
                e._stOrig = r.cssText, a = is(e);
                for (o in a) !+o && !oH.test(o) && a[o] && typeof r[o] == "string" && o !== "0" && (r[o] = a[o]);
                r.top = i, r.left = s
            } else r.cssText = e._stOrig;
            Fe.core.getCache(e).uncache = 1, t.appendChild(e)
        }
    },
    lS = function (e, t, i) {
        var s = t,
            r = s;
        return function (o) {
            var a = Math.round(e());
            return a !== s && a !== r && Math.abs(a - s) > 3 && Math.abs(a - r) > 3 && (o = a, i && i()), r = s, s = o, o
        }
    },
    lh = function (e, t, i) {
        var s = {};
        s[t.p] = "+=" + i, Fe.set(e, s)
    },
    Ex = function (e, t) {
        var i = Co(e, t),
            s = "_scroll" + t.p2,
            r = function o(a, l, c, u, d) {
                var h = o.tween,
                    f = l.onComplete,
                    m = {};
                c = c || i();
                var g = lS(i, c, function () {
                    h.kill(), o.tween = 0
                });
                return d = u && d || 0, u = u || a - c, h && h.kill(), l[s] = a, l.inherit = !1, l.modifiers = m, m[s] = function () {
                    return g(c + u * h.ratio + d * h.ratio * h.ratio)
                }, l.onUpdate = function () {
                    ut.cache++, o.tween && vr()
                }, l.onComplete = function () {
                    o.tween = 0, f && f.call(h)
                }, h = o.tween = Fe.to(e, l), h
            };
        return e[s] = i, i.wheelHandler = function () {
            return r.tween && r.tween.kill() && (r.tween = 0)
        }, Ti(e, "wheel", i.wheelHandler), dt.isTouch && Ti(e, "touchmove", i.wheelHandler), r
    },
    dt = function () {
        function n(t, i) {
            al || n.register(Fe) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), tA(this), this.init(t, i)
        }
        var e = n.prototype;
        return e.init = function (i, s) {
            if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Lc) {
                this.update = this.refresh = this.kill = Rs;
                return
            }
            i = gx(Fn(i) || Fc(i) || i.nodeType ? {
                trigger: i
            } : i, rh);
            var r = i,
                o = r.onUpdate,
                a = r.toggleClass,
                l = r.id,
                c = r.onToggle,
                u = r.onRefresh,
                d = r.scrub,
                h = r.trigger,
                f = r.pin,
                m = r.pinSpacing,
                g = r.invalidateOnRefresh,
                A = r.anticipatePin,
                p = r.onScrubComplete,
                v = r.onSnapComplete,
                _ = r.once,
                b = r.snap,
                w = r.pinReparent,
                E = r.pinSpacer,
                C = r.containerAnimation,
                S = r.fastScrollEnd,
                x = r.preventOverlaps,
                y = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? dn : bi,
                P = !d && d !== 0,
                T = vn(i.scroller || ft),
                R = Fe.core.getCache(T),
                D = Ca(T),
                U = ("pinType" in i ? i.pinType : go(T, "pinType") || D && "fixed") === "fixed",
                Q = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack],
                F = P && i.toggleActions.split(" "),
                L = "markers" in i ? i.markers : rh.markers,
                W = D ? 0 : parseFloat(is(T)["border" + y.p2 + Kl]) || 0,
                k = this,
                $ = i.onRefreshInit && function () {
                    return i.onRefreshInit(k)
                },
                X = XG(T, D, y),
                le = KG(T, D),
                K = 0,
                te = 0,
                ue = 0,
                fe = Co(T, y),
                Me, Be, Ce, Z, ke, N, G, Y, se, M, I, H, V, j, q, he, re, de, ge, ce, me, xe, ve, we, Pe, Ke, Ve, Le, We, Te, B, ee, pe, be, Se, et, tt, xt, Tt;
            if (k._startClamp = k._endClamp = !1, k._dir = y, A *= 45, k.scroller = T, k.scroll = C ? C.time.bind(C) : fe, Z = fe(), k.vars = i, s = s || i.animation, "refreshPriority" in i && ($C = 1, i.refreshPriority === -9999 && (uu = k)), R.tweenScroll = R.tweenScroll || {
                top: Ex(T, bi),
                left: Ex(T, dn)
            }, k.tweenTo = Me = R.tweenScroll[y.p], k.scrubDuration = function (Ee) {
                pe = Fc(Ee) && Ee, pe ? ee ? ee.duration(Ee) : ee = Fe.to(s, {
                    ease: "expo",
                    totalProgress: "+=0",
                    inherit: !1,
                    duration: pe,
                    paused: !0,
                    onComplete: function () {
                        return p && p(k)
                    }
                }) : (ee && ee.progress(1).kill(), ee = 0)
            }, s && (s.vars.lazy = !1, s._initted && !k.isReverted || s.vars.immediateRender !== !1 && i.immediateRender !== !1 && s.duration() && s.render(0, !0, !0), k.animation = s.pause(), s.scrollTrigger = k, k.scrubDuration(d), Te = 0, l || (l = s.vars.id)), b && ((!Jo(b) || b.push) && (b = {
                snapTo: b
            }), "scrollBehavior" in Ot.style && Fe.set(D ? [Ot, _s] : T, {
                scrollBehavior: "auto"
            }), ut.forEach(function (Ee) {
                return hn(Ee) && Ee.target === (D ? $t.scrollingElement || _s : T) && (Ee.smooth = !1)
            }), Ce = hn(b.snapTo) ? b.snapTo : b.snapTo === "labels" ? ZG(s) : b.snapTo === "labelsDirectional" ? eH(s) : b.directional !== !1 ? function (Ee, $e) {
                return R0(b.snapTo)(Ee, ji() - te < 500 ? 0 : $e.direction)
            } : Fe.utils.snap(b.snapTo), be = b.duration || {
                min: .1,
                max: 2
            }, be = Jo(be) ? ru(be.min, be.max) : ru(be, be), Se = Fe.delayedCall(b.delay || pe / 2 || .1, function () {
                var Ee = fe(),
                    $e = ji() - te < 500,
                    Qe = Me.tween;
                if (($e || Math.abs(k.getVelocity()) < 10) && !Qe && !jf && K !== Ee) {
                    var je = (Ee - N) / j,
                        ni = s && !P ? s.totalProgress() : je,
                        rt = $e ? 0 : (ni - B) / (ji() - Dc) * 1e3 || 0,
                        Qt = Fe.utils.clamp(-je, 1 - je, sl(rt / 2) * rt / .185),
                        Ai = je + (b.inertia === !1 ? 0 : Qt),
                        zt, Dt, wt = b,
                        O = wt.onStart,
                        J = wt.onInterrupt,
                        oe = wt.onComplete;
                    if (zt = Ce(Ai, k), Fc(zt) || (zt = Ai), Dt = Math.round(N + zt * j), Ee <= G && Ee >= N && Dt !== Ee) {
                        if (Qe && !Qe._initted && Qe.data <= sl(Dt - Ee)) return;
                        b.inertia === !1 && (Qt = zt - je), Me(Dt, {
                            duration: be(sl(Math.max(sl(Ai - ni), sl(zt - ni)) * .185 / rt / .05 || 0)),
                            ease: b.ease || "power3",
                            data: sl(Dt - Ee),
                            onInterrupt: function () {
                                return Se.restart(!0) && J && J(k)
                            },
                            onComplete: function () {
                                k.update(), K = fe(), s && (ee ? ee.resetTo("totalProgress", zt, s._tTime / s._tDur) : s.progress(zt)), Te = B = s && !P ? s.totalProgress() : k.progress, v && v(k), oe && oe(k)
                            }
                        }, Ee, Qt * j, Dt - Ee - Qt * j), O && O(k, Me.tween)
                    }
                } else k.isActive && K !== Ee && Se.restart(!0)
            }).pause()), l && (nA[l] = k), h = k.trigger = vn(h || f !== !0 && f), Tt = h && h._gsap && h._gsap.stRevert, Tt && (Tt = Tt(k)), f = f === !0 ? h : vn(f), Fn(a) && (a = {
                targets: h,
                className: a
            }), f && (m === !1 || m === ts || (m = !m && f.parentNode && f.parentNode.style && is(f.parentNode).display === "flex" ? !1 : ui), k.pin = f, Be = Fe.core.getCache(f), Be.spacer ? q = Be.pinState : (E && (E = vn(E), E && !E.nodeType && (E = E.current || E.nativeElement), Be.spacerIsNative = !!E, E && (Be.spacerState = ah(E))), Be.spacer = de = E || $t.createElement("div"), de.classList.add("pin-spacer"), l && de.classList.add("pin-spacer-" + l), Be.pinState = q = ah(f)), i.force3D !== !1 && Fe.set(f, {
                force3D: !0
            }), k.spacer = de = Be.spacer, We = is(f), we = We[m + y.os2], ce = Fe.getProperty(f), me = Fe.quickSetter(f, y.a, _i), Mm(f, de, We), re = ah(f)), L) {
                H = Jo(L) ? gx(L, Ax) : Ax, M = oh("scroller-start", l, T, y, H, 0), I = oh("scroller-end", l, T, y, H, 0, M), ge = M["offset" + y.op.d2];
                var mt = vn(go(T, "content") || T);
                Y = this.markerStart = oh("start", l, mt, y, H, ge, 0, C), se = this.markerEnd = oh("end", l, mt, y, H, ge, 0, C), C && (xt = Fe.quickSetter([Y, se], y.a, _i)), !U && !(Vs.length && go(T, "fixedMarkers") === !0) && (JG(D ? Ot : T), Fe.set([M, I], {
                    force3D: !0
                }), Ke = Fe.quickSetter(M, y.a, _i), Le = Fe.quickSetter(I, y.a, _i))
            }
            if (C) {
                var Ne = C.vars.onUpdate,
                    De = C.vars.onUpdateParams;
                C.eventCallback("onUpdate", function () {
                    k.update(0, 0, 1), Ne && Ne.apply(C, De || [])
                })
            }
            if (k.previous = function () {
                return lt[lt.indexOf(k) - 1]
            }, k.next = function () {
                return lt[lt.indexOf(k) + 1]
            }, k.revert = function (Ee, $e) {
                if (!$e) return k.kill(!0);
                var Qe = Ee !== !1 || !k.enabled,
                    je = $i;
                Qe !== k.isReverted && (Qe && (et = Math.max(fe(), k.scroll.rec || 0), ue = k.progress, tt = s && s.progress()), Y && [Y, se, M, I].forEach(function (ni) {
                    return ni.style.display = Qe ? "none" : "block"
                }), Qe && ($i = k, k.update(Qe)), f && (!w || !k.isActive) && (Qe ? nH(f, de, q) : Mm(f, de, is(f), Pe)), Qe || k.update(Qe), $i = je, k.isReverted = Qe)
            }, k.refresh = function (Ee, $e, Qe, je) {
                if (!(($i || !k.enabled) && !$e)) {
                    if (f && Ee && ds) {
                        Ti(n, "scrollEnd", sS);
                        return
                    } !ln && $ && $(k), $i = k, Me.tween && !Qe && (Me.tween.kill(), Me.tween = 0), ee && ee.pause(), g && s && s.revert({
                        kill: !1
                    }).invalidate(), k.isReverted || k.revert(!0, !0), k._subPinOffset = !1;
                    var ni = X(),
                        rt = le(),
                        Qt = C ? C.duration() : Qs(T, y),
                        Ai = j <= .01,
                        zt = 0,
                        Dt = je || 0,
                        wt = Jo(Qe) ? Qe.end : i.end,
                        O = i.endTrigger || h,
                        J = Jo(Qe) ? Qe.start : i.start || (i.start === 0 || !h ? 0 : f ? "0 0" : "0 100%"),
                        oe = k.pinnedContainer = i.pinnedContainer && vn(i.pinnedContainer, k),
                        ae = h && Math.max(0, lt.indexOf(k)) || 0,
                        ne = ae,
                        ye, Re, He, Ye, ze, Oe, qe, Nt, Hi, Gt, li, Ct, nt;
                    for (L && Jo(Qe) && (Ct = Fe.getProperty(M, y.p), nt = Fe.getProperty(I, y.p)); ne--;) Oe = lt[ne], Oe.end || Oe.refresh(0, 1) || ($i = k), qe = Oe.pin, qe && (qe === h || qe === f || qe === oe) && !Oe.isReverted && (Gt || (Gt = []), Gt.unshift(Oe), Oe.revert(!0, !0)), Oe !== lt[ne] && (ae--, ne--);
                    for (hn(J) && (J = J(k)), J = hx(J, "start", k), N = xx(J, h, ni, y, fe(), Y, M, k, rt, W, U, Qt, C, k._startClamp && "_startClamp") || (f ? -.001 : 0), hn(wt) && (wt = wt(k)), Fn(wt) && !wt.indexOf("+=") && (~wt.indexOf(" ") ? wt = (Fn(J) ? J.split(" ")[0] : "") + wt : (zt = Rh(wt.substr(2), ni), wt = Fn(J) ? J : (C ? Fe.utils.mapRange(0, C.duration(), C.scrollTrigger.start, C.scrollTrigger.end, N) : N) + zt, O = h)), wt = hx(wt, "end", k), G = Math.max(N, xx(wt || (O ? "100% 0" : Qt), O, ni, y, fe() + zt, se, I, k, rt, W, U, Qt, C, k._endClamp && "_endClamp")) || -.001, zt = 0, ne = ae; ne--;) Oe = lt[ne], qe = Oe.pin, qe && Oe.start - Oe._pinPush <= N && !C && Oe.end > 0 && (ye = Oe.end - (k._startClamp ? Math.max(0, Oe.start) : Oe.start), (qe === h && Oe.start - Oe._pinPush < N || qe === oe) && isNaN(J) && (zt += ye * (1 - Oe.progress)), qe === f && (Dt += ye));
                    if (N += zt, G += zt, k._startClamp && (k._startClamp += zt), k._endClamp && !ln && (k._endClamp = G || -.001, G = Math.min(G, Qs(T, y))), j = G - N || (N -= .01) && .001, Ai && (ue = Fe.utils.clamp(0, 1, Fe.utils.normalize(N, G, et))), k._pinPush = Dt, Y && zt && (ye = {}, ye[y.a] = "+=" + zt, oe && (ye[y.p] = "-=" + fe()), Fe.set([Y, se], ye)), f && !(iA && k.end >= Qs(T, y))) ye = is(f), Ye = y === bi, He = fe(), xe = parseFloat(ce(y.a)) + Dt, !Qt && G > 1 && (li = (D ? $t.scrollingElement || _s : T).style, li = {
                        style: li,
                        value: li["overflow" + y.a.toUpperCase()]
                    }, D && is(Ot)["overflow" + y.a.toUpperCase()] !== "scroll" && (li.style["overflow" + y.a.toUpperCase()] = "scroll")), Mm(f, de, ye), re = ah(f), Re = dr(f, !0), Nt = U && Co(T, Ye ? dn : bi)(), m ? (Pe = [m + y.os2, j + Dt + _i], Pe.t = de, ne = m === ui ? Af(f, y) + j + Dt : 0, ne && (Pe.push(y.d, ne + _i), de.style.flexBasis !== "auto" && (de.style.flexBasis = ne + _i)), Fl(Pe), oe && lt.forEach(function (Ks) {
                        Ks.pin === oe && Ks.vars.pinSpacing !== !1 && (Ks._subPinOffset = !0)
                    }), U && fe(et)) : (ne = Af(f, y), ne && de.style.flexBasis !== "auto" && (de.style.flexBasis = ne + _i)), U && (ze = {
                        top: Re.top + (Ye ? He - N : Nt) + _i,
                        left: Re.left + (Ye ? Nt : He - N) + _i,
                        boxSizing: "border-box",
                        position: "fixed"
                    }, ze[ga] = ze["max" + Kl] = Math.ceil(Re.width) + _i, ze[Aa] = ze["max" + B0] = Math.ceil(Re.height) + _i, ze[ts] = ze[ts + lu] = ze[ts + ou] = ze[ts + cu] = ze[ts + au] = "0", ze[ui] = ye[ui], ze[ui + lu] = ye[ui + lu], ze[ui + ou] = ye[ui + ou], ze[ui + cu] = ye[ui + cu], ze[ui + au] = ye[ui + au], he = rH(q, ze, w), ln && fe(0)), s ? (Hi = s._initted, ym(1), s.render(s.duration(), !0, !0), ve = ce(y.a) - xe + j + Dt, Ve = Math.abs(j - ve) > 1, U && Ve && he.splice(he.length - 2, 2), s.render(0, !0, !0), Hi || s.invalidate(!0), s.parent || s.totalTime(s.totalTime()), ym(0)) : ve = j, li && (li.value ? li.style["overflow" + y.a.toUpperCase()] = li.value : li.style.removeProperty("overflow-" + y.a));
                    else if (h && fe() && !C)
                        for (Re = h.parentNode; Re && Re !== Ot;) Re._pinOffset && (N -= Re._pinOffset, G -= Re._pinOffset), Re = Re.parentNode;
                    Gt && Gt.forEach(function (Ks) {
                        return Ks.revert(!1, !0)
                    }), k.start = N, k.end = G, Z = ke = ln ? et : fe(), !C && !ln && (Z < et && fe(et), k.scroll.rec = 0), k.revert(!1, !0), te = ji(), Se && (K = -1, Se.restart(!0)), $i = 0, s && P && (s._initted || tt) && s.progress() !== tt && s.progress(tt || 0, !0).render(s.time(), !0, !0), (Ai || ue !== k.progress || C || g) && (s && !P && s.totalProgress(C && N < -.001 && !ue ? Fe.utils.normalize(N, G, 0) : ue, !0), k.progress = Ai || (Z - N) / j === ue ? 0 : ue), f && m && (de._pinOffset = Math.round(k.progress * ve)), ee && ee.invalidate(), isNaN(Ct) || (Ct -= Fe.getProperty(M, y.p), nt -= Fe.getProperty(I, y.p), lh(M, y, Ct), lh(Y, y, Ct - (je || 0)), lh(I, y, nt), lh(se, y, nt - (je || 0))), Ai && !ln && k.update(), u && !ln && !V && (V = !0, u(k), V = !1)
                }
            }, k.getVelocity = function () {
                return (fe() - ke) / (ji() - Dc) * 1e3 || 0
            }, k.endAnimation = function () {
                wc(k.callbackAnimation), s && (ee ? ee.progress(1) : s.paused() ? P || wc(s, k.direction < 0, 1) : wc(s, s.reversed()))
            }, k.labelToScroll = function (Ee) {
                return s && s.labels && (N || k.refresh() || N) + s.labels[Ee] / s.duration() * j || 0
            }, k.getTrailing = function (Ee) {
                var $e = lt.indexOf(k),
                    Qe = k.direction > 0 ? lt.slice(0, $e).reverse() : lt.slice($e + 1);
                return (Fn(Ee) ? Qe.filter(function (je) {
                    return je.vars.preventOverlaps === Ee
                }) : Qe).filter(function (je) {
                    return k.direction > 0 ? je.end <= N : je.start >= G
                })
            }, k.update = function (Ee, $e, Qe) {
                if (!(C && !Qe && !Ee)) {
                    var je = ln === !0 ? et : k.scroll(),
                        ni = Ee ? 0 : (je - N) / j,
                        rt = ni < 0 ? 0 : ni > 1 ? 1 : ni || 0,
                        Qt = k.progress,
                        Ai, zt, Dt, wt, O, J, oe, ae;
                    if ($e && (ke = Z, Z = C ? fe() : je, b && (B = Te, Te = s && !P ? s.totalProgress() : rt)), A && f && !$i && !th && ds && (!rt && N < je + (je - ke) / (ji() - Dc) * A ? rt = 1e-4 : rt === 1 && G > je + (je - ke) / (ji() - Dc) * A && (rt = .9999)), rt !== Qt && k.enabled) {
                        if (Ai = k.isActive = !!rt && rt < 1, zt = !!Qt && Qt < 1, J = Ai !== zt, O = J || !!rt != !!Qt, k.direction = rt > Qt ? 1 : -1, k.progress = rt, O && !$i && (Dt = rt && !Qt ? 0 : rt === 1 ? 1 : Qt === 1 ? 2 : 3, P && (wt = !J && F[Dt + 1] !== "none" && F[Dt + 1] || F[Dt], ae = s && (wt === "complete" || wt === "reset" || wt in s))), x && (J || ae) && (ae || d || !s) && (hn(x) ? x(k) : k.getTrailing(x).forEach(function (He) {
                            return He.endAnimation()
                        })), P || (ee && !$i && !th ? (ee._dp._time - ee._start !== ee._time && ee.render(ee._dp._time - ee._start), ee.resetTo ? ee.resetTo("totalProgress", rt, s._tTime / s._tDur) : (ee.vars.totalProgress = rt, ee.invalidate().restart())) : s && s.totalProgress(rt, !!($i && (te || Ee)))), f) {
                            if (Ee && m && (de.style[m + y.os2] = we), !U) me(kc(xe + ve * rt));
                            else if (O) {
                                if (oe = !Ee && rt > Qt && G + 1 > je && je + 1 >= Qs(T, y), w)
                                    if (!Ee && (Ai || oe)) {
                                        var ne = dr(f, !0),
                                            ye = je - N;
                                        yx(f, Ot, ne.top + (y === bi ? ye : 0) + _i, ne.left + (y === bi ? 0 : ye) + _i)
                                    } else yx(f, de);
                                Fl(Ai || oe ? he : re), Ve && rt < 1 && Ai || me(xe + (rt === 1 && !oe ? ve : 0))
                            }
                        }
                        b && !Me.tween && !$i && !th && Se.restart(!0), a && (J || _ && rt && (rt < 1 || !Em)) && Fu(a.targets).forEach(function (He) {
                            return He.classList[Ai || _ ? "add" : "remove"](a.className)
                        }), o && !P && !Ee && o(k), O && !$i ? (P && (ae && (wt === "complete" ? s.pause().totalProgress(1) : wt === "reset" ? s.restart(!0).pause() : wt === "restart" ? s.restart(!0) : s[wt]()), o && o(k)), (J || !Em) && (c && J && Cm(k, c), Q[Dt] && Cm(k, Q[Dt]), _ && (rt === 1 ? k.kill(!1, 1) : Q[Dt] = 0), J || (Dt = rt === 1 ? 1 : 3, Q[Dt] && Cm(k, Q[Dt]))), S && !Ai && Math.abs(k.getVelocity()) > (Fc(S) ? S : 2500) && (wc(k.callbackAnimation), ee ? ee.progress(1) : wc(s, wt === "reverse" ? 1 : !rt, 1))) : P && o && !$i && o(k)
                    }
                    if (Le) {
                        var Re = C ? je / C.duration() * (C._caScrollDist || 0) : je;
                        Ke(Re + (M._isFlipped ? 1 : 0)), Le(Re)
                    }
                    xt && xt(-je / C.duration() * (C._caScrollDist || 0))
                }
            }, k.enable = function (Ee, $e) {
                k.enabled || (k.enabled = !0, Ti(T, "resize", Nc), D || Ti(T, "scroll", rl), $ && Ti(n, "refreshInit", $), Ee !== !1 && (k.progress = ue = 0, Z = ke = K = fe()), $e !== !1 && k.refresh())
            }, k.getTween = function (Ee) {
                return Ee && Me ? Me.tween : ee
            }, k.setPositions = function (Ee, $e, Qe, je) {
                if (C) {
                    var ni = C.scrollTrigger,
                        rt = C.duration(),
                        Qt = ni.end - ni.start;
                    Ee = ni.start + Qt * Ee / rt, $e = ni.start + Qt * $e / rt
                }
                k.refresh(!1, !1, {
                    start: fx(Ee, Qe && !!k._startClamp),
                    end: fx($e, Qe && !!k._endClamp)
                }, je), k.update()
            }, k.adjustPinSpacing = function (Ee) {
                if (Pe && Ee) {
                    var $e = Pe.indexOf(y.d) + 1;
                    Pe[$e] = parseFloat(Pe[$e]) + Ee + _i, Pe[1] = parseFloat(Pe[1]) + Ee + _i, Fl(Pe)
                }
            }, k.disable = function (Ee, $e) {
                if (k.enabled && (Ee !== !1 && k.revert(!0, !0), k.enabled = k.isActive = !1, $e || ee && ee.pause(), et = 0, Be && (Be.uncache = 1), $ && Mi(n, "refreshInit", $), Se && (Se.pause(), Me.tween && Me.tween.kill() && (Me.tween = 0)), !D)) {
                    for (var Qe = lt.length; Qe--;)
                        if (lt[Qe].scroller === T && lt[Qe] !== k) return;
                    Mi(T, "resize", Nc), D || Mi(T, "scroll", rl)
                }
            }, k.kill = function (Ee, $e) {
                k.disable(Ee, $e), ee && !$e && ee.kill(), l && delete nA[l];
                var Qe = lt.indexOf(k);
                Qe >= 0 && lt.splice(Qe, 1), Qe === an && Dh > 0 && an--, Qe = 0, lt.forEach(function (je) {
                    return je.scroller === k.scroller && (Qe = 1)
                }), Qe || ln || (k.scroll.rec = 0), s && (s.scrollTrigger = null, Ee && s.revert({
                    kill: !1
                }), $e || s.kill()), Y && [Y, se, M, I].forEach(function (je) {
                    return je.parentNode && je.parentNode.removeChild(je)
                }), uu === k && (uu = 0), f && (Be && (Be.uncache = 1), Qe = 0, lt.forEach(function (je) {
                    return je.pin === f && Qe++
                }), Qe || (Be.spacer = 0)), i.onKill && i.onKill(k)
            }, lt.push(k), k.enable(!1, !1), Tt && Tt(k), s && s.add && !j) {
                var it = k.update;
                k.update = function () {
                    k.update = it, N || G || k.refresh()
                }, Fe.delayedCall(.01, k.update), j = .01, N = G = 0
            } else k.refresh();
            f && iH()
        }, n.register = function (i) {
            return al || (Fe = i || JC(), KC() && window.document && n.enable(), al = Lc), al
        }, n.defaults = function (i) {
            if (i)
                for (var s in i) rh[s] = i[s];
            return rh
        }, n.disable = function (i, s) {
            Lc = 0, lt.forEach(function (o) {
                return o[s ? "kill" : "disable"](i)
            }), Mi(ft, "wheel", rl), Mi($t, "scroll", rl), clearInterval(eh), Mi($t, "touchcancel", Rs), Mi(Ot, "touchstart", Rs), nh(Mi, $t, "pointerdown,touchstart,mousedown", px), nh(Mi, $t, "pointerup,touchend,mouseup", mx), mf.kill(), ih(Mi);
            for (var r = 0; r < ut.length; r += 3) sh(Mi, ut[r], ut[r + 1]), sh(Mi, ut[r], ut[r + 2])
        }, n.enable = function () {
            if (ft = window, $t = document, _s = $t.documentElement, Ot = $t.body, Fe && (Fu = Fe.utils.toArray, ru = Fe.utils.clamp, tA = Fe.core.context || Rs, ym = Fe.core.suppressOverwrites || Rs, S0 = ft.history.scrollRestoration || "auto", sA = ft.pageYOffset, Fe.core.globals("ScrollTrigger", n), Ot)) {
                Lc = 1, kl = document.createElement("div"), kl.style.height = "100vh", kl.style.position = "absolute", aS(), YG(), ri.register(Fe), n.isTouch = ri.isTouch, zr = ri.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), eA = ri.isTouch === 1, Ti(ft, "wheel", rl), qC = [ft, $t, _s, Ot], Fe.matchMedia ? (n.matchMedia = function (l) {
                    var c = Fe.matchMedia(),
                        u;
                    for (u in l) c.add(u, l[u]);
                    return c
                }, Fe.addEventListener("matchMediaInit", function () {
                    return P0()
                }), Fe.addEventListener("matchMediaRevert", function () {
                    return rS()
                }), Fe.addEventListener("matchMedia", function () {
                    oa(0, 1), Ma("matchMedia")
                }), Fe.matchMedia("(orientation: portrait)", function () {
                    return Sm(), Sm
                })) : console.warn("Requires GSAP 3.11.0 or later"), Sm(), Ti($t, "scroll", rl);
                var i = Ot.style,
                    s = i.borderTopStyle,
                    r = Fe.core.Animation.prototype,
                    o, a;
                for (r.revert || Object.defineProperty(r, "revert", {
                    value: function () {
                        return this.time(-.01, !0)
                    }
                }), i.borderTopStyle = "solid", o = dr(Ot), bi.m = Math.round(o.top + bi.sc()) || 0, dn.m = Math.round(o.left + dn.sc()) || 0, s ? i.borderTopStyle = s : i.removeProperty("border-top-style"), eh = setInterval(_x, 250), Fe.delayedCall(.5, function () {
                    return th = 0
                }), Ti($t, "touchcancel", Rs), Ti(Ot, "touchstart", Rs), nh(Ti, $t, "pointerdown,touchstart,mousedown", px), nh(Ti, $t, "pointerup,touchend,mouseup", mx), Zg = Fe.utils.checkPrefix("transform"), Lh.push(Zg), al = ji(), mf = Fe.delayedCall(.2, oa).pause(), ll = [$t, "visibilitychange", function () {
                    var l = ft.innerWidth,
                        c = ft.innerHeight;
                    $t.hidden ? (ux = l, dx = c) : (ux !== l || dx !== c) && Nc()
                }, $t, "DOMContentLoaded", oa, ft, "load", oa, ft, "resize", Nc], ih(Ti), lt.forEach(function (l) {
                    return l.enable(0, 1)
                }), a = 0; a < ut.length; a += 3) sh(Mi, ut[a], ut[a + 1]), sh(Mi, ut[a], ut[a + 2])
            }
        }, n.config = function (i) {
            "limitCallbacks" in i && (Em = !!i.limitCallbacks);
            var s = i.syncInterval;
            s && clearInterval(eh) || (eh = s) && setInterval(_x, s), "ignoreMobileResize" in i && (eA = n.isTouch === 1 && i.ignoreMobileResize), "autoRefreshEvents" in i && (ih(Mi) || ih(Ti, i.autoRefreshEvents || "none"), jC = (i.autoRefreshEvents + "").indexOf("resize") === -1)
        }, n.scrollerProxy = function (i, s) {
            var r = vn(i),
                o = ut.indexOf(r),
                a = Ca(r);
            ~o && ut.splice(o, a ? 6 : 2), s && (a ? Vs.unshift(ft, s, Ot, s, _s, s) : Vs.unshift(r, s))
        }, n.clearMatchMedia = function (i) {
            lt.forEach(function (s) {
                return s._ctx && s._ctx.query === i && s._ctx.kill(!0, !0)
            })
        }, n.isInViewport = function (i, s, r) {
            var o = (Fn(i) ? vn(i) : i).getBoundingClientRect(),
                a = o[r ? ga : Aa] * s || 0;
            return r ? o.right - a > 0 && o.left + a < ft.innerWidth : o.bottom - a > 0 && o.top + a < ft.innerHeight
        }, n.positionInViewport = function (i, s, r) {
            Fn(i) && (i = vn(i));
            var o = i.getBoundingClientRect(),
                a = o[r ? ga : Aa],
                l = s == null ? a / 2 : s in _f ? _f[s] * a : ~s.indexOf("%") ? parseFloat(s) * a / 100 : parseFloat(s) || 0;
            return r ? (o.left + l) / ft.innerWidth : (o.top + l) / ft.innerHeight
        }, n.killAll = function (i) {
            if (lt.slice(0).forEach(function (r) {
                return r.vars.id !== "ScrollSmoother" && r.kill()
            }), i !== !0) {
                var s = Sa.killAll || [];
                Sa = {}, s.forEach(function (r) {
                    return r()
                })
            }
        }, n
    }();
dt.version = "3.12.5";
dt.saveStyles = function (n) {
    return n ? Fu(n).forEach(function (e) {
        if (e && e.style) {
            var t = kn.indexOf(e);
            t >= 0 && kn.splice(t, 5), kn.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Fe.core.getCache(e), tA())
        }
    }) : kn
};
dt.revert = function (n, e) {
    return P0(!n, e)
};
dt.create = function (n, e) {
    return new dt(n, e)
};
dt.refresh = function (n) {
    return n ? Nc() : (al || dt.register()) && oa(!0)
};
dt.update = function (n) {
    return ++ut.cache && vr(n === !0 ? 2 : 0)
};
dt.clearScrollMemory = oS;
dt.maxScroll = function (n, e) {
    return Qs(n, e ? dn : bi)
};
dt.getScrollFunc = function (n, e) {
    return Co(vn(n), e ? dn : bi)
};
dt.getById = function (n) {
    return nA[n]
};
dt.getAll = function () {
    return lt.filter(function (n) {
        return n.vars.id !== "ScrollSmoother"
    })
};
dt.isScrolling = function () {
    return !!ds
};
dt.snapDirectional = R0;
dt.addEventListener = function (n, e) {
    var t = Sa[n] || (Sa[n] = []);
    ~t.indexOf(e) || t.push(e)
};
dt.removeEventListener = function (n, e) {
    var t = Sa[n],
        i = t && t.indexOf(e);
    i >= 0 && t.splice(i, 1)
};
dt.batch = function (n, e) {
    var t = [],
        i = {},
        s = e.interval || .016,
        r = e.batchMax || 1e9,
        o = function (c, u) {
            var d = [],
                h = [],
                f = Fe.delayedCall(s, function () {
                    u(d, h), d = [], h = []
                }).pause();
            return function (m) {
                d.length || f.restart(!0), d.push(m.trigger), h.push(m), r <= d.length && f.progress(1)
            }
        },
        a;
    for (a in e) i[a] = a.substr(0, 2) === "on" && hn(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
    return hn(r) && (r = r(), Ti(dt, "refresh", function () {
        return r = e.batchMax()
    })), Fu(n).forEach(function (l) {
        var c = {};
        for (a in i) c[a] = i[a];
        c.trigger = l, t.push(dt.create(c))
    }), t
};
var wx = function (e, t, i, s) {
    return t > s ? e(s) : t < 0 && e(0), i > s ? (s - t) / (i - t) : i < 0 ? t / (t - i) : 1
},
    Tm = function n(e, t) {
        t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (ri.isTouch ? " pinch-zoom" : "") : "none", e === _s && n(Ot, t)
    },
    ch = {
        auto: 1,
        scroll: 1
    },
    aH = function (e) {
        var t = e.event,
            i = e.target,
            s = e.axis,
            r = (t.changedTouches ? t.changedTouches[0] : t).target,
            o = r._gsap || Fe.core.getCache(r),
            a = ji(),
            l;
        if (!o._isScrollT || a - o._isScrollT > 2e3) {
            for (; r && r !== Ot && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !(ch[(l = is(r)).overflowY] || ch[l.overflowX]));) r = r.parentNode;
            o._isScroll = r && r !== i && !Ca(r) && (ch[(l = is(r)).overflowY] || ch[l.overflowX]), o._isScrollT = a
        } (o._isScroll || s === "x") && (t.stopPropagation(), t._gsapAllow = !0)
    },
    cS = function (e, t, i, s) {
        return ri.create({
            target: e,
            capture: !0,
            debounce: !1,
            lockAxis: !0,
            type: t,
            onWheel: s = s && aH,
            onPress: s,
            onDrag: s,
            onScroll: s,
            onEnable: function () {
                return i && Ti($t, ri.eventTypes[0], Sx, !1, !0)
            },
            onDisable: function () {
                return Mi($t, ri.eventTypes[0], Sx, !0)
            }
        })
    },
    lH = /(input|label|select|textarea)/i,
    Cx, Sx = function (e) {
        var t = lH.test(e.target.tagName);
        (t || Cx) && (e._gsapAllow = !0, Cx = t)
    },
    cH = function (e) {
        Jo(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
        var t = e,
            i = t.normalizeScrollX,
            s = t.momentum,
            r = t.allowNestedScroll,
            o = t.onRelease,
            a, l, c = vn(e.target) || _s,
            u = Fe.core.globals().ScrollSmoother,
            d = u && u.get(),
            h = zr && (e.content && vn(e.content) || d && e.content !== !1 && !d.smooth() && d.content()),
            f = Co(c, bi),
            m = Co(c, dn),
            g = 1,
            A = (ri.isTouch && ft.visualViewport ? ft.visualViewport.scale * ft.visualViewport.width : ft.outerWidth) / ft.innerWidth,
            p = 0,
            v = hn(s) ? function () {
                return s(a)
            } : function () {
                return s || 2.8
            },
            _, b, w = cS(c, e.type, !0, r),
            E = function () {
                return b = !1
            },
            C = Rs,
            S = Rs,
            x = function () {
                l = Qs(c, bi), S = ru(zr ? 1 : 0, l), i && (C = ru(0, Qs(c, dn))), _ = _a
            },
            y = function () {
                h._gsap.y = kc(parseFloat(h._gsap.y) + f.offset) + "px", h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(h._gsap.y) + ", 0, 1)", f.offset = f.cacheID = 0
            },
            P = function () {
                if (b) {
                    requestAnimationFrame(E);
                    var L = kc(a.deltaY / 2),
                        W = S(f.v - L);
                    if (h && W !== f.v + f.offset) {
                        f.offset = W - f.v;
                        var k = kc((parseFloat(h && h._gsap.y) || 0) - f.offset);
                        h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + k + ", 0, 1)", h._gsap.y = k + "px", f.cacheID = ut.cache, vr()
                    }
                    return !0
                }
                f.offset && y(), b = !0
            },
            T, R, D, U, Q = function () {
                x(), T.isActive() && T.vars.scrollY > l && (f() > l ? T.progress(1) && f(l) : T.resetTo("scrollY", l))
            };
        return h && Fe.set(h, {
            y: "+=0"
        }), e.ignoreCheck = function (F) {
            return zr && F.type === "touchmove" && P() || g > 1.05 && F.type !== "touchstart" || a.isGesturing || F.touches && F.touches.length > 1
        }, e.onPress = function () {
            b = !1;
            var F = g;
            g = kc((ft.visualViewport && ft.visualViewport.scale || 1) / A), T.pause(), F !== g && Tm(c, g > 1.01 ? !0 : i ? !1 : "x"), R = m(), D = f(), x(), _ = _a
        }, e.onRelease = e.onGestureStart = function (F, L) {
            if (f.offset && y(), !L) U.restart(!0);
            else {
                ut.cache++;
                var W = v(),
                    k, $;
                i && (k = m(), $ = k + W * .05 * -F.velocityX / .227, W *= wx(m, k, $, Qs(c, dn)), T.vars.scrollX = C($)), k = f(), $ = k + W * .05 * -F.velocityY / .227, W *= wx(f, k, $, Qs(c, bi)), T.vars.scrollY = S($), T.invalidate().duration(W).play(.01), (zr && T.vars.scrollY >= l || k >= l - 1) && Fe.to({}, {
                    onUpdate: Q,
                    duration: W
                })
            }
            o && o(F)
        }, e.onWheel = function () {
            T._ts && T.pause(), ji() - p > 1e3 && (_ = 0, p = ji())
        }, e.onChange = function (F, L, W, k, $) {
            if (_a !== _ && x(), L && i && m(C(k[2] === L ? R + (F.startX - F.x) : m() + L - k[1])), W) {
                f.offset && y();
                var X = $[2] === W,
                    le = X ? D + F.startY - F.y : f() + W - $[1],
                    K = S(le);
                X && le !== K && (D += K - le), f(K)
            } (W || L) && vr()
        }, e.onEnable = function () {
            Tm(c, i ? !1 : "x"), dt.addEventListener("refresh", Q), Ti(ft, "resize", Q), f.smooth && (f.target.style.scrollBehavior = "auto", f.smooth = m.smooth = !1), w.enable()
        }, e.onDisable = function () {
            Tm(c, !0), Mi(ft, "resize", Q), dt.removeEventListener("refresh", Q), w.kill()
        }, e.lockAxis = e.lockAxis !== !1, a = new ri(e), a.iOS = zr, zr && !f() && f(1), zr && Fe.ticker.add(Rs), U = a._dc, T = Fe.to(a, {
            ease: "power4",
            paused: !0,
            inherit: !1,
            scrollX: i ? "+=0.1" : "+=0",
            scrollY: "+=0.1",
            modifiers: {
                scrollY: lS(f, f(), function () {
                    return T.pause()
                })
            },
            onUpdate: vr,
            onComplete: U.vars.onComplete
        }), a
    };
dt.sort = function (n) {
    return lt.sort(n || function (e, t) {
        return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
    })
};
dt.observe = function (n) {
    return new ri(n)
};
dt.normalizeScroll = function (n) {
    if (typeof n > "u") return on;
    if (n === !0 && on) return on.enable();
    if (n === !1) {
        on && on.kill(), on = n;
        return
    }
    var e = n instanceof ri ? n : cH(n);
    return on && on.target === e.target && on.kill(), Ca(e.target) && (on = e), e
};
dt.core = {
    _getVelocityProp: Jg,
    _inputObserver: cS,
    _scrollers: ut,
    _proxies: Vs,
    bridge: {
        ss: function () {
            ds || Ma("scrollStart"), ds = ji()
        },
        ref: function () {
            return $i
        }
    }
};
JC() && Fe.registerPlugin(dt);
/*!
 * ScrollToPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var fn, uS, br, zs, Ao, dS, hS, uh, fS = function () {
    return typeof window < "u"
},
    pS = function () {
        return fn || fS() && (fn = window.gsap) && fn.registerPlugin && fn
    },
    mS = function (e) {
        return typeof e == "string"
    },
    Mx = function (e) {
        return typeof e == "function"
    },
    Ou = function (e, t) {
        var i = t === "x" ? "Width" : "Height",
            s = "scroll" + i,
            r = "client" + i;
        return e === br || e === zs || e === Ao ? Math.max(zs[s], Ao[s]) - (br["inner" + i] || zs[r] || Ao[r]) : e[s] - e["offset" + i]
    },
    Uu = function (e, t) {
        var i = "scroll" + (t === "x" ? "Left" : "Top");
        return e === br && (e.pageXOffset != null ? i = "page" + t.toUpperCase() + "Offset" : e = zs[i] != null ? zs : Ao),
            function () {
                return e[i]
            }
    },
    uH = function (e, t, i, s) {
        if (Mx(e) && (e = e(t, i, s)), typeof e != "object") return mS(e) && e !== "max" && e.charAt(1) !== "=" ? {
            x: e,
            y: e
        } : {
            y: e
        };
        if (e.nodeType) return {
            y: e,
            x: e
        };
        var r = {},
            o;
        for (o in e) r[o] = o !== "onAutoKill" && Mx(e[o]) ? e[o](t, i, s) : e[o];
        return r
    },
    gS = function (e, t) {
        if (e = dS(e)[0], !e || !e.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
            x: 0,
            y: 0
        };
        var i = e.getBoundingClientRect(),
            s = !t || t === br || t === Ao,
            r = s ? {
                top: zs.clientTop - (br.pageYOffset || zs.scrollTop || Ao.scrollTop || 0),
                left: zs.clientLeft - (br.pageXOffset || zs.scrollLeft || Ao.scrollLeft || 0)
            } : t.getBoundingClientRect(),
            o = {
                x: i.left - r.left,
                y: i.top - r.top
            };
        return !s && t && (o.x += Uu(t, "x")(), o.y += Uu(t, "y")()), o
    },
    Tx = function (e, t, i, s, r) {
        return !isNaN(e) && typeof e != "object" ? parseFloat(e) - r : mS(e) && e.charAt(1) === "=" ? parseFloat(e.substr(2)) * (e.charAt(0) === "-" ? -1 : 1) + s - r : e === "max" ? Ou(t, i) - r : Math.min(Ou(t, i), gS(e, t)[i] - r)
    },
    Ix = function () {
        fn = pS(), fS() && fn && typeof document < "u" && document.body && (br = window, Ao = document.body, zs = document.documentElement, dS = fn.utils.toArray, fn.config({
            autoKillThreshold: 7
        }), hS = fn.config(), uS = 1)
    },
    Ku = {
        version: "3.12.5",
        name: "scrollTo",
        rawVars: 1,
        register: function (e) {
            fn = e, Ix()
        },
        init: function (e, t, i, s, r) {
            uS || Ix();
            var o = this,
                a = fn.getProperty(e, "scrollSnapType");
            o.isWin = e === br, o.target = e, o.tween = i, t = uH(t, s, e, r), o.vars = t, o.autoKill = !!t.autoKill, o.getX = Uu(e, "x"), o.getY = Uu(e, "y"), o.x = o.xPrev = o.getX(), o.y = o.yPrev = o.getY(), uh || (uh = fn.core.globals().ScrollTrigger), fn.getProperty(e, "scrollBehavior") === "smooth" && fn.set(e, {
                scrollBehavior: "auto"
            }), a && a !== "none" && (o.snap = 1, o.snapInline = e.style.scrollSnapType, e.style.scrollSnapType = "none"), t.x != null ? (o.add(o, "x", o.x, Tx(t.x, e, "x", o.x, t.offsetX || 0), s, r), o._props.push("scrollTo_x")) : o.skipX = 1, t.y != null ? (o.add(o, "y", o.y, Tx(t.y, e, "y", o.y, t.offsetY || 0), s, r), o._props.push("scrollTo_y")) : o.skipY = 1
        },
        render: function (e, t) {
            for (var i = t._pt, s = t.target, r = t.tween, o = t.autoKill, a = t.xPrev, l = t.yPrev, c = t.isWin, u = t.snap, d = t.snapInline, h, f, m, g, A; i;) i.r(e, i.d), i = i._next;
            h = c || !t.skipX ? t.getX() : a, f = c || !t.skipY ? t.getY() : l, m = f - l, g = h - a, A = hS.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), o && (!t.skipX && (g > A || g < -A) && h < Ou(s, "x") && (t.skipX = 1), !t.skipY && (m > A || m < -A) && f < Ou(s, "y") && (t.skipY = 1), t.skipX && t.skipY && (r.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(r, t.vars.onAutoKillParams || []))), c ? br.scrollTo(t.skipX ? h : t.x, t.skipY ? f : t.y) : (t.skipY || (s.scrollTop = t.y), t.skipX || (s.scrollLeft = t.x)), u && (e === 1 || e === 0) && (f = s.scrollTop, h = s.scrollLeft, d ? s.style.scrollSnapType = d : s.style.removeProperty("scroll-snap-type"), s.scrollTop = f + 1, s.scrollLeft = h + 1, s.scrollTop = f, s.scrollLeft = h), t.xPrev = t.x, t.yPrev = t.y, uh && uh.update()
        },
        kill: function (e) {
            var t = e === "scrollTo",
                i = this._props.indexOf(e);
            return (t || e === "scrollTo_x") && (this.skipX = 1), (t || e === "scrollTo_y") && (this.skipY = 1), i > -1 && this._props.splice(i, 1), !this._props.length
        }
    };
Ku.max = Ou;
Ku.getOffset = gS;
Ku.buildGetter = Uu;
pS() && fn.registerPlugin(Ku);
var oA = function () {
    return oA = Object.assign || function (n) {
        for (var e, t = 1, i = arguments.length; t < i; t++)
            for (var s in e = arguments[t]) Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
        return n
    }, oA.apply(this, arguments)
};

function AS(n, e, t) {
    return Math.max(n, Math.min(e, t))
}
class dH {
    advance(e) {
        var a;
        if (!this.isRunning) return;
        let t = !1;
        if (this.lerp) this.value = (i = this.value, s = this.to, r = 60 * this.lerp, o = e, function (l, c, u) {
            return (1 - u) * l + u * c
        }(i, s, 1 - Math.exp(-r * o))), Math.round(this.value) === this.to && (this.value = this.to, t = !0);
        else {
            this.currentTime += e;
            const l = AS(0, this.currentTime / this.duration, 1);
            t = l >= 1;
            const c = t ? 1 : this.easing(l);
            this.value = this.from + (this.to - this.from) * c
        }
        var i, s, r, o;
        (a = this.onUpdate) == null || a.call(this, this.value, t), t && this.stop()
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(e, t, {
        lerp: i = .1,
        duration: s = 1,
        easing: r = l => l,
        onStart: o,
        onUpdate: a
    }) {
        this.from = this.value = e, this.to = t, this.lerp = i, this.duration = s, this.easing = r, this.currentTime = 0, this.isRunning = !0, o == null || o(), this.onUpdate = a
    }
}
class hH {
    constructor({
        wrapper: e,
        content: t,
        autoResize: i = !0,
        debounce: s = 250
    } = {}) {
        Ae(this, "resize", () => {
            this.onWrapperResize(), this.onContentResize()
        });
        Ae(this, "onWrapperResize", () => {
            this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
        });
        Ae(this, "onContentResize", () => {
            this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
        });
        this.wrapper = e, this.content = t, i && (this.debouncedResize = function (r, o) {
            let a;
            return function () {
                let l = arguments,
                    c = this;
                clearTimeout(a), a = setTimeout(function () {
                    r.apply(c, l)
                }, o)
            }
        }(this.resize, s), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
    }
    destroy() {
        var e, t;
        (e = this.wrapperResizeObserver) == null || e.disconnect(), (t = this.contentResizeObserver) == null || t.disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
    }
    get limit() {
        return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
        }
    }
}
class _S {
    constructor() {
        this.events = {}
    }
    emit(e, ...t) {
        let i = this.events[e] || [];
        for (let s = 0, r = i.length; s < r; s++) i[s](...t)
    }
    on(e, t) {
        var i;
        return (i = this.events[e]) != null && i.push(t) || (this.events[e] = [t]), () => {
            var s;
            this.events[e] = (s = this.events[e]) == null ? void 0 : s.filter(r => t !== r)
        }
    }
    off(e, t) {
        var i;
        this.events[e] = (i = this.events[e]) == null ? void 0 : i.filter(s => t !== s)
    }
    destroy() {
        this.events = {}
    }
}
const Bx = 100 / 6;
class fH {
    constructor(e, {
        wheelMultiplier: t = 1,
        touchMultiplier: i = 1
    }) {
        Ae(this, "onTouchStart", e => {
            const {
                clientX: t,
                clientY: i
            } = e.targetTouches ? e.targetTouches[0] : e;
            this.touchStart.x = t, this.touchStart.y = i, this.lastDelta = {
                x: 0,
                y: 0
            }, this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: e
            })
        });
        Ae(this, "onTouchMove", e => {
            const {
                clientX: t,
                clientY: i
            } = e.targetTouches ? e.targetTouches[0] : e, s = -(t - this.touchStart.x) * this.touchMultiplier, r = -(i - this.touchStart.y) * this.touchMultiplier;
            this.touchStart.x = t, this.touchStart.y = i, this.lastDelta = {
                x: s,
                y: r
            }, this.emitter.emit("scroll", {
                deltaX: s,
                deltaY: r,
                event: e
            })
        });
        Ae(this, "onTouchEnd", e => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: e
            })
        });
        Ae(this, "onWheel", e => {
            let {
                deltaX: t,
                deltaY: i,
                deltaMode: s
            } = e;
            t *= s === 1 ? Bx : s === 2 ? this.windowWidth : 1, i *= s === 1 ? Bx : s === 2 ? this.windowHeight : 1, t *= this.wheelMultiplier, i *= this.wheelMultiplier, this.emitter.emit("scroll", {
                deltaX: t,
                deltaY: i,
                event: e
            })
        });
        Ae(this, "onWindowResize", () => {
            this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight
        });
        this.element = e, this.wheelMultiplier = t, this.touchMultiplier = i, this.touchStart = {
            x: null,
            y: null
        }, this.emitter = new _S, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, {
            passive: !1
        }), this.element.addEventListener("touchstart", this.onTouchStart, {
            passive: !1
        }), this.element.addEventListener("touchmove", this.onTouchMove, {
            passive: !1
        }), this.element.addEventListener("touchend", this.onTouchEnd, {
            passive: !1
        })
    }
    on(e, t) {
        return this.emitter.on(e, t)
    }
    destroy() {
        this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, {
            passive: !1
        }), this.element.removeEventListener("touchstart", this.onTouchStart, {
            passive: !1
        }), this.element.removeEventListener("touchmove", this.onTouchMove, {
            passive: !1
        }), this.element.removeEventListener("touchend", this.onTouchEnd, {
            passive: !1
        })
    }
}
var pH = function () {
    function n(e) {
        var t = e === void 0 ? {} : e,
            i = t.wrapper,
            s = i === void 0 ? window : i,
            r = t.content,
            o = r === void 0 ? document.documentElement : r,
            a = t.wheelEventsTarget,
            l = a === void 0 ? s : a,
            c = t.eventsTarget,
            u = c === void 0 ? l : c,
            d = t.smoothWheel,
            h = d === void 0 || d,
            f = t.syncTouch,
            m = f !== void 0 && f,
            g = t.syncTouchLerp,
            A = g === void 0 ? .075 : g,
            p = t.touchInertiaMultiplier,
            v = p === void 0 ? 35 : p,
            _ = t.duration,
            b = t.easing,
            w = b === void 0 ? function (le) {
                return Math.min(1, 1.001 - Math.pow(2, -10 * le))
            } : b,
            E = t.lerp,
            C = E === void 0 ? !_ && .1 : E,
            S = t.infinite,
            x = S !== void 0 && S,
            y = t.orientation,
            P = y === void 0 ? "vertical" : y,
            T = t.gestureOrientation,
            R = T === void 0 ? "vertical" : T,
            D = t.touchMultiplier,
            U = D === void 0 ? 1 : D,
            Q = t.wheelMultiplier,
            F = Q === void 0 ? 1 : Q,
            L = t.autoResize,
            W = L === void 0 || L,
            k = t.__experimental__naiveDimensions,
            $ = k !== void 0 && k,
            X = this;
        this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = function (le) {
            var K = le.deltaX,
                te = le.deltaY,
                ue = le.event;
            if (!ue.ctrlKey) {
                var fe = ue.type.includes("touch"),
                    Me = ue.type.includes("wheel");
                if (X.options.syncTouch && fe && ue.type === "touchstart" && !X.isStopped && !X.isLocked) X.reset();
                else {
                    var Be = K === 0 && te === 0,
                        Ce = X.options.gestureOrientation === "vertical" && te === 0 || X.options.gestureOrientation === "horizontal" && K === 0;
                    if (!Be && !Ce) {
                        var Z = ue.composedPath();
                        if (!(Z = Z.slice(0, Z.indexOf(X.rootElement))).find(function (Y) {
                            var se, M, I, H, V;
                            return ((se = Y.hasAttribute) === null || se === void 0 ? void 0 : se.call(Y, "data-lenis-prevent")) || fe && ((M = Y.hasAttribute) === null || M === void 0 ? void 0 : M.call(Y, "data-lenis-prevent-touch")) || Me && ((I = Y.hasAttribute) === null || I === void 0 ? void 0 : I.call(Y, "data-lenis-prevent-wheel")) || ((H = Y.classList) === null || H === void 0 ? void 0 : H.contains("lenis")) && !(!((V = Y.classList) === null || V === void 0) && V.contains("lenis-stopped"))
                        }))
                            if (X.isStopped || X.isLocked) ue.preventDefault();
                            else {
                                if (X.isSmooth = X.options.syncTouch && fe || X.options.smoothWheel && Me, !X.isSmooth) return X.isScrolling = !1, void X.animate.stop();
                                ue.preventDefault();
                                var ke = te;
                                X.options.gestureOrientation === "both" ? ke = Math.abs(te) > Math.abs(K) ? te : K : X.options.gestureOrientation === "horizontal" && (ke = K);
                                var N = fe && X.options.syncTouch,
                                    G = fe && ue.type === "touchend" && Math.abs(ke) > 5;
                                G && (ke = X.velocity * X.options.touchInertiaMultiplier), X.scrollTo(X.targetScroll + ke, oA({
                                    programmatic: !1
                                }, N ? {
                                    lerp: G ? X.options.syncTouchLerp : 1
                                } : {
                                    lerp: X.options.lerp,
                                    duration: X.options.duration,
                                    easing: X.options.easing
                                }))
                            }
                    }
                }
            }
        }, this.onNativeScroll = function () {
            if (!X.__preventNextScrollEvent && !X.isScrolling) {
                var le = X.animatedScroll;
                X.animatedScroll = X.targetScroll = X.actualScroll, X.velocity = 0, X.direction = Math.sign(X.animatedScroll - le), X.emit()
            }
        }, window.lenisVersion = "1.0.44", s !== document.documentElement && s !== document.body || (s = window), this.options = {
            wrapper: s,
            content: o,
            wheelEventsTarget: l,
            eventsTarget: u,
            smoothWheel: h,
            syncTouch: m,
            syncTouchLerp: A,
            touchInertiaMultiplier: v,
            duration: _,
            easing: w,
            lerp: C,
            infinite: x,
            gestureOrientation: R,
            orientation: P,
            touchMultiplier: U,
            wheelMultiplier: F,
            autoResize: W,
            __experimental__naiveDimensions: $
        }, this.animate = new dH, this.emitter = new _S, this.dimensions = new hH({
            wrapper: s,
            content: o,
            autoResize: W
        }), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = m || h, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new fH(u, {
            touchMultiplier: U,
            wheelMultiplier: F
        }), this.virtualScroll.on("scroll", this.onVirtualScroll)
    }
    return n.prototype.destroy = function () {
        this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1)
    }, n.prototype.on = function (e, t) {
        return this.emitter.on(e, t)
    }, n.prototype.off = function (e, t) {
        return this.emitter.off(e, t)
    }, n.prototype.setScroll = function (e) {
        this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
    }, n.prototype.resize = function () {
        this.dimensions.resize()
    }, n.prototype.emit = function () {
        this.emitter.emit("scroll", this)
    }, n.prototype.reset = function () {
        this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
    }, n.prototype.start = function () {
        this.isStopped && (this.isStopped = !1, this.reset())
    }, n.prototype.stop = function () {
        this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
    }, n.prototype.raf = function (e) {
        var t = e - (this.time || e);
        this.time = e, this.animate.advance(.001 * t)
    }, n.prototype.scrollTo = function (e, t) {
        var i = this,
            s = t === void 0 ? {} : t,
            r = s.offset,
            o = r === void 0 ? 0 : r,
            a = s.immediate,
            l = a !== void 0 && a,
            c = s.lock,
            u = c !== void 0 && c,
            d = s.duration,
            h = d === void 0 ? this.options.duration : d,
            f = s.easing,
            m = f === void 0 ? this.options.easing : f,
            g = s.lerp,
            A = g === void 0 ? !h && this.options.lerp : g,
            p = s.onComplete,
            v = s.force,
            _ = v !== void 0 && v,
            b = s.programmatic,
            w = b === void 0 || b;
        if (!this.isStopped && !this.isLocked || _) {
            if (["top", "left", "start"].includes(e)) e = 0;
            else if (["bottom", "right", "end"].includes(e)) e = this.limit;
            else {
                var E = void 0;
                if (typeof e == "string" ? E = document.querySelector(e) : e != null && e.nodeType && (E = e), E) {
                    if (this.options.wrapper !== window) {
                        var C = this.options.wrapper.getBoundingClientRect();
                        o -= this.isHorizontal ? C.left : C.top
                    }
                    var S = E.getBoundingClientRect();
                    e = (this.isHorizontal ? S.left : S.top) + this.animatedScroll
                }
            }
            if (typeof e == "number") {
                if (e += o, e = Math.round(e), this.options.infinite ? w && (this.targetScroll = this.animatedScroll = this.scroll) : e = AS(0, e, this.limit), l) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void (p == null || p(this));
                if (!w) {
                    if (e === this.targetScroll) return;
                    this.targetScroll = e
                }
                this.animate.fromTo(this.animatedScroll, e, {
                    duration: h,
                    easing: m,
                    lerp: A,
                    onStart: function () {
                        u && (i.isLocked = !0), i.isScrolling = !0
                    },
                    onUpdate: function (x, y) {
                        i.isScrolling = !0, i.velocity = x - i.animatedScroll, i.direction = Math.sign(i.velocity), i.animatedScroll = x, i.setScroll(i.scroll), w && (i.targetScroll = x), y || i.emit(), y && (i.reset(), i.emit(), p == null || p(i), i.__preventNextScrollEvent = !0, requestAnimationFrame(function () {
                            delete i.__preventNextScrollEvent
                        }))
                    }
                })
            }
        }
    }, Object.defineProperty(n.prototype, "rootElement", {
        get: function () {
            return this.options.wrapper === window ? document.documentElement : this.options.wrapper
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "limit", {
        get: function () {
            return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "isHorizontal", {
        get: function () {
            return this.options.orientation === "horizontal"
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "actualScroll", {
        get: function () {
            return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "scroll", {
        get: function () {
            return this.options.infinite ? (e = this.animatedScroll, t = this.limit, (e % t + t) % t) : this.animatedScroll;
            var e, t
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "progress", {
        get: function () {
            return this.limit === 0 ? 1 : this.scroll / this.limit
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "isSmooth", {
        get: function () {
            return this.__isSmooth
        },
        set: function (e) {
            this.__isSmooth !== e && (this.__isSmooth = e, this.toggleClassName("lenis-smooth", e))
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "isScrolling", {
        get: function () {
            return this.__isScrolling
        },
        set: function (e) {
            this.__isScrolling !== e && (this.__isScrolling = e, this.toggleClassName("lenis-scrolling", e))
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "isStopped", {
        get: function () {
            return this.__isStopped
        },
        set: function (e) {
            this.__isStopped !== e && (this.__isStopped = e, this.toggleClassName("lenis-stopped", e))
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "isLocked", {
        get: function () {
            return this.__isLocked
        },
        set: function (e) {
            this.__isLocked !== e && (this.__isLocked = e, this.toggleClassName("lenis-locked", e))
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(n.prototype, "className", {
        get: function () {
            var e = "lenis";
            return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), this.isSmooth && (e += " lenis-smooth"), e
        },
        enumerable: !1,
        configurable: !0
    }), n.prototype.toggleClassName = function (e, t) {
        this.rootElement.classList.toggle(e, t), this.emitter.emit("className change", this)
    }, n
}();
bt.registerPlugin(dt, $f, Ku);
const mH = {
    name: "App",
    data: () => ({
        timeout: null,
        lenisScroll: null,
        timelineApp: null,
        isScrolling: !1,
        positions: []
    }),
    components: {
        AppHeader: mB,
        AppFooter: NB,
        AppPreloader: VB,
        AppThreeCanvas: qU,
        SectionHero: aQ,
        SectionWhyWe: bQ,
        SectionRoadmap: WQ,
        SectionConverterCoins: fz,
        SectionFeatures: Pz,
        SectionTokenSpecifics: Hz,
        SectionMainCollection: cG,
        SectionCollection: wG,
        SectionFAQ: QG
    },
    watch: {
        preloaderIsShown(n) {
            !n && !this.timelineApp && (this.initAppTimeline(), this.initLenisScroll(), this.calculatePositionsSection())
        }
    },
    computed: {
        ...fs(gn, ["breakpoints", "preloaderIsShown"]),
        isHTMLVisible() {
            return !0
        },
        isCanvasVisible() {
            return !0
        }
    },
    created() {
        this.setBreakpoints(), this.checkActiveBreakpoint(), window.addEventListener("resize", () => {
            this.calculatePositionsSection(), this.checkActiveBreakpoint()
        })
    },
    methods: {
        ...RA(gn, ["setBreakpoint", "setActiveBreakpoint"]),
        initAppTimeline() {
            this.timelineApp = bt.timeline({
                scrollTrigger: {
                    trigger: document.documentElement,
                    start: "top top",
                    end: "bottom bottom",
                    markers: !1,
                    onUpdate: ({
                        progress: n
                    }) => {
                        window.dispatchEvent(new CustomEvent("scroll:update-normalize-y", {
                            detail: {
                                currentPoint: n
                            }
                        }))
                    }
                }
            })
        },
        initLenisScroll() {
            this.lenis = new pH({
                lerp: .06
            }), this.lenis.on("scroll", dt.update), bt.ticker.add(n => {
                this.lenis.raf(n * 1e3)
            }), bt.ticker.lagSmoothing(0), this.lenis.scrollTo(0, {
                lerp: 0,
                duration: 0,
                lock: !0,
                force: !0
            })
        },
        goToSection(n) {
            const t = this.$refs.scrollContainer.querySelector(`#${n}`),
                i = t.parentElement;
            let s = t;
            i.classList.contains("pin-spacer") && (s = i), this.lenis.scrollTo(s, {
                offset: 10,
                lock: !0
            })
        },
        calculatePositionsSection() {
            const n = this.$refs.scrollContainer,
                e = document.documentElement.scrollHeight - window.innerHeight,
                t = Array(...n.children);
            this.positions = [], t.forEach((i, s) => {
                const r = i.getBoundingClientRect(),
                    o = window.scrollY,
                    l = (r.top + o) / e;
                this.positions.push(l)
            }), window.dispatchEvent(new CustomEvent("scroll:update-breakpoints", {
                detail: {
                    breakpoints: [...this.positions]
                }
            }))
        },
        checkActiveBreakpoint() {
            const n = Object.keys(this.breakpoints),
                e = n.find((t, i) => {
                    const s = this.breakpoints[t];
                    return window.innerWidth <= s || i === n.length - 1
                });
            this.setActiveBreakpoint(e)
        },
        setBreakpoints() {
            const n = getComputedStyle(document.documentElement);
            ["md", "xl", "xxl"].forEach(e => {
                this.setBreakpoint(e, parseFloat(n.getPropertyValue(`--breakpoint-${e}`)))
            })
        }
    }
},
    gH = {
        class: "content"
    },
    AH = {
        key: 1,
        ref: "scrollContainer",
        class: "wrap-sections"
    };

function _H(n, e, t, i, s, r) {
    const o = Mt("app-preloader"),
        a = Mt("app-header"),
        l = Mt("app-three-canvas"),
        c = Mt("section-hero"),
        u = Mt("section-why-we"),
        d = Mt("section-roadmap"),
        h = Mt("section-converter-coins"),
        f = Mt("section-features"),
        m = Mt("section-token-specifics"),
        g = Mt("section-main-collection"),
        A = Mt("section-collection"),
        p = Mt("section-FAQ"),
        v = Mt("app-footer");
    return Ge(), st(Bt, null, [gt(o), r.isHTMLVisible ? (Ge(), yn(a, {
        key: 0,
        onGoToSection: r.goToSection
    }, null, 8, ["onGoToSection"])) : Sc("", !0), ie("main", gH, [r.isCanvasVisible ? (Ge(), yn(l, {
        key: 0
    })) : Sc("", !0), r.isHTMLVisible ? (Ge(), st("div", AH, [gt(c), gt(u), gt(d), gt(h), gt(f), gt(m), gt(g), gt(A), gt(p)], 512)) : Sc("", !0)]), r.isHTMLVisible ? (Ge(), yn(v, {
        key: 1
    })) : Sc("", !0)], 64)
}
const vH = ki(mH, [
    ["render", _H]
]);

function Rx(n) {
    return n !== null && typeof n == "object" && "constructor" in n && n.constructor === Object
}

function D0(n, e) {
    n === void 0 && (n = {}), e === void 0 && (e = {}), Object.keys(e).forEach(t => {
        typeof n[t] > "u" ? n[t] = e[t] : Rx(e[t]) && Rx(n[t]) && Object.keys(e[t]).length > 0 && D0(n[t], e[t])
    })
}
const vS = {
    body: {},
    addEventListener() { },
    removeEventListener() { },
    activeElement: {
        blur() { },
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() { }
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() { },
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};

function zi() {
    const n = typeof document < "u" ? document : {};
    return D0(n, vS), n
}
const bH = {
    document: vS,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() { },
        pushState() { },
        go() { },
        back() { }
    },
    CustomEvent: function () {
        return this
    },
    addEventListener() { },
    removeEventListener() { },
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() { },
    Date() { },
    screen: {},
    setTimeout() { },
    clearTimeout() { },
    matchMedia() {
        return {}
    },
    requestAnimationFrame(n) {
        return typeof setTimeout > "u" ? (n(), null) : setTimeout(n, 0)
    },
    cancelAnimationFrame(n) {
        typeof setTimeout > "u" || clearTimeout(n)
    }
};

function ii() {
    const n = typeof window < "u" ? window : {};
    return D0(n, bH), n
}

function Gr(n) {
    return n === void 0 && (n = ""), n.trim().split(" ").filter(e => !!e.trim())
}

function xH(n) {
    const e = n;
    Object.keys(e).forEach(t => {
        try {
            e[t] = null
        } catch { }
        try {
            delete e[t]
        } catch { }
    })
}

function Ta(n, e) {
    return e === void 0 && (e = 0), setTimeout(n, e)
}

function ns() {
    return Date.now()
}

function yH(n) {
    const e = ii();
    let t;
    return e.getComputedStyle && (t = e.getComputedStyle(n, null)), !t && n.currentStyle && (t = n.currentStyle), t || (t = n.style), t
}

function aA(n, e) {
    e === void 0 && (e = "x");
    const t = ii();
    let i, s, r;
    const o = yH(n);
    return t.WebKitCSSMatrix ? (s = o.transform || o.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(a => a.replace(",", ".")).join(", ")), r = new t.WebKitCSSMatrix(s === "none" ? "" : s)) : (r = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = r.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? s = r.m41 : i.length === 16 ? s = parseFloat(i[12]) : s = parseFloat(i[4])), e === "y" && (t.WebKitCSSMatrix ? s = r.m42 : i.length === 16 ? s = parseFloat(i[13]) : s = parseFloat(i[5])), s || 0
}

function Oc(n) {
    return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object"
}

function EH(n) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? n instanceof HTMLElement : n && (n.nodeType === 1 || n.nodeType === 11)
}

function Un() {
    const n = Object(arguments.length <= 0 ? void 0 : arguments[0]),
        e = ["__proto__", "constructor", "prototype"];
    for (let t = 1; t < arguments.length; t += 1) {
        const i = t < 0 || arguments.length <= t ? void 0 : arguments[t];
        if (i != null && !EH(i)) {
            const s = Object.keys(Object(i)).filter(r => e.indexOf(r) < 0);
            for (let r = 0, o = s.length; r < o; r += 1) {
                const a = s[r],
                    l = Object.getOwnPropertyDescriptor(i, a);
                l !== void 0 && l.enumerable && (Oc(n[a]) && Oc(i[a]) ? i[a].__swiper__ ? n[a] = i[a] : Un(n[a], i[a]) : !Oc(n[a]) && Oc(i[a]) ? (n[a] = {}, i[a].__swiper__ ? n[a] = i[a] : Un(n[a], i[a])) : n[a] = i[a])
            }
        }
    }
    return n
}

function Uc(n, e, t) {
    n.style.setProperty(e, t)
}

function bS(n) {
    let {
        swiper: e,
        targetPosition: t,
        side: i
    } = n;
    const s = ii(),
        r = -e.translate;
    let o = null,
        a;
    const l = e.params.speed;
    e.wrapperEl.style.scrollSnapType = "none", s.cancelAnimationFrame(e.cssModeFrameID);
    const c = t > r ? "next" : "prev",
        u = (h, f) => c === "next" && h >= f || c === "prev" && h <= f,
        d = () => {
            a = new Date().getTime(), o === null && (o = a);
            const h = Math.max(Math.min((a - o) / l, 1), 0),
                f = .5 - Math.cos(h * Math.PI) / 2;
            let m = r + f * (t - r);
            if (u(m, t) && (m = t), e.wrapperEl.scrollTo({
                [i]: m
            }), u(m, t)) {
                e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                    e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
                        [i]: m
                    })
                }), s.cancelAnimationFrame(e.cssModeFrameID);
                return
            }
            e.cssModeFrameID = s.requestAnimationFrame(d)
        };
    d()
}

function Ra(n) {
    return n.querySelector(".swiper-slide-transform") || n.shadowRoot && n.shadowRoot.querySelector(".swiper-slide-transform") || n
}

function Qi(n, e) {
    return e === void 0 && (e = ""), [...n.children].filter(t => t.matches(e))
}

function vf(n) {
    try {
        console.warn(n);
        return
    } catch { }
}

function Vn(n, e) {
    e === void 0 && (e = []);
    const t = document.createElement(n);
    return t.classList.add(...Array.isArray(e) ? e : Gr(e)), t
}

function bf(n) {
    const e = ii(),
        t = zi(),
        i = n.getBoundingClientRect(),
        s = t.body,
        r = n.clientTop || s.clientTop || 0,
        o = n.clientLeft || s.clientLeft || 0,
        a = n === e ? e.scrollY : n.scrollTop,
        l = n === e ? e.scrollX : n.scrollLeft;
    return {
        top: i.top + a - r,
        left: i.left + l - o
    }
}

function wH(n, e) {
    const t = [];
    for (; n.previousElementSibling;) {
        const i = n.previousElementSibling;
        e ? i.matches(e) && t.push(i) : t.push(i), n = i
    }
    return t
}

function CH(n, e) {
    const t = [];
    for (; n.nextElementSibling;) {
        const i = n.nextElementSibling;
        e ? i.matches(e) && t.push(i) : t.push(i), n = i
    }
    return t
}

function uo(n, e) {
    return ii().getComputedStyle(n, null).getPropertyValue(e)
}

function Qu(n) {
    let e = n,
        t;
    if (e) {
        for (t = 0;
            (e = e.previousSibling) !== null;) e.nodeType === 1 && (t += 1);
        return t
    }
}

function va(n, e) {
    const t = [];
    let i = n.parentElement;
    for (; i;) e ? i.matches(e) && t.push(i) : t.push(i), i = i.parentElement;
    return t
}

function du(n, e) {
    function t(i) {
        i.target === n && (e.call(n, i), n.removeEventListener("transitionend", t))
    }
    e && n.addEventListener("transitionend", t)
}

function lA(n, e, t) {
    const i = ii();
    return t ? n[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : n.offsetWidth
}

function ct(n) {
    return (Array.isArray(n) ? n : [n]).filter(e => !!e)
}
let Im;

function SH() {
    const n = ii(),
        e = zi();
    return {
        smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style,
        touch: !!("ontouchstart" in n || n.DocumentTouch && e instanceof n.DocumentTouch)
    }
}

function xS() {
    return Im || (Im = SH()), Im
}
let Bm;

function MH(n) {
    let {
        userAgent: e
    } = n === void 0 ? {} : n;
    const t = xS(),
        i = ii(),
        s = i.navigator.platform,
        r = e || i.navigator.userAgent,
        o = {
            ios: !1,
            android: !1
        },
        a = i.screen.width,
        l = i.screen.height,
        c = r.match(/(Android);?[\s\/]+([\d.]+)?/);
    let u = r.match(/(iPad).*OS\s([\d_]+)/);
    const d = r.match(/(iPod)(.*OS\s([\d_]+))?/),
        h = !u && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
        f = s === "Win32";
    let m = s === "MacIntel";
    const g = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !u && m && t.touch && g.indexOf(`${a}x${l}`) >= 0 && (u = r.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), m = !1), c && !f && (o.os = "android", o.android = !0), (u || h || d) && (o.os = "ios", o.ios = !0), o
}

function yS(n) {
    return n === void 0 && (n = {}), Bm || (Bm = MH(n)), Bm
}
let Rm;

function TH() {
    const n = ii(),
        e = yS();
    let t = !1;

    function i() {
        const a = n.navigator.userAgent.toLowerCase();
        return a.indexOf("safari") >= 0 && a.indexOf("chrome") < 0 && a.indexOf("android") < 0
    }
    if (i()) {
        const a = String(n.navigator.userAgent);
        if (a.includes("Version/")) {
            const [l, c] = a.split("Version/")[1].split(" ")[0].split(".").map(u => Number(u));
            t = l < 16 || l === 16 && c < 2
        }
    }
    const s = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent),
        r = i(),
        o = r || s && e.ios;
    return {
        isSafari: t || r,
        needPerspectiveFix: t,
        need3dFix: o,
        isWebView: s
    }
}

function IH() {
    return Rm || (Rm = TH()), Rm
}

function BH(n) {
    let {
        swiper: e,
        on: t,
        emit: i
    } = n;
    const s = ii();
    let r = null,
        o = null;
    const a = () => {
        !e || e.destroyed || !e.initialized || (i("beforeResize"), i("resize"))
    },
        l = () => {
            !e || e.destroyed || !e.initialized || (r = new ResizeObserver(d => {
                o = s.requestAnimationFrame(() => {
                    const {
                        width: h,
                        height: f
                    } = e;
                    let m = h,
                        g = f;
                    d.forEach(A => {
                        let {
                            contentBoxSize: p,
                            contentRect: v,
                            target: _
                        } = A;
                        _ && _ !== e.el || (m = v ? v.width : (p[0] || p).inlineSize, g = v ? v.height : (p[0] || p).blockSize)
                    }), (m !== h || g !== f) && a()
                })
            }), r.observe(e.el))
        },
        c = () => {
            o && s.cancelAnimationFrame(o), r && r.unobserve && e.el && (r.unobserve(e.el), r = null)
        },
        u = () => {
            !e || e.destroyed || !e.initialized || i("orientationchange")
        };
    t("init", () => {
        if (e.params.resizeObserver && typeof s.ResizeObserver < "u") {
            l();
            return
        }
        s.addEventListener("resize", a), s.addEventListener("orientationchange", u)
    }), t("destroy", () => {
        c(), s.removeEventListener("resize", a), s.removeEventListener("orientationchange", u)
    })
}

function RH(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    const r = [],
        o = ii(),
        a = function (u, d) {
            d === void 0 && (d = {});
            const h = o.MutationObserver || o.WebkitMutationObserver,
                f = new h(m => {
                    if (e.__preventObserver__) return;
                    if (m.length === 1) {
                        s("observerUpdate", m[0]);
                        return
                    }
                    const g = function () {
                        s("observerUpdate", m[0])
                    };
                    o.requestAnimationFrame ? o.requestAnimationFrame(g) : o.setTimeout(g, 0)
                });
            f.observe(u, {
                attributes: typeof d.attributes > "u" ? !0 : d.attributes,
                childList: typeof d.childList > "u" ? !0 : d.childList,
                characterData: typeof d.characterData > "u" ? !0 : d.characterData
            }), r.push(f)
        },
        l = () => {
            if (e.params.observer) {
                if (e.params.observeParents) {
                    const u = va(e.hostEl);
                    for (let d = 0; d < u.length; d += 1) a(u[d])
                }
                a(e.hostEl, {
                    childList: e.params.observeSlideChildren
                }), a(e.wrapperEl, {
                    attributes: !1
                })
            }
        },
        c = () => {
            r.forEach(u => {
                u.disconnect()
            }), r.splice(0, r.length)
        };
    t({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }), i("init", l), i("destroy", c)
}
var PH = {
    on(n, e, t) {
        const i = this;
        if (!i.eventsListeners || i.destroyed || typeof e != "function") return i;
        const s = t ? "unshift" : "push";
        return n.split(" ").forEach(r => {
            i.eventsListeners[r] || (i.eventsListeners[r] = []), i.eventsListeners[r][s](e)
        }), i
    },
    once(n, e, t) {
        const i = this;
        if (!i.eventsListeners || i.destroyed || typeof e != "function") return i;

        function s() {
            i.off(n, s), s.__emitterProxy && delete s.__emitterProxy;
            for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++) o[a] = arguments[a];
            e.apply(i, o)
        }
        return s.__emitterProxy = e, i.on(n, s, t)
    },
    onAny(n, e) {
        const t = this;
        if (!t.eventsListeners || t.destroyed || typeof n != "function") return t;
        const i = e ? "unshift" : "push";
        return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[i](n), t
    },
    offAny(n) {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
        const t = e.eventsAnyListeners.indexOf(n);
        return t >= 0 && e.eventsAnyListeners.splice(t, 1), e
    },
    off(n, e) {
        const t = this;
        return !t.eventsListeners || t.destroyed || !t.eventsListeners || n.split(" ").forEach(i => {
            typeof e > "u" ? t.eventsListeners[i] = [] : t.eventsListeners[i] && t.eventsListeners[i].forEach((s, r) => {
                (s === e || s.__emitterProxy && s.__emitterProxy === e) && t.eventsListeners[i].splice(r, 1)
            })
        }), t
    },
    emit() {
        const n = this;
        if (!n.eventsListeners || n.destroyed || !n.eventsListeners) return n;
        let e, t, i;
        for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++) r[o] = arguments[o];
        return typeof r[0] == "string" || Array.isArray(r[0]) ? (e = r[0], t = r.slice(1, r.length), i = n) : (e = r[0].events, t = r[0].data, i = r[0].context || n), t.unshift(i), (Array.isArray(e) ? e : e.split(" ")).forEach(l => {
            n.eventsAnyListeners && n.eventsAnyListeners.length && n.eventsAnyListeners.forEach(c => {
                c.apply(i, [l, ...t])
            }), n.eventsListeners && n.eventsListeners[l] && n.eventsListeners[l].forEach(c => {
                c.apply(i, t)
            })
        }), n
    }
};

function DH() {
    const n = this;
    let e, t;
    const i = n.el;
    typeof n.params.width < "u" && n.params.width !== null ? e = n.params.width : e = i.clientWidth, typeof n.params.height < "u" && n.params.height !== null ? t = n.params.height : t = i.clientHeight, !(e === 0 && n.isHorizontal() || t === 0 && n.isVertical()) && (e = e - parseInt(uo(i, "padding-left") || 0, 10) - parseInt(uo(i, "padding-right") || 0, 10), t = t - parseInt(uo(i, "padding-top") || 0, 10) - parseInt(uo(i, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(n, {
        width: e,
        height: t,
        size: n.isHorizontal() ? e : t
    }))
}

function LH() {
    const n = this;

    function e(y, P) {
        return parseFloat(y.getPropertyValue(n.getDirectionLabel(P)) || 0)
    }
    const t = n.params,
        {
            wrapperEl: i,
            slidesEl: s,
            size: r,
            rtlTranslate: o,
            wrongRTL: a
        } = n,
        l = n.virtual && t.virtual.enabled,
        c = l ? n.virtual.slides.length : n.slides.length,
        u = Qi(s, `.${n.params.slideClass}, swiper-slide`),
        d = l ? n.virtual.slides.length : u.length;
    let h = [];
    const f = [],
        m = [];
    let g = t.slidesOffsetBefore;
    typeof g == "function" && (g = t.slidesOffsetBefore.call(n));
    let A = t.slidesOffsetAfter;
    typeof A == "function" && (A = t.slidesOffsetAfter.call(n));
    const p = n.snapGrid.length,
        v = n.slidesGrid.length;
    let _ = t.spaceBetween,
        b = -g,
        w = 0,
        E = 0;
    if (typeof r > "u") return;
    typeof _ == "string" && _.indexOf("%") >= 0 ? _ = parseFloat(_.replace("%", "")) / 100 * r : typeof _ == "string" && (_ = parseFloat(_)), n.virtualSize = -_, u.forEach(y => {
        o ? y.style.marginLeft = "" : y.style.marginRight = "", y.style.marginBottom = "", y.style.marginTop = ""
    }), t.centeredSlides && t.cssMode && (Uc(i, "--swiper-centered-offset-before", ""), Uc(i, "--swiper-centered-offset-after", ""));
    const C = t.grid && t.grid.rows > 1 && n.grid;
    C ? n.grid.initSlides(u) : n.grid && n.grid.unsetSlides();
    let S;
    const x = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter(y => typeof t.breakpoints[y].slidesPerView < "u").length > 0;
    for (let y = 0; y < d; y += 1) {
        S = 0;
        let P;
        if (u[y] && (P = u[y]), C && n.grid.updateSlide(y, P, u), !(u[y] && uo(P, "display") === "none")) {
            if (t.slidesPerView === "auto") {
                x && (u[y].style[n.getDirectionLabel("width")] = "");
                const T = getComputedStyle(P),
                    R = P.style.transform,
                    D = P.style.webkitTransform;
                if (R && (P.style.transform = "none"), D && (P.style.webkitTransform = "none"), t.roundLengths) S = n.isHorizontal() ? lA(P, "width", !0) : lA(P, "height", !0);
                else {
                    const U = e(T, "width"),
                        Q = e(T, "padding-left"),
                        F = e(T, "padding-right"),
                        L = e(T, "margin-left"),
                        W = e(T, "margin-right"),
                        k = T.getPropertyValue("box-sizing");
                    if (k && k === "border-box") S = U + L + W;
                    else {
                        const {
                            clientWidth: $,
                            offsetWidth: X
                        } = P;
                        S = U + Q + F + L + W + (X - $)
                    }
                }
                R && (P.style.transform = R), D && (P.style.webkitTransform = D), t.roundLengths && (S = Math.floor(S))
            } else S = (r - (t.slidesPerView - 1) * _) / t.slidesPerView, t.roundLengths && (S = Math.floor(S)), u[y] && (u[y].style[n.getDirectionLabel("width")] = `${S}px`);
            u[y] && (u[y].swiperSlideSize = S), m.push(S), t.centeredSlides ? (b = b + S / 2 + w / 2 + _, w === 0 && y !== 0 && (b = b - r / 2 - _), y === 0 && (b = b - r / 2 - _), Math.abs(b) < 1 / 1e3 && (b = 0), t.roundLengths && (b = Math.floor(b)), E % t.slidesPerGroup === 0 && h.push(b), f.push(b)) : (t.roundLengths && (b = Math.floor(b)), (E - Math.min(n.params.slidesPerGroupSkip, E)) % n.params.slidesPerGroup === 0 && h.push(b), f.push(b), b = b + S + _), n.virtualSize += S + _, w = S, E += 1
        }
    }
    if (n.virtualSize = Math.max(n.virtualSize, r) + A, o && a && (t.effect === "slide" || t.effect === "coverflow") && (i.style.width = `${n.virtualSize + _}px`), t.setWrapperSize && (i.style[n.getDirectionLabel("width")] = `${n.virtualSize + _}px`), C && n.grid.updateWrapperSize(S, h), !t.centeredSlides) {
        const y = [];
        for (let P = 0; P < h.length; P += 1) {
            let T = h[P];
            t.roundLengths && (T = Math.floor(T)), h[P] <= n.virtualSize - r && y.push(T)
        }
        h = y, Math.floor(n.virtualSize - r) - Math.floor(h[h.length - 1]) > 1 && h.push(n.virtualSize - r)
    }
    if (l && t.loop) {
        const y = m[0] + _;
        if (t.slidesPerGroup > 1) {
            const P = Math.ceil((n.virtual.slidesBefore + n.virtual.slidesAfter) / t.slidesPerGroup),
                T = y * t.slidesPerGroup;
            for (let R = 0; R < P; R += 1) h.push(h[h.length - 1] + T)
        }
        for (let P = 0; P < n.virtual.slidesBefore + n.virtual.slidesAfter; P += 1) t.slidesPerGroup === 1 && h.push(h[h.length - 1] + y), f.push(f[f.length - 1] + y), n.virtualSize += y
    }
    if (h.length === 0 && (h = [0]), _ !== 0) {
        const y = n.isHorizontal() && o ? "marginLeft" : n.getDirectionLabel("marginRight");
        u.filter((P, T) => !t.cssMode || t.loop ? !0 : T !== u.length - 1).forEach(P => {
            P.style[y] = `${_}px`
        })
    }
    if (t.centeredSlides && t.centeredSlidesBounds) {
        let y = 0;
        m.forEach(T => {
            y += T + (_ || 0)
        }), y -= _;
        const P = y - r;
        h = h.map(T => T <= 0 ? -g : T > P ? P + A : T)
    }
    if (t.centerInsufficientSlides) {
        let y = 0;
        if (m.forEach(P => {
            y += P + (_ || 0)
        }), y -= _, y < r) {
            const P = (r - y) / 2;
            h.forEach((T, R) => {
                h[R] = T - P
            }), f.forEach((T, R) => {
                f[R] = T + P
            })
        }
    }
    if (Object.assign(n, {
        slides: u,
        snapGrid: h,
        slidesGrid: f,
        slidesSizesGrid: m
    }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) {
        Uc(i, "--swiper-centered-offset-before", `${-h[0]}px`), Uc(i, "--swiper-centered-offset-after", `${n.size / 2 - m[m.length - 1] / 2}px`);
        const y = -n.snapGrid[0],
            P = -n.slidesGrid[0];
        n.snapGrid = n.snapGrid.map(T => T + y), n.slidesGrid = n.slidesGrid.map(T => T + P)
    }
    if (d !== c && n.emit("slidesLengthChange"), h.length !== p && (n.params.watchOverflow && n.checkOverflow(), n.emit("snapGridLengthChange")), f.length !== v && n.emit("slidesGridLengthChange"), t.watchSlidesProgress && n.updateSlidesOffset(), n.emit("slidesUpdated"), !l && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) {
        const y = `${t.containerModifierClass}backface-hidden`,
            P = n.el.classList.contains(y);
        d <= t.maxBackfaceHiddenSlides ? P || n.el.classList.add(y) : P && n.el.classList.remove(y)
    }
}

function kH(n) {
    const e = this,
        t = [],
        i = e.virtual && e.params.virtual.enabled;
    let s = 0,
        r;
    typeof n == "number" ? e.setTransition(n) : n === !0 && e.setTransition(e.params.speed);
    const o = a => i ? e.slides[e.getSlideIndexByData(a)] : e.slides[a];
    if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
        if (e.params.centeredSlides) (e.visibleSlides || []).forEach(a => {
            t.push(a)
        });
        else
            for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
                const a = e.activeIndex + r;
                if (a > e.slides.length && !i) break;
                t.push(o(a))
            } else t.push(o(e.activeIndex));
    for (r = 0; r < t.length; r += 1)
        if (typeof t[r] < "u") {
            const a = t[r].offsetHeight;
            s = a > s ? a : s
        } (s || s === 0) && (e.wrapperEl.style.height = `${s}px`)
}

function FH() {
    const n = this,
        e = n.slides,
        t = n.isElement ? n.isHorizontal() ? n.wrapperEl.offsetLeft : n.wrapperEl.offsetTop : 0;
    for (let i = 0; i < e.length; i += 1) e[i].swiperSlideOffset = (n.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) - t - n.cssOverflowAdjustment()
}

function NH(n) {
    n === void 0 && (n = this && this.translate || 0);
    const e = this,
        t = e.params,
        {
            slides: i,
            rtlTranslate: s,
            snapGrid: r
        } = e;
    if (i.length === 0) return;
    typeof i[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
    let o = -n;
    s && (o = n), i.forEach(l => {
        l.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass)
    }), e.visibleSlidesIndexes = [], e.visibleSlides = [];
    let a = t.spaceBetween;
    typeof a == "string" && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * e.size : typeof a == "string" && (a = parseFloat(a));
    for (let l = 0; l < i.length; l += 1) {
        const c = i[l];
        let u = c.swiperSlideOffset;
        t.cssMode && t.centeredSlides && (u -= i[0].swiperSlideOffset);
        const d = (o + (t.centeredSlides ? e.minTranslate() : 0) - u) / (c.swiperSlideSize + a),
            h = (o - r[0] + (t.centeredSlides ? e.minTranslate() : 0) - u) / (c.swiperSlideSize + a),
            f = -(o - u),
            m = f + e.slidesSizesGrid[l],
            g = f >= 0 && f <= e.size - e.slidesSizesGrid[l];
        (f >= 0 && f < e.size - 1 || m > 1 && m <= e.size || f <= 0 && m >= e.size) && (e.visibleSlides.push(c), e.visibleSlidesIndexes.push(l), i[l].classList.add(t.slideVisibleClass)), g && i[l].classList.add(t.slideFullyVisibleClass), c.progress = s ? -d : d, c.originalProgress = s ? -h : h
    }
}

function OH(n) {
    const e = this;
    if (typeof n > "u") {
        const u = e.rtlTranslate ? -1 : 1;
        n = e && e.translate && e.translate * u || 0
    }
    const t = e.params,
        i = e.maxTranslate() - e.minTranslate();
    let {
        progress: s,
        isBeginning: r,
        isEnd: o,
        progressLoop: a
    } = e;
    const l = r,
        c = o;
    if (i === 0) s = 0, r = !0, o = !0;
    else {
        s = (n - e.minTranslate()) / i;
        const u = Math.abs(n - e.minTranslate()) < 1,
            d = Math.abs(n - e.maxTranslate()) < 1;
        r = u || s <= 0, o = d || s >= 1, u && (s = 0), d && (s = 1)
    }
    if (t.loop) {
        const u = e.getSlideIndexByData(0),
            d = e.getSlideIndexByData(e.slides.length - 1),
            h = e.slidesGrid[u],
            f = e.slidesGrid[d],
            m = e.slidesGrid[e.slidesGrid.length - 1],
            g = Math.abs(n);
        g >= h ? a = (g - h) / m : a = (g + m - f) / m, a > 1 && (a -= 1)
    }
    Object.assign(e, {
        progress: s,
        progressLoop: a,
        isBeginning: r,
        isEnd: o
    }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(n), r && !l && e.emit("reachBeginning toEdge"), o && !c && e.emit("reachEnd toEdge"), (l && !r || c && !o) && e.emit("fromEdge"), e.emit("progress", s)
}
const Pm = (n, e, t) => {
    e && !n.classList.contains(t) ? n.classList.add(t) : !e && n.classList.contains(t) && n.classList.remove(t)
};

function UH() {
    const n = this,
        {
            slides: e,
            params: t,
            slidesEl: i,
            activeIndex: s
        } = n,
        r = n.virtual && t.virtual.enabled,
        o = n.grid && t.grid && t.grid.rows > 1,
        a = d => Qi(i, `.${t.slideClass}${d}, swiper-slide${d}`)[0];
    let l, c, u;
    if (r)
        if (t.loop) {
            let d = s - n.virtual.slidesBefore;
            d < 0 && (d = n.virtual.slides.length + d), d >= n.virtual.slides.length && (d -= n.virtual.slides.length), l = a(`[data-swiper-slide-index="${d}"]`)
        } else l = a(`[data-swiper-slide-index="${s}"]`);
    else o ? (l = e.filter(d => d.column === s)[0], u = e.filter(d => d.column === s + 1)[0], c = e.filter(d => d.column === s - 1)[0]) : l = e[s];
    l && (o || (u = CH(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !u && (u = e[0]), c = wH(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !c === 0 && (c = e[e.length - 1]))), e.forEach(d => {
        Pm(d, d === l, t.slideActiveClass), Pm(d, d === u, t.slideNextClass), Pm(d, d === c, t.slidePrevClass)
    }), n.emitSlidesClasses()
}
const Fh = (n, e) => {
    if (!n || n.destroyed || !n.params) return;
    const t = () => n.isElement ? "swiper-slide" : `.${n.params.slideClass}`,
        i = e.closest(t());
    if (i) {
        let s = i.querySelector(`.${n.params.lazyPreloaderClass}`);
        !s && n.isElement && (i.shadowRoot ? s = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
            i.shadowRoot && (s = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`), s && s.remove())
        })), s && s.remove()
    }
},
    Dm = (n, e) => {
        if (!n.slides[e]) return;
        const t = n.slides[e].querySelector('[loading="lazy"]');
        t && t.removeAttribute("loading")
    },
    cA = n => {
        if (!n || n.destroyed || !n.params) return;
        let e = n.params.lazyPreloadPrevNext;
        const t = n.slides.length;
        if (!t || !e || e < 0) return;
        e = Math.min(e, t);
        const i = n.params.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(n.params.slidesPerView),
            s = n.activeIndex;
        if (n.params.grid && n.params.grid.rows > 1) {
            const o = s,
                a = [o - e];
            a.push(...Array.from({
                length: e
            }).map((l, c) => o + i + c)), n.slides.forEach((l, c) => {
                a.includes(l.column) && Dm(n, c)
            });
            return
        }
        const r = s + i - 1;
        if (n.params.rewind || n.params.loop)
            for (let o = s - e; o <= r + e; o += 1) {
                const a = (o % t + t) % t;
                (a < s || a > r) && Dm(n, a)
            } else
            for (let o = Math.max(s - e, 0); o <= Math.min(r + e, t - 1); o += 1) o !== s && (o > r || o < s) && Dm(n, o)
    };

function QH(n) {
    const {
        slidesGrid: e,
        params: t
    } = n, i = n.rtlTranslate ? n.translate : -n.translate;
    let s;
    for (let r = 0; r < e.length; r += 1) typeof e[r + 1] < "u" ? i >= e[r] && i < e[r + 1] - (e[r + 1] - e[r]) / 2 ? s = r : i >= e[r] && i < e[r + 1] && (s = r + 1) : i >= e[r] && (s = r);
    return t.normalizeSlideIndex && (s < 0 || typeof s > "u") && (s = 0), s
}

function zH(n) {
    const e = this,
        t = e.rtlTranslate ? e.translate : -e.translate,
        {
            snapGrid: i,
            params: s,
            activeIndex: r,
            realIndex: o,
            snapIndex: a
        } = e;
    let l = n,
        c;
    const u = f => {
        let m = f - e.virtual.slidesBefore;
        return m < 0 && (m = e.virtual.slides.length + m), m >= e.virtual.slides.length && (m -= e.virtual.slides.length), m
    };
    if (typeof l > "u" && (l = QH(e)), i.indexOf(t) >= 0) c = i.indexOf(t);
    else {
        const f = Math.min(s.slidesPerGroupSkip, l);
        c = f + Math.floor((l - f) / s.slidesPerGroup)
    }
    if (c >= i.length && (c = i.length - 1), l === r && !e.params.loop) {
        c !== a && (e.snapIndex = c, e.emit("snapIndexChange"));
        return
    }
    if (l === r && e.params.loop && e.virtual && e.params.virtual.enabled) {
        e.realIndex = u(l);
        return
    }
    const d = e.grid && s.grid && s.grid.rows > 1;
    let h;
    if (e.virtual && s.virtual.enabled && s.loop) h = u(l);
    else if (d) {
        const f = e.slides.filter(g => g.column === l)[0];
        let m = parseInt(f.getAttribute("data-swiper-slide-index"), 10);
        Number.isNaN(m) && (m = Math.max(e.slides.indexOf(f), 0)), h = Math.floor(m / s.grid.rows)
    } else if (e.slides[l]) {
        const f = e.slides[l].getAttribute("data-swiper-slide-index");
        f ? h = parseInt(f, 10) : h = l
    } else h = l;
    Object.assign(e, {
        previousSnapIndex: a,
        snapIndex: c,
        previousRealIndex: o,
        realIndex: h,
        previousIndex: r,
        activeIndex: l
    }), e.initialized && cA(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (o !== h && e.emit("realIndexChange"), e.emit("slideChange"))
}

function GH(n, e) {
    const t = this,
        i = t.params;
    let s = n.closest(`.${i.slideClass}, swiper-slide`);
    !s && t.isElement && e && e.length > 1 && e.includes(n) && [...e.slice(e.indexOf(n) + 1, e.length)].forEach(a => {
        !s && a.matches && a.matches(`.${i.slideClass}, swiper-slide`) && (s = a)
    });
    let r = !1,
        o;
    if (s) {
        for (let a = 0; a < t.slides.length; a += 1)
            if (t.slides[a] === s) {
                r = !0, o = a;
                break
            }
    }
    if (s && r) t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(s.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = o;
    else {
        t.clickedSlide = void 0, t.clickedIndex = void 0;
        return
    }
    i.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
}
var HH = {
    updateSize: DH,
    updateSlides: LH,
    updateAutoHeight: kH,
    updateSlidesOffset: FH,
    updateSlidesProgress: NH,
    updateProgress: OH,
    updateSlidesClasses: UH,
    updateActiveIndex: zH,
    updateClickedSlide: GH
};

function VH(n) {
    n === void 0 && (n = this.isHorizontal() ? "x" : "y");
    const e = this,
        {
            params: t,
            rtlTranslate: i,
            translate: s,
            wrapperEl: r
        } = e;
    if (t.virtualTranslate) return i ? -s : s;
    if (t.cssMode) return s;
    let o = aA(r, n);
    return o += e.cssOverflowAdjustment(), i && (o = -o), o || 0
}

function WH(n, e) {
    const t = this,
        {
            rtlTranslate: i,
            params: s,
            wrapperEl: r,
            progress: o
        } = t;
    let a = 0,
        l = 0;
    const c = 0;
    t.isHorizontal() ? a = i ? -n : n : l = n, s.roundLengths && (a = Math.floor(a), l = Math.floor(l)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? a : l, s.cssMode ? r[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -a : -l : s.virtualTranslate || (t.isHorizontal() ? a -= t.cssOverflowAdjustment() : l -= t.cssOverflowAdjustment(), r.style.transform = `translate3d(${a}px, ${l}px, ${c}px)`);
    let u;
    const d = t.maxTranslate() - t.minTranslate();
    d === 0 ? u = 0 : u = (n - t.minTranslate()) / d, u !== o && t.updateProgress(n), t.emit("setTranslate", t.translate, e)
}

function qH() {
    return -this.snapGrid[0]
}

function $H() {
    return -this.snapGrid[this.snapGrid.length - 1]
}

function jH(n, e, t, i, s) {
    n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), i === void 0 && (i = !0);
    const r = this,
        {
            params: o,
            wrapperEl: a
        } = r;
    if (r.animating && o.preventInteractionOnTransition) return !1;
    const l = r.minTranslate(),
        c = r.maxTranslate();
    let u;
    if (i && n > l ? u = l : i && n < c ? u = c : u = n, r.updateProgress(u), o.cssMode) {
        const d = r.isHorizontal();
        if (e === 0) a[d ? "scrollLeft" : "scrollTop"] = -u;
        else {
            if (!r.support.smoothScroll) return bS({
                swiper: r,
                targetPosition: -u,
                side: d ? "left" : "top"
            }), !0;
            a.scrollTo({
                [d ? "left" : "top"]: -u,
                behavior: "smooth"
            })
        }
        return !0
    }
    return e === 0 ? (r.setTransition(0), r.setTranslate(u), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionEnd"))) : (r.setTransition(e), r.setTranslate(u), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (h) {
        !r || r.destroyed || h.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, r.animating = !1, t && r.emit("transitionEnd"))
    }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0
}
var YH = {
    getTranslate: VH,
    setTranslate: WH,
    minTranslate: qH,
    maxTranslate: $H,
    translateTo: jH
};

function XH(n, e) {
    const t = this;
    t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${n}ms`, t.wrapperEl.style.transitionDelay = n === 0 ? "0ms" : ""), t.emit("setTransition", n, e)
}

function ES(n) {
    let {
        swiper: e,
        runCallbacks: t,
        direction: i,
        step: s
    } = n;
    const {
        activeIndex: r,
        previousIndex: o
    } = e;
    let a = i;
    if (a || (r > o ? a = "next" : r < o ? a = "prev" : a = "reset"), e.emit(`transition${s}`), t && r !== o) {
        if (a === "reset") {
            e.emit(`slideResetTransition${s}`);
            return
        }
        e.emit(`slideChangeTransition${s}`), a === "next" ? e.emit(`slideNextTransition${s}`) : e.emit(`slidePrevTransition${s}`)
    }
}

function KH(n, e) {
    n === void 0 && (n = !0);
    const t = this,
        {
            params: i
        } = t;
    i.cssMode || (i.autoHeight && t.updateAutoHeight(), ES({
        swiper: t,
        runCallbacks: n,
        direction: e,
        step: "Start"
    }))
}

function JH(n, e) {
    n === void 0 && (n = !0);
    const t = this,
        {
            params: i
        } = t;
    t.animating = !1, !i.cssMode && (t.setTransition(0), ES({
        swiper: t,
        runCallbacks: n,
        direction: e,
        step: "End"
    }))
}
var ZH = {
    setTransition: XH,
    transitionStart: KH,
    transitionEnd: JH
};

function e4(n, e, t, i, s) {
    n === void 0 && (n = 0), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10));
    const r = this;
    let o = n;
    o < 0 && (o = 0);
    const {
        params: a,
        snapGrid: l,
        slidesGrid: c,
        previousIndex: u,
        activeIndex: d,
        rtlTranslate: h,
        wrapperEl: f,
        enabled: m
    } = r;
    if (!m && !i && !s || r.destroyed || r.animating && a.preventInteractionOnTransition) return !1;
    typeof e > "u" && (e = r.params.speed);
    const g = Math.min(r.params.slidesPerGroupSkip, o);
    let A = g + Math.floor((o - g) / r.params.slidesPerGroup);
    A >= l.length && (A = l.length - 1);
    const p = -l[A];
    if (a.normalizeSlideIndex)
        for (let _ = 0; _ < c.length; _ += 1) {
            const b = -Math.floor(p * 100),
                w = Math.floor(c[_] * 100),
                E = Math.floor(c[_ + 1] * 100);
            typeof c[_ + 1] < "u" ? b >= w && b < E - (E - w) / 2 ? o = _ : b >= w && b < E && (o = _ + 1) : b >= w && (o = _)
        }
    if (r.initialized && o !== d && (!r.allowSlideNext && (h ? p > r.translate && p > r.minTranslate() : p < r.translate && p < r.minTranslate()) || !r.allowSlidePrev && p > r.translate && p > r.maxTranslate() && (d || 0) !== o)) return !1;
    o !== (u || 0) && t && r.emit("beforeSlideChangeStart"), r.updateProgress(p);
    let v;
    if (o > d ? v = "next" : o < d ? v = "prev" : v = "reset", h && -p === r.translate || !h && p === r.translate) return r.updateActiveIndex(o), a.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), a.effect !== "slide" && r.setTranslate(p), v !== "reset" && (r.transitionStart(t, v), r.transitionEnd(t, v)), !1;
    if (a.cssMode) {
        const _ = r.isHorizontal(),
            b = h ? p : -p;
        if (e === 0) {
            const w = r.virtual && r.params.virtual.enabled;
            w && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), w && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
                f[_ ? "scrollLeft" : "scrollTop"] = b
            })) : f[_ ? "scrollLeft" : "scrollTop"] = b, w && requestAnimationFrame(() => {
                r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1
            })
        } else {
            if (!r.support.smoothScroll) return bS({
                swiper: r,
                targetPosition: b,
                side: _ ? "left" : "top"
            }), !0;
            f.scrollTo({
                [_ ? "left" : "top"]: b,
                behavior: "smooth"
            })
        }
        return !0
    }
    return r.setTransition(e), r.setTranslate(p), r.updateActiveIndex(o), r.updateSlidesClasses(), r.emit("beforeTransitionStart", e, i), r.transitionStart(t, v), e === 0 ? r.transitionEnd(t, v) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (b) {
        !r || r.destroyed || b.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(t, v))
    }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0
}

function t4(n, e, t, i) {
    n === void 0 && (n = 0), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10));
    const s = this;
    if (s.destroyed) return;
    typeof e > "u" && (e = s.params.speed);
    const r = s.grid && s.params.grid && s.params.grid.rows > 1;
    let o = n;
    if (s.params.loop)
        if (s.virtual && s.params.virtual.enabled) o = o + s.virtual.slidesBefore;
        else {
            let a;
            if (r) {
                const h = o * s.params.grid.rows;
                a = s.slides.filter(f => f.getAttribute("data-swiper-slide-index") * 1 === h)[0].column
            } else a = s.getSlideIndexByData(o);
            const l = r ? Math.ceil(s.slides.length / s.params.grid.rows) : s.slides.length,
                {
                    centeredSlides: c
                } = s.params;
            let u = s.params.slidesPerView;
            u === "auto" ? u = s.slidesPerViewDynamic() : (u = Math.ceil(parseFloat(s.params.slidesPerView, 10)), c && u % 2 === 0 && (u = u + 1));
            let d = l - a < u;
            if (c && (d = d || a < Math.ceil(u / 2)), i && c && s.params.slidesPerView !== "auto" && !r && (d = !1), d) {
                const h = c ? a < s.activeIndex ? "prev" : "next" : a - s.activeIndex - 1 < s.params.slidesPerView ? "next" : "prev";
                s.loopFix({
                    direction: h,
                    slideTo: !0,
                    activeSlideIndex: h === "next" ? a + 1 : a - l + 1,
                    slideRealIndex: h === "next" ? s.realIndex : void 0
                })
            }
            if (r) {
                const h = o * s.params.grid.rows;
                o = s.slides.filter(f => f.getAttribute("data-swiper-slide-index") * 1 === h)[0].column
            } else o = s.getSlideIndexByData(o)
        }
    return requestAnimationFrame(() => {
        s.slideTo(o, e, t, i)
    }), s
}

function i4(n, e, t) {
    e === void 0 && (e = !0);
    const i = this,
        {
            enabled: s,
            params: r,
            animating: o
        } = i;
    if (!s || i.destroyed) return i;
    typeof n > "u" && (n = i.params.speed);
    let a = r.slidesPerGroup;
    r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (a = Math.max(i.slidesPerViewDynamic("current", !0), 1));
    const l = i.activeIndex < r.slidesPerGroupSkip ? 1 : a,
        c = i.virtual && r.virtual.enabled;
    if (r.loop) {
        if (o && !c && r.loopPreventsSliding) return !1;
        if (i.loopFix({
            direction: "next"
        }), i._clientLeft = i.wrapperEl.clientLeft, i.activeIndex === i.slides.length - 1 && r.cssMode) return requestAnimationFrame(() => {
            i.slideTo(i.activeIndex + l, n, e, t)
        }), !0
    }
    return r.rewind && i.isEnd ? i.slideTo(0, n, e, t) : i.slideTo(i.activeIndex + l, n, e, t)
}

function n4(n, e, t) {
    e === void 0 && (e = !0);
    const i = this,
        {
            params: s,
            snapGrid: r,
            slidesGrid: o,
            rtlTranslate: a,
            enabled: l,
            animating: c
        } = i;
    if (!l || i.destroyed) return i;
    typeof n > "u" && (n = i.params.speed);
    const u = i.virtual && s.virtual.enabled;
    if (s.loop) {
        if (c && !u && s.loopPreventsSliding) return !1;
        i.loopFix({
            direction: "prev"
        }), i._clientLeft = i.wrapperEl.clientLeft
    }
    const d = a ? i.translate : -i.translate;

    function h(p) {
        return p < 0 ? -Math.floor(Math.abs(p)) : Math.floor(p)
    }
    const f = h(d),
        m = r.map(p => h(p));
    let g = r[m.indexOf(f) - 1];
    if (typeof g > "u" && s.cssMode) {
        let p;
        r.forEach((v, _) => {
            f >= v && (p = _)
        }), typeof p < "u" && (g = r[p > 0 ? p - 1 : p])
    }
    let A = 0;
    if (typeof g < "u" && (A = o.indexOf(g), A < 0 && (A = i.activeIndex - 1), s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (A = A - i.slidesPerViewDynamic("previous", !0) + 1, A = Math.max(A, 0))), s.rewind && i.isBeginning) {
        const p = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1;
        return i.slideTo(p, n, e, t)
    } else if (s.loop && i.activeIndex === 0 && s.cssMode) return requestAnimationFrame(() => {
        i.slideTo(A, n, e, t)
    }), !0;
    return i.slideTo(A, n, e, t)
}

function s4(n, e, t) {
    e === void 0 && (e = !0);
    const i = this;
    if (!i.destroyed) return typeof n > "u" && (n = i.params.speed), i.slideTo(i.activeIndex, n, e, t)
}

function r4(n, e, t, i) {
    e === void 0 && (e = !0), i === void 0 && (i = .5);
    const s = this;
    if (s.destroyed) return;
    typeof n > "u" && (n = s.params.speed);
    let r = s.activeIndex;
    const o = Math.min(s.params.slidesPerGroupSkip, r),
        a = o + Math.floor((r - o) / s.params.slidesPerGroup),
        l = s.rtlTranslate ? s.translate : -s.translate;
    if (l >= s.snapGrid[a]) {
        const c = s.snapGrid[a],
            u = s.snapGrid[a + 1];
        l - c > (u - c) * i && (r += s.params.slidesPerGroup)
    } else {
        const c = s.snapGrid[a - 1],
            u = s.snapGrid[a];
        l - c <= (u - c) * i && (r -= s.params.slidesPerGroup)
    }
    return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, n, e, t)
}

function o4() {
    const n = this;
    if (n.destroyed) return;
    const {
        params: e,
        slidesEl: t
    } = n, i = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView;
    let s = n.clickedIndex,
        r;
    const o = n.isElement ? "swiper-slide" : `.${e.slideClass}`;
    if (e.loop) {
        if (n.animating) return;
        r = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? s < n.loopedSlides - i / 2 || s > n.slides.length - n.loopedSlides + i / 2 ? (n.loopFix(), s = n.getSlideIndex(Qi(t, `${o}[data-swiper-slide-index="${r}"]`)[0]), Ta(() => {
            n.slideTo(s)
        })) : n.slideTo(s) : s > n.slides.length - i ? (n.loopFix(), s = n.getSlideIndex(Qi(t, `${o}[data-swiper-slide-index="${r}"]`)[0]), Ta(() => {
            n.slideTo(s)
        })) : n.slideTo(s)
    } else n.slideTo(s)
}
var a4 = {
    slideTo: e4,
    slideToLoop: t4,
    slideNext: i4,
    slidePrev: n4,
    slideReset: s4,
    slideToClosest: r4,
    slideToClickedSlide: o4
};

function l4(n) {
    const e = this,
        {
            params: t,
            slidesEl: i
        } = e;
    if (!t.loop || e.virtual && e.params.virtual.enabled) return;
    const s = () => {
        Qi(i, `.${t.slideClass}, swiper-slide`).forEach((d, h) => {
            d.setAttribute("data-swiper-slide-index", h)
        })
    },
        r = e.grid && t.grid && t.grid.rows > 1,
        o = t.slidesPerGroup * (r ? t.grid.rows : 1),
        a = e.slides.length % o !== 0,
        l = r && e.slides.length % t.grid.rows !== 0,
        c = u => {
            for (let d = 0; d < u; d += 1) {
                const h = e.isElement ? Vn("swiper-slide", [t.slideBlankClass]) : Vn("div", [t.slideClass, t.slideBlankClass]);
                e.slidesEl.append(h)
            }
        };
    if (a) {
        if (t.loopAddBlankSlides) {
            const u = o - e.slides.length % o;
            c(u), e.recalcSlides(), e.updateSlides()
        } else vf("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        s()
    } else if (l) {
        if (t.loopAddBlankSlides) {
            const u = t.grid.rows - e.slides.length % t.grid.rows;
            c(u), e.recalcSlides(), e.updateSlides()
        } else vf("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        s()
    } else s();
    e.loopFix({
        slideRealIndex: n,
        direction: t.centeredSlides ? void 0 : "next"
    })
}

function c4(n) {
    let {
        slideRealIndex: e,
        slideTo: t = !0,
        direction: i,
        setTranslate: s,
        activeSlideIndex: r,
        byController: o,
        byMousewheel: a
    } = n === void 0 ? {} : n;
    const l = this;
    if (!l.params.loop) return;
    l.emit("beforeLoopFix");
    const {
        slides: c,
        allowSlidePrev: u,
        allowSlideNext: d,
        slidesEl: h,
        params: f
    } = l, {
        centeredSlides: m
    } = f;
    if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && f.virtual.enabled) {
        t && (!f.centeredSlides && l.snapIndex === 0 ? l.slideTo(l.virtual.slides.length, 0, !1, !0) : f.centeredSlides && l.snapIndex < f.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0)), l.allowSlidePrev = u, l.allowSlideNext = d, l.emit("loopFix");
        return
    }
    let g = f.slidesPerView;
    g === "auto" ? g = l.slidesPerViewDynamic() : (g = Math.ceil(parseFloat(f.slidesPerView, 10)), m && g % 2 === 0 && (g = g + 1));
    const A = f.slidesPerGroupAuto ? g : f.slidesPerGroup;
    let p = A;
    p % A !== 0 && (p += A - p % A), p += f.loopAdditionalSlides, l.loopedSlides = p;
    const v = l.grid && f.grid && f.grid.rows > 1;
    c.length < g + p ? vf("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : v && f.grid.fill === "row" && vf("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const _ = [],
        b = [];
    let w = l.activeIndex;
    typeof r > "u" ? r = l.getSlideIndex(c.filter(R => R.classList.contains(f.slideActiveClass))[0]) : w = r;
    const E = i === "next" || !i,
        C = i === "prev" || !i;
    let S = 0,
        x = 0;
    const y = v ? Math.ceil(c.length / f.grid.rows) : c.length,
        T = (v ? c[r].column : r) + (m && typeof s > "u" ? -g / 2 + .5 : 0);
    if (T < p) {
        S = Math.max(p - T, A);
        for (let R = 0; R < p - T; R += 1) {
            const D = R - Math.floor(R / y) * y;
            if (v) {
                const U = y - D - 1;
                for (let Q = c.length - 1; Q >= 0; Q -= 1) c[Q].column === U && _.push(Q)
            } else _.push(y - D - 1)
        }
    } else if (T + g > y - p) {
        x = Math.max(T - (y - p * 2), A);
        for (let R = 0; R < x; R += 1) {
            const D = R - Math.floor(R / y) * y;
            v ? c.forEach((U, Q) => {
                U.column === D && b.push(Q)
            }) : b.push(D)
        }
    }
    if (l.__preventObserver__ = !0, requestAnimationFrame(() => {
        l.__preventObserver__ = !1
    }), C && _.forEach(R => {
        c[R].swiperLoopMoveDOM = !0, h.prepend(c[R]), c[R].swiperLoopMoveDOM = !1
    }), E && b.forEach(R => {
        c[R].swiperLoopMoveDOM = !0, h.append(c[R]), c[R].swiperLoopMoveDOM = !1
    }), l.recalcSlides(), f.slidesPerView === "auto" ? l.updateSlides() : v && (_.length > 0 && C || b.length > 0 && E) && l.slides.forEach((R, D) => {
        l.grid.updateSlide(D, R, l.slides)
    }), f.watchSlidesProgress && l.updateSlidesOffset(), t) {
        if (_.length > 0 && C) {
            if (typeof e > "u") {
                const R = l.slidesGrid[w],
                    U = l.slidesGrid[w + S] - R;
                a ? l.setTranslate(l.translate - U) : (l.slideTo(w + Math.ceil(S), 0, !1, !0), s && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - U, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - U))
            } else if (s) {
                const R = v ? _.length / f.grid.rows : _.length;
                l.slideTo(l.activeIndex + R, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate
            }
        } else if (b.length > 0 && E)
            if (typeof e > "u") {
                const R = l.slidesGrid[w],
                    U = l.slidesGrid[w - x] - R;
                a ? l.setTranslate(l.translate - U) : (l.slideTo(w - x, 0, !1, !0), s && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - U, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - U))
            } else {
                const R = v ? b.length / f.grid.rows : b.length;
                l.slideTo(l.activeIndex - R, 0, !1, !0)
            }
    }
    if (l.allowSlidePrev = u, l.allowSlideNext = d, l.controller && l.controller.control && !o) {
        const R = {
            slideRealIndex: e,
            direction: i,
            setTranslate: s,
            activeSlideIndex: r,
            byController: !0
        };
        Array.isArray(l.controller.control) ? l.controller.control.forEach(D => {
            !D.destroyed && D.params.loop && D.loopFix({
                ...R,
                slideTo: D.params.slidesPerView === f.slidesPerView ? t : !1
            })
        }) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
            ...R,
            slideTo: l.controller.control.params.slidesPerView === f.slidesPerView ? t : !1
        })
    }
    l.emit("loopFix")
}

function u4() {
    const n = this,
        {
            params: e,
            slidesEl: t
        } = n;
    if (!e.loop || n.virtual && n.params.virtual.enabled) return;
    n.recalcSlides();
    const i = [];
    n.slides.forEach(s => {
        const r = typeof s.swiperSlideIndex > "u" ? s.getAttribute("data-swiper-slide-index") * 1 : s.swiperSlideIndex;
        i[r] = s
    }), n.slides.forEach(s => {
        s.removeAttribute("data-swiper-slide-index")
    }), i.forEach(s => {
        t.append(s)
    }), n.recalcSlides(), n.slideTo(n.realIndex, 0)
}
var d4 = {
    loopCreate: l4,
    loopFix: c4,
    loopDestroy: u4
};

function h4(n) {
    const e = this;
    if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return;
    const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
    e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = n ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => {
        e.__preventObserver__ = !1
    })
}

function f4() {
    const n = this;
    n.params.watchOverflow && n.isLocked || n.params.cssMode || (n.isElement && (n.__preventObserver__ = !0), n[n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", n.isElement && requestAnimationFrame(() => {
        n.__preventObserver__ = !1
    }))
}
var p4 = {
    setGrabCursor: h4,
    unsetGrabCursor: f4
};

function m4(n, e) {
    e === void 0 && (e = this);

    function t(i) {
        if (!i || i === zi() || i === ii()) return null;
        i.assignedSlot && (i = i.assignedSlot);
        const s = i.closest(n);
        return !s && !i.getRootNode ? null : s || t(i.getRootNode().host)
    }
    return t(e)
}

function Px(n, e, t) {
    const i = ii(),
        {
            params: s
        } = n,
        r = s.edgeSwipeDetection,
        o = s.edgeSwipeThreshold;
    return r && (t <= o || t >= i.innerWidth - o) ? r === "prevent" ? (e.preventDefault(), !0) : !1 : !0
}

function g4(n) {
    const e = this,
        t = zi();
    let i = n;
    i.originalEvent && (i = i.originalEvent);
    const s = e.touchEventsData;
    if (i.type === "pointerdown") {
        if (s.pointerId !== null && s.pointerId !== i.pointerId) return;
        s.pointerId = i.pointerId
    } else i.type === "touchstart" && i.targetTouches.length === 1 && (s.touchId = i.targetTouches[0].identifier);
    if (i.type === "touchstart") {
        Px(e, i, i.targetTouches[0].pageX);
        return
    }
    const {
        params: r,
        touches: o,
        enabled: a
    } = e;
    if (!a || !r.simulateTouch && i.pointerType === "mouse" || e.animating && r.preventInteractionOnTransition) return;
    !e.animating && r.cssMode && r.loop && e.loopFix();
    let l = i.target;
    if (r.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(l) || "which" in i && i.which === 3 || "button" in i && i.button > 0 || s.isTouched && s.isMoved) return;
    const c = !!r.noSwipingClass && r.noSwipingClass !== "",
        u = i.composedPath ? i.composedPath() : i.path;
    c && i.target && i.target.shadowRoot && u && (l = u[0]);
    const d = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`,
        h = !!(i.target && i.target.shadowRoot);
    if (r.noSwiping && (h ? m4(d, l) : l.closest(d))) {
        e.allowClick = !0;
        return
    }
    if (r.swipeHandler && !l.closest(r.swipeHandler)) return;
    o.currentX = i.pageX, o.currentY = i.pageY;
    const f = o.currentX,
        m = o.currentY;
    if (!Px(e, i, f)) return;
    Object.assign(s, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }), o.startX = f, o.startY = m, s.touchStartTime = ns(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, r.threshold > 0 && (s.allowThresholdMove = !1);
    let g = !0;
    l.matches(s.focusableElements) && (g = !1, l.nodeName === "SELECT" && (s.isTouched = !1)), t.activeElement && t.activeElement.matches(s.focusableElements) && t.activeElement !== l && t.activeElement.blur();
    const A = g && e.allowTouchMove && r.touchStartPreventDefault;
    (r.touchStartForcePreventDefault || A) && !l.isContentEditable && i.preventDefault(), r.freeMode && r.freeMode.enabled && e.freeMode && e.animating && !r.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", i)
}

function A4(n) {
    const e = zi(),
        t = this,
        i = t.touchEventsData,
        {
            params: s,
            touches: r,
            rtlTranslate: o,
            enabled: a
        } = t;
    if (!a || !s.simulateTouch && n.pointerType === "mouse") return;
    let l = n;
    if (l.originalEvent && (l = l.originalEvent), l.type === "pointermove" && (i.touchId !== null || l.pointerId !== i.pointerId)) return;
    let c;
    if (l.type === "touchmove") {
        if (c = [...l.changedTouches].filter(E => E.identifier === i.touchId)[0], !c || c.identifier !== i.touchId) return
    } else c = l;
    if (!i.isTouched) {
        i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", l);
        return
    }
    const u = c.pageX,
        d = c.pageY;
    if (l.preventedByNestedSwiper) {
        r.startX = u, r.startY = d;
        return
    }
    if (!t.allowTouchMove) {
        l.target.matches(i.focusableElements) || (t.allowClick = !1), i.isTouched && (Object.assign(r, {
            startX: u,
            startY: d,
            currentX: u,
            currentY: d
        }), i.touchStartTime = ns());
        return
    }
    if (s.touchReleaseOnEdges && !s.loop) {
        if (t.isVertical()) {
            if (d < r.startY && t.translate <= t.maxTranslate() || d > r.startY && t.translate >= t.minTranslate()) {
                i.isTouched = !1, i.isMoved = !1;
                return
            }
        } else if (u < r.startX && t.translate <= t.maxTranslate() || u > r.startX && t.translate >= t.minTranslate()) return
    }
    if (e.activeElement && l.target === e.activeElement && l.target.matches(i.focusableElements)) {
        i.isMoved = !0, t.allowClick = !1;
        return
    }
    i.allowTouchCallbacks && t.emit("touchMove", l), r.previousX = r.currentX, r.previousY = r.currentY, r.currentX = u, r.currentY = d;
    const h = r.currentX - r.startX,
        f = r.currentY - r.startY;
    if (t.params.threshold && Math.sqrt(h ** 2 + f ** 2) < t.params.threshold) return;
    if (typeof i.isScrolling > "u") {
        let E;
        t.isHorizontal() && r.currentY === r.startY || t.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : h * h + f * f >= 25 && (E = Math.atan2(Math.abs(f), Math.abs(h)) * 180 / Math.PI, i.isScrolling = t.isHorizontal() ? E > s.touchAngle : 90 - E > s.touchAngle)
    }
    if (i.isScrolling && t.emit("touchMoveOpposite", l), typeof i.startMoving > "u" && (r.currentX !== r.startX || r.currentY !== r.startY) && (i.startMoving = !0), i.isScrolling || l.type === "touchmove" && i.preventTouchMoveFromPointerMove) {
        i.isTouched = !1;
        return
    }
    if (!i.startMoving) return;
    t.allowClick = !1, !s.cssMode && l.cancelable && l.preventDefault(), s.touchMoveStopPropagation && !s.nested && l.stopPropagation();
    let m = t.isHorizontal() ? h : f,
        g = t.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY;
    s.oneWayMovement && (m = Math.abs(m) * (o ? 1 : -1), g = Math.abs(g) * (o ? 1 : -1)), r.diff = m, m *= s.touchRatio, o && (m = -m, g = -g);
    const A = t.touchesDirection;
    t.swipeDirection = m > 0 ? "prev" : "next", t.touchesDirection = g > 0 ? "prev" : "next";
    const p = t.params.loop && !s.cssMode,
        v = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev;
    if (!i.isMoved) {
        if (p && v && t.loopFix({
            direction: t.swipeDirection
        }), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) {
            const E = new window.CustomEvent("transitionend", {
                bubbles: !0,
                cancelable: !0
            });
            t.wrapperEl.dispatchEvent(E)
        }
        i.allowMomentumBounce = !1, s.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", l)
    }
    let _;
    if (new Date().getTime(), i.isMoved && i.allowThresholdMove && A !== t.touchesDirection && p && v && Math.abs(m) >= 1) {
        Object.assign(r, {
            startX: u,
            startY: d,
            currentX: u,
            currentY: d,
            startTranslate: i.currentTranslate
        }), i.loopSwapReset = !0, i.startTranslate = i.currentTranslate;
        return
    }
    t.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = m + i.startTranslate;
    let b = !0,
        w = s.resistanceRatio;
    if (s.touchReleaseOnEdges && (w = 0), m > 0 ? (p && v && !_ && i.allowThresholdMove && i.currentTranslate > (s.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] : t.minTranslate()) && t.loopFix({
        direction: "prev",
        setTranslate: !0,
        activeSlideIndex: 0
    }), i.currentTranslate > t.minTranslate() && (b = !1, s.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + m) ** w))) : m < 0 && (p && v && !_ && i.allowThresholdMove && i.currentTranslate < (s.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] : t.maxTranslate()) && t.loopFix({
        direction: "next",
        setTranslate: !0,
        activeSlideIndex: t.slides.length - (s.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(s.slidesPerView, 10)))
    }), i.currentTranslate < t.maxTranslate() && (b = !1, s.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - m) ** w))), b && (l.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (i.currentTranslate = i.startTranslate), s.threshold > 0)
        if (Math.abs(m) > s.threshold || i.allowThresholdMove) {
            if (!i.allowThresholdMove) {
                i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, r.diff = t.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY;
                return
            }
        } else {
            i.currentTranslate = i.startTranslate;
            return
        } !s.followFinger || s.cssMode || ((s.freeMode && s.freeMode.enabled && t.freeMode || s.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), s.freeMode && s.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate))
}

function _4(n) {
    const e = this,
        t = e.touchEventsData;
    let i = n;
    i.originalEvent && (i = i.originalEvent);
    let s;
    if (i.type === "touchend" || i.type === "touchcancel") {
        if (s = [...i.changedTouches].filter(w => w.identifier === t.touchId)[0], !s || s.identifier !== t.touchId) return
    } else {
        if (t.touchId !== null || i.pointerId !== t.pointerId) return;
        s = i
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type) && !(["pointercancel", "contextmenu"].includes(i.type) && (e.browser.isSafari || e.browser.isWebView))) return;
    t.pointerId = null, t.touchId = null;
    const {
        params: o,
        touches: a,
        rtlTranslate: l,
        slidesGrid: c,
        enabled: u
    } = e;
    if (!u || !o.simulateTouch && i.pointerType === "mouse") return;
    if (t.allowTouchCallbacks && e.emit("touchEnd", i), t.allowTouchCallbacks = !1, !t.isTouched) {
        t.isMoved && o.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1;
        return
    }
    o.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
    const d = ns(),
        h = d - t.touchStartTime;
    if (e.allowClick) {
        const w = i.path || i.composedPath && i.composedPath();
        e.updateClickedSlide(w && w[0] || i.target, w), e.emit("tap click", i), h < 300 && d - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", i)
    }
    if (t.lastClickTime = ns(), Ta(() => {
        e.destroyed || (e.allowClick = !0)
    }), !t.isTouched || !t.isMoved || !e.swipeDirection || a.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) {
        t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
        return
    }
    t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
    let f;
    if (o.followFinger ? f = l ? e.translate : -e.translate : f = -t.currentTranslate, o.cssMode) return;
    if (o.freeMode && o.freeMode.enabled) {
        e.freeMode.onTouchEnd({
            currentPos: f
        });
        return
    }
    const m = f >= -e.maxTranslate() && !e.params.loop;
    let g = 0,
        A = e.slidesSizesGrid[0];
    for (let w = 0; w < c.length; w += w < o.slidesPerGroupSkip ? 1 : o.slidesPerGroup) {
        const E = w < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
        typeof c[w + E] < "u" ? (m || f >= c[w] && f < c[w + E]) && (g = w, A = c[w + E] - c[w]) : (m || f >= c[w]) && (g = w, A = c[c.length - 1] - c[c.length - 2])
    }
    let p = null,
        v = null;
    o.rewind && (e.isBeginning ? v = o.virtual && o.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (p = 0));
    const _ = (f - c[g]) / A,
        b = g < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
    if (h > o.longSwipesMs) {
        if (!o.longSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.swipeDirection === "next" && (_ >= o.longSwipesRatio ? e.slideTo(o.rewind && e.isEnd ? p : g + b) : e.slideTo(g)), e.swipeDirection === "prev" && (_ > 1 - o.longSwipesRatio ? e.slideTo(g + b) : v !== null && _ < 0 && Math.abs(_) > o.longSwipesRatio ? e.slideTo(v) : e.slideTo(g))
    } else {
        if (!o.shortSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.navigation && (i.target === e.navigation.nextEl || i.target === e.navigation.prevEl) ? i.target === e.navigation.nextEl ? e.slideTo(g + b) : e.slideTo(g) : (e.swipeDirection === "next" && e.slideTo(p !== null ? p : g + b), e.swipeDirection === "prev" && e.slideTo(v !== null ? v : g))
    }
}

function Dx() {
    const n = this,
        {
            params: e,
            el: t
        } = n;
    if (t && t.offsetWidth === 0) return;
    e.breakpoints && n.setBreakpoint();
    const {
        allowSlideNext: i,
        allowSlidePrev: s,
        snapGrid: r
    } = n, o = n.virtual && n.params.virtual.enabled;
    n.allowSlideNext = !0, n.allowSlidePrev = !0, n.updateSize(), n.updateSlides(), n.updateSlidesClasses();
    const a = o && e.loop;
    (e.slidesPerView === "auto" || e.slidesPerView > 1) && n.isEnd && !n.isBeginning && !n.params.centeredSlides && !a ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.params.loop && !o ? n.slideToLoop(n.realIndex, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0), n.autoplay && n.autoplay.running && n.autoplay.paused && (clearTimeout(n.autoplay.resizeTimeout), n.autoplay.resizeTimeout = setTimeout(() => {
        n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.resume()
    }, 500)), n.allowSlidePrev = s, n.allowSlideNext = i, n.params.watchOverflow && r !== n.snapGrid && n.checkOverflow()
}

function v4(n) {
    const e = this;
    e.enabled && (e.allowClick || (e.params.preventClicks && n.preventDefault(), e.params.preventClicksPropagation && e.animating && (n.stopPropagation(), n.stopImmediatePropagation())))
}

function b4() {
    const n = this,
        {
            wrapperEl: e,
            rtlTranslate: t,
            enabled: i
        } = n;
    if (!i) return;
    n.previousTranslate = n.translate, n.isHorizontal() ? n.translate = -e.scrollLeft : n.translate = -e.scrollTop, n.translate === 0 && (n.translate = 0), n.updateActiveIndex(), n.updateSlidesClasses();
    let s;
    const r = n.maxTranslate() - n.minTranslate();
    r === 0 ? s = 0 : s = (n.translate - n.minTranslate()) / r, s !== n.progress && n.updateProgress(t ? -n.translate : n.translate), n.emit("setTranslate", n.translate, !1)
}

function x4(n) {
    const e = this;
    Fh(e, n.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update()
}

function y4() {
    const n = this;
    n.documentTouchHandlerProceeded || (n.documentTouchHandlerProceeded = !0, n.params.touchReleaseOnEdges && (n.el.style.touchAction = "auto"))
}
const wS = (n, e) => {
    const t = zi(),
        {
            params: i,
            el: s,
            wrapperEl: r,
            device: o
        } = n,
        a = !!i.nested,
        l = e === "on" ? "addEventListener" : "removeEventListener",
        c = e;
    t[l]("touchstart", n.onDocumentTouchStart, {
        passive: !1,
        capture: a
    }), s[l]("touchstart", n.onTouchStart, {
        passive: !1
    }), s[l]("pointerdown", n.onTouchStart, {
        passive: !1
    }), t[l]("touchmove", n.onTouchMove, {
        passive: !1,
        capture: a
    }), t[l]("pointermove", n.onTouchMove, {
        passive: !1,
        capture: a
    }), t[l]("touchend", n.onTouchEnd, {
        passive: !0
    }), t[l]("pointerup", n.onTouchEnd, {
        passive: !0
    }), t[l]("pointercancel", n.onTouchEnd, {
        passive: !0
    }), t[l]("touchcancel", n.onTouchEnd, {
        passive: !0
    }), t[l]("pointerout", n.onTouchEnd, {
        passive: !0
    }), t[l]("pointerleave", n.onTouchEnd, {
        passive: !0
    }), t[l]("contextmenu", n.onTouchEnd, {
        passive: !0
    }), (i.preventClicks || i.preventClicksPropagation) && s[l]("click", n.onClick, !0), i.cssMode && r[l]("scroll", n.onScroll), i.updateOnWindowResize ? n[c](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Dx, !0) : n[c]("observerUpdate", Dx, !0), s[l]("load", n.onLoad, {
        capture: !0
    })
};

function E4() {
    const n = this,
        {
            params: e
        } = n;
    n.onTouchStart = g4.bind(n), n.onTouchMove = A4.bind(n), n.onTouchEnd = _4.bind(n), n.onDocumentTouchStart = y4.bind(n), e.cssMode && (n.onScroll = b4.bind(n)), n.onClick = v4.bind(n), n.onLoad = x4.bind(n), wS(n, "on")
}

function w4() {
    wS(this, "off")
}
var C4 = {
    attachEvents: E4,
    detachEvents: w4
};
const Lx = (n, e) => n.grid && e.grid && e.grid.rows > 1;

function S4() {
    const n = this,
        {
            realIndex: e,
            initialized: t,
            params: i,
            el: s
        } = n,
        r = i.breakpoints;
    if (!r || r && Object.keys(r).length === 0) return;
    const o = n.getBreakpoint(r, n.params.breakpointsBase, n.el);
    if (!o || n.currentBreakpoint === o) return;
    const l = (o in r ? r[o] : void 0) || n.originalParams,
        c = Lx(n, i),
        u = Lx(n, l),
        d = n.params.grabCursor,
        h = l.grabCursor,
        f = i.enabled;
    c && !u ? (s.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), n.emitContainerClasses()) : !c && u && (s.classList.add(`${i.containerModifierClass}grid`), (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && i.grid.fill === "column") && s.classList.add(`${i.containerModifierClass}grid-column`), n.emitContainerClasses()), d && !h ? n.unsetGrabCursor() : !d && h && n.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(_ => {
        if (typeof l[_] > "u") return;
        const b = i[_] && i[_].enabled,
            w = l[_] && l[_].enabled;
        b && !w && n[_].disable(), !b && w && n[_].enable()
    });
    const m = l.direction && l.direction !== i.direction,
        g = i.loop && (l.slidesPerView !== i.slidesPerView || m),
        A = i.loop;
    m && t && n.changeDirection(), Un(n.params, l);
    const p = n.params.enabled,
        v = n.params.loop;
    Object.assign(n, {
        allowTouchMove: n.params.allowTouchMove,
        allowSlideNext: n.params.allowSlideNext,
        allowSlidePrev: n.params.allowSlidePrev
    }), f && !p ? n.disable() : !f && p && n.enable(), n.currentBreakpoint = o, n.emit("_beforeBreakpoint", l), t && (g ? (n.loopDestroy(), n.loopCreate(e), n.updateSlides()) : !A && v ? (n.loopCreate(e), n.updateSlides()) : A && !v && n.loopDestroy()), n.emit("breakpoint", l)
}

function M4(n, e, t) {
    if (e === void 0 && (e = "window"), !n || e === "container" && !t) return;
    let i = !1;
    const s = ii(),
        r = e === "window" ? s.innerHeight : t.clientHeight,
        o = Object.keys(n).map(a => {
            if (typeof a == "string" && a.indexOf("@") === 0) {
                const l = parseFloat(a.substr(1));
                return {
                    value: r * l,
                    point: a
                }
            }
            return {
                value: a,
                point: a
            }
        });
    o.sort((a, l) => parseInt(a.value, 10) - parseInt(l.value, 10));
    for (let a = 0; a < o.length; a += 1) {
        const {
            point: l,
            value: c
        } = o[a];
        e === "window" ? s.matchMedia(`(min-width: ${c}px)`).matches && (i = l) : c <= t.clientWidth && (i = l)
    }
    return i || "max"
}
var T4 = {
    setBreakpoint: S4,
    getBreakpoint: M4
};

function I4(n, e) {
    const t = [];
    return n.forEach(i => {
        typeof i == "object" ? Object.keys(i).forEach(s => {
            i[s] && t.push(e + s)
        }) : typeof i == "string" && t.push(e + i)
    }), t
}

function B4() {
    const n = this,
        {
            classNames: e,
            params: t,
            rtl: i,
            el: s,
            device: r
        } = n,
        o = I4(["initialized", t.direction, {
            "free-mode": n.params.freeMode && t.freeMode.enabled
        }, {
                autoheight: t.autoHeight
            }, {
                rtl: i
            }, {
                grid: t.grid && t.grid.rows > 1
            }, {
                "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
            }, {
                android: r.android
            }, {
                ios: r.ios
            }, {
                "css-mode": t.cssMode
            }, {
                centered: t.cssMode && t.centeredSlides
            }, {
                "watch-progress": t.watchSlidesProgress
            }], t.containerModifierClass);
    e.push(...o), s.classList.add(...e), n.emitContainerClasses()
}

function R4() {
    const n = this,
        {
            el: e,
            classNames: t
        } = n;
    e.classList.remove(...t), n.emitContainerClasses()
}
var P4 = {
    addClasses: B4,
    removeClasses: R4
};

function D4() {
    const n = this,
        {
            isLocked: e,
            params: t
        } = n,
        {
            slidesOffsetBefore: i
        } = t;
    if (i) {
        const s = n.slides.length - 1,
            r = n.slidesGrid[s] + n.slidesSizesGrid[s] + i * 2;
        n.isLocked = n.size > r
    } else n.isLocked = n.snapGrid.length === 1;
    t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked), t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked), e && e !== n.isLocked && (n.isEnd = !1), e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock")
}
var L4 = {
    checkOverflow: D4
},
    uA = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        swiperElementNodeName: "SWIPER-CONTAINER",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        eventsPrefix: "swiper",
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopAddBlankSlides: !0,
        loopAdditionalSlides: 0,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-blank",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideFullyVisibleClass: "swiper-slide-fully-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

function k4(n, e) {
    return function (i) {
        i === void 0 && (i = {});
        const s = Object.keys(i)[0],
            r = i[s];
        if (typeof r != "object" || r === null) {
            Un(e, i);
            return
        }
        if (n[s] === !0 && (n[s] = {
            enabled: !0
        }), s === "navigation" && n[s] && n[s].enabled && !n[s].prevEl && !n[s].nextEl && (n[s].auto = !0), ["pagination", "scrollbar"].indexOf(s) >= 0 && n[s] && n[s].enabled && !n[s].el && (n[s].auto = !0), !(s in n && "enabled" in r)) {
            Un(e, i);
            return
        }
        typeof n[s] == "object" && !("enabled" in n[s]) && (n[s].enabled = !0), n[s] || (n[s] = {
            enabled: !1
        }), Un(e, i)
    }
}
const Lm = {
    eventsEmitter: PH,
    update: HH,
    translate: YH,
    transition: ZH,
    slide: a4,
    loop: d4,
    grabCursor: p4,
    events: C4,
    breakpoints: T4,
    checkOverflow: L4,
    classes: P4
},
    km = {};
class Nn {
    constructor() {
        let e, t;
        for (var i = arguments.length, s = new Array(i), r = 0; r < i; r++) s[r] = arguments[r];
        s.length === 1 && s[0].constructor && Object.prototype.toString.call(s[0]).slice(8, -1) === "Object" ? t = s[0] : [e, t] = s, t || (t = {}), t = Un({}, t), e && !t.el && (t.el = e);
        const o = zi();
        if (t.el && typeof t.el == "string" && o.querySelectorAll(t.el).length > 1) {
            const u = [];
            return o.querySelectorAll(t.el).forEach(d => {
                const h = Un({}, t, {
                    el: d
                });
                u.push(new Nn(h))
            }), u
        }
        const a = this;
        a.__swiper__ = !0, a.support = xS(), a.device = yS({
            userAgent: t.userAgent
        }), a.browser = IH(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], t.modules && Array.isArray(t.modules) && a.modules.push(...t.modules);
        const l = {};
        a.modules.forEach(u => {
            u({
                params: t,
                swiper: a,
                extendParams: k4(t, l),
                on: a.on.bind(a),
                once: a.once.bind(a),
                off: a.off.bind(a),
                emit: a.emit.bind(a)
            })
        });
        const c = Un({}, uA, l);
        return a.params = Un({}, c, km, t), a.originalParams = Un({}, a.params), a.passedParams = Un({}, t), a.params && a.params.on && Object.keys(a.params.on).forEach(u => {
            a.on(u, a.params.on[u])
        }), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, {
            enabled: a.params.enabled,
            el: e,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return a.params.direction === "horizontal"
            },
            isVertical() {
                return a.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
            },
            allowSlideNext: a.params.allowSlideNext,
            allowSlidePrev: a.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: a.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: a.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }), a.emit("_swiper"), a.params.init && a.init(), a
    }
    getDirectionLabel(e) {
        return this.isHorizontal() ? e : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[e]
    }
    getSlideIndex(e) {
        const {
            slidesEl: t,
            params: i
        } = this, s = Qi(t, `.${i.slideClass}, swiper-slide`), r = Qu(s[0]);
        return Qu(e) - r
    }
    getSlideIndexByData(e) {
        return this.getSlideIndex(this.slides.filter(t => t.getAttribute("data-swiper-slide-index") * 1 === e)[0])
    }
    recalcSlides() {
        const e = this,
            {
                slidesEl: t,
                params: i
            } = e;
        e.slides = Qi(t, `.${i.slideClass}, swiper-slide`)
    }
    enable() {
        const e = this;
        e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
    }
    disable() {
        const e = this;
        e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
    }
    setProgress(e, t) {
        const i = this;
        e = Math.min(Math.max(e, 0), 1);
        const s = i.minTranslate(),
            o = (i.maxTranslate() - s) * e + s;
        i.translateTo(o, typeof t > "u" ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses()
    }
    emitContainerClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const t = e.el.className.split(" ").filter(i => i.indexOf("swiper") === 0 || i.indexOf(e.params.containerModifierClass) === 0);
        e.emit("_containerClasses", t.join(" "))
    }
    getSlideClasses(e) {
        const t = this;
        return t.destroyed ? "" : e.className.split(" ").filter(i => i.indexOf("swiper-slide") === 0 || i.indexOf(t.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const t = [];
        e.slides.forEach(i => {
            const s = e.getSlideClasses(i);
            t.push({
                slideEl: i,
                classNames: s
            }), e.emit("_slideClass", i, s)
        }), e.emit("_slideClasses", t)
    }
    slidesPerViewDynamic(e, t) {
        e === void 0 && (e = "current"), t === void 0 && (t = !1);
        const i = this,
            {
                params: s,
                slides: r,
                slidesGrid: o,
                slidesSizesGrid: a,
                size: l,
                activeIndex: c
            } = i;
        let u = 1;
        if (typeof s.slidesPerView == "number") return s.slidesPerView;
        if (s.centeredSlides) {
            let d = r[c] ? Math.ceil(r[c].swiperSlideSize) : 0,
                h;
            for (let f = c + 1; f < r.length; f += 1) r[f] && !h && (d += Math.ceil(r[f].swiperSlideSize), u += 1, d > l && (h = !0));
            for (let f = c - 1; f >= 0; f -= 1) r[f] && !h && (d += r[f].swiperSlideSize, u += 1, d > l && (h = !0))
        } else if (e === "current")
            for (let d = c + 1; d < r.length; d += 1)(t ? o[d] + a[d] - o[c] < l : o[d] - o[c] < l) && (u += 1);
        else
            for (let d = c - 1; d >= 0; d -= 1) o[c] - o[d] < l && (u += 1);
        return u
    }
    update() {
        const e = this;
        if (!e || e.destroyed) return;
        const {
            snapGrid: t,
            params: i
        } = e;
        i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(o => {
            o.complete && Fh(e, o)
        }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses();

        function s() {
            const o = e.rtlTranslate ? e.translate * -1 : e.translate,
                a = Math.min(Math.max(o, e.maxTranslate()), e.minTranslate());
            e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses()
        }
        let r;
        if (i.freeMode && i.freeMode.enabled && !i.cssMode) s(), i.autoHeight && e.updateAutoHeight();
        else {
            if ((i.slidesPerView === "auto" || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
                const o = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
                r = e.slideTo(o.length - 1, 0, !1, !0)
            } else r = e.slideTo(e.activeIndex, 0, !1, !0);
            r || s()
        }
        i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
    }
    changeDirection(e, t) {
        t === void 0 && (t = !0);
        const i = this,
            s = i.params.direction;
        return e || (e = s === "horizontal" ? "vertical" : "horizontal"), e === s || e !== "horizontal" && e !== "vertical" || (i.el.classList.remove(`${i.params.containerModifierClass}${s}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach(r => {
            e === "vertical" ? r.style.width = "" : r.style.height = ""
        }), i.emit("changeDirection"), t && i.update()), i
    }
    changeLanguageDirection(e) {
        const t = this;
        t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
    }
    mount(e) {
        const t = this;
        if (t.mounted) return !0;
        let i = e || t.params.el;
        if (typeof i == "string" && (i = document.querySelector(i)), !i) return !1;
        i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
        const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let o = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(s()) : Qi(i, s())[0];
        return !o && t.params.createElements && (o = Vn("div", t.params.wrapperClass), i.append(o), Qi(i, `.${t.params.slideClass}`).forEach(a => {
            o.append(a)
        })), Object.assign(t, {
            el: i,
            wrapperEl: o,
            slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : o,
            hostEl: t.isElement ? i.parentNode.host : i,
            mounted: !0,
            rtl: i.dir.toLowerCase() === "rtl" || uo(i, "direction") === "rtl",
            rtlTranslate: t.params.direction === "horizontal" && (i.dir.toLowerCase() === "rtl" || uo(i, "direction") === "rtl"),
            wrongRTL: uo(o, "display") === "-webkit-box"
        }), !0
    }
    init(e) {
        const t = this;
        if (t.initialized || t.mount(e) === !1) return t;
        t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
        const s = [...t.el.querySelectorAll('[loading="lazy"]')];
        return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach(r => {
            r.complete ? Fh(t, r) : r.addEventListener("load", o => {
                Fh(t, o.target)
            })
        }), cA(t), t.initialized = !0, cA(t), t.emit("init"), t.emit("afterInit"), t
    }
    destroy(e, t) {
        e === void 0 && (e = !0), t === void 0 && (t = !0);
        const i = this,
            {
                params: s,
                el: r,
                wrapperEl: o,
                slides: a
            } = i;
        return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), r.removeAttribute("style"), o.removeAttribute("style"), a && a.length && a.forEach(l => {
            l.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass), l.removeAttribute("style"), l.removeAttribute("data-swiper-slide-index")
        })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(l => {
            i.off(l)
        }), e !== !1 && (i.el.swiper = null, xH(i)), i.destroyed = !0), null
    }
    static extendDefaults(e) {
        Un(km, e)
    }
    static get extendedDefaults() {
        return km
    }
    static get defaults() {
        return uA
    }
    static installModule(e) {
        Nn.prototype.__modules__ || (Nn.prototype.__modules__ = []);
        const t = Nn.prototype.__modules__;
        typeof e == "function" && t.indexOf(e) < 0 && t.push(e)
    }
    static use(e) {
        return Array.isArray(e) ? (e.forEach(t => Nn.installModule(t)), Nn) : (Nn.installModule(e), Nn)
    }
}
Object.keys(Lm).forEach(n => {
    Object.keys(Lm[n]).forEach(e => {
        Nn.prototype[e] = Lm[n][e]
    })
});
Nn.use([BH, RH]);

function F4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    t({
        virtual: {
            enabled: !1,
            slides: [],
            cache: !0,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: !0,
            addSlidesBefore: 0,
            addSlidesAfter: 0
        }
    });
    let r;
    const o = zi();
    e.virtual = {
        cache: {},
        from: void 0,
        to: void 0,
        slides: [],
        offset: 0,
        slidesGrid: []
    };
    const a = o.createElement("div");

    function l(m, g) {
        const A = e.params.virtual;
        if (A.cache && e.virtual.cache[g]) return e.virtual.cache[g];
        let p;
        return A.renderSlide ? (p = A.renderSlide.call(e, m, g), typeof p == "string" && (a.innerHTML = p, p = a.children[0])) : e.isElement ? p = Vn("swiper-slide") : p = Vn("div", e.params.slideClass), p.setAttribute("data-swiper-slide-index", g), A.renderSlide || (p.innerHTML = m), A.cache && (e.virtual.cache[g] = p), p
    }

    function c(m, g) {
        const {
            slidesPerView: A,
            slidesPerGroup: p,
            centeredSlides: v,
            loop: _,
            initialSlide: b
        } = e.params;
        if (g && !_ && b > 0) return;
        const {
            addSlidesBefore: w,
            addSlidesAfter: E
        } = e.params.virtual, {
            from: C,
            to: S,
            slides: x,
            slidesGrid: y,
            offset: P
        } = e.virtual;
        e.params.cssMode || e.updateActiveIndex();
        const T = e.activeIndex || 0;
        let R;
        e.rtlTranslate ? R = "right" : R = e.isHorizontal() ? "left" : "top";
        let D, U;
        v ? (D = Math.floor(A / 2) + p + E, U = Math.floor(A / 2) + p + w) : (D = A + (p - 1) + E, U = (_ ? A : p) + w);
        let Q = T - U,
            F = T + D;
        _ || (Q = Math.max(Q, 0), F = Math.min(F, x.length - 1));
        let L = (e.slidesGrid[Q] || 0) - (e.slidesGrid[0] || 0);
        _ && T >= U ? (Q -= U, v || (L += e.slidesGrid[0])) : _ && T < U && (Q = -U, v && (L += e.slidesGrid[0])), Object.assign(e.virtual, {
            from: Q,
            to: F,
            offset: L,
            slidesGrid: e.slidesGrid,
            slidesBefore: U,
            slidesAfter: D
        });

        function W() {
            e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s("virtualUpdate")
        }
        if (C === Q && S === F && !m) {
            e.slidesGrid !== y && L !== P && e.slides.forEach(te => {
                te.style[R] = `${L - Math.abs(e.cssOverflowAdjustment())}px`
            }), e.updateProgress(), s("virtualUpdate");
            return
        }
        if (e.params.virtual.renderExternal) {
            e.params.virtual.renderExternal.call(e, {
                offset: L,
                from: Q,
                to: F,
                slides: function () {
                    const ue = [];
                    for (let fe = Q; fe <= F; fe += 1) ue.push(x[fe]);
                    return ue
                }()
            }), e.params.virtual.renderExternalUpdate ? W() : s("virtualUpdate");
            return
        }
        const k = [],
            $ = [],
            X = te => {
                let ue = te;
                return te < 0 ? ue = x.length + te : ue >= x.length && (ue = ue - x.length), ue
            };
        if (m) e.slides.filter(te => te.matches(`.${e.params.slideClass}, swiper-slide`)).forEach(te => {
            te.remove()
        });
        else
            for (let te = C; te <= S; te += 1)
                if (te < Q || te > F) {
                    const ue = X(te);
                    e.slides.filter(fe => fe.matches(`.${e.params.slideClass}[data-swiper-slide-index="${ue}"], swiper-slide[data-swiper-slide-index="${ue}"]`)).forEach(fe => {
                        fe.remove()
                    })
                } const le = _ ? -x.length : 0,
                    K = _ ? x.length * 2 : x.length;
        for (let te = le; te < K; te += 1)
            if (te >= Q && te <= F) {
                const ue = X(te);
                typeof S > "u" || m ? $.push(ue) : (te > S && $.push(ue), te < C && k.push(ue))
            }
        if ($.forEach(te => {
            e.slidesEl.append(l(x[te], te))
        }), _)
            for (let te = k.length - 1; te >= 0; te -= 1) {
                const ue = k[te];
                e.slidesEl.prepend(l(x[ue], ue))
            } else k.sort((te, ue) => ue - te), k.forEach(te => {
                e.slidesEl.prepend(l(x[te], te))
            });
        Qi(e.slidesEl, ".swiper-slide, swiper-slide").forEach(te => {
            te.style[R] = `${L - Math.abs(e.cssOverflowAdjustment())}px`
        }), W()
    }

    function u(m) {
        if (typeof m == "object" && "length" in m)
            for (let g = 0; g < m.length; g += 1) m[g] && e.virtual.slides.push(m[g]);
        else e.virtual.slides.push(m);
        c(!0)
    }

    function d(m) {
        const g = e.activeIndex;
        let A = g + 1,
            p = 1;
        if (Array.isArray(m)) {
            for (let v = 0; v < m.length; v += 1) m[v] && e.virtual.slides.unshift(m[v]);
            A = g + m.length, p = m.length
        } else e.virtual.slides.unshift(m);
        if (e.params.virtual.cache) {
            const v = e.virtual.cache,
                _ = {};
            Object.keys(v).forEach(b => {
                const w = v[b],
                    E = w.getAttribute("data-swiper-slide-index");
                E && w.setAttribute("data-swiper-slide-index", parseInt(E, 10) + p), _[parseInt(b, 10) + p] = w
            }), e.virtual.cache = _
        }
        c(!0), e.slideTo(A, 0)
    }

    function h(m) {
        if (typeof m > "u" || m === null) return;
        let g = e.activeIndex;
        if (Array.isArray(m))
            for (let A = m.length - 1; A >= 0; A -= 1) e.params.virtual.cache && (delete e.virtual.cache[m[A]], Object.keys(e.virtual.cache).forEach(p => {
                p > m && (e.virtual.cache[p - 1] = e.virtual.cache[p], e.virtual.cache[p - 1].setAttribute("data-swiper-slide-index", p - 1), delete e.virtual.cache[p])
            })), e.virtual.slides.splice(m[A], 1), m[A] < g && (g -= 1), g = Math.max(g, 0);
        else e.params.virtual.cache && (delete e.virtual.cache[m], Object.keys(e.virtual.cache).forEach(A => {
            A > m && (e.virtual.cache[A - 1] = e.virtual.cache[A], e.virtual.cache[A - 1].setAttribute("data-swiper-slide-index", A - 1), delete e.virtual.cache[A])
        })), e.virtual.slides.splice(m, 1), m < g && (g -= 1), g = Math.max(g, 0);
        c(!0), e.slideTo(g, 0)
    }

    function f() {
        e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), c(!0), e.slideTo(0, 0)
    }
    i("beforeInit", () => {
        if (!e.params.virtual.enabled) return;
        let m;
        if (typeof e.passedParams.virtual.slides > "u") {
            const g = [...e.slidesEl.children].filter(A => A.matches(`.${e.params.slideClass}, swiper-slide`));
            g && g.length && (e.virtual.slides = [...g], m = !0, g.forEach((A, p) => {
                A.setAttribute("data-swiper-slide-index", p), e.virtual.cache[p] = A, A.remove()
            }))
        }
        m || (e.virtual.slides = e.params.virtual.slides), e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, c(!1, !0)
    }), i("setTranslate", () => {
        e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(r), r = setTimeout(() => {
            c()
        }, 100)) : c())
    }), i("init update resize", () => {
        e.params.virtual.enabled && e.params.cssMode && Uc(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`)
    }), Object.assign(e.virtual, {
        appendSlide: u,
        prependSlide: d,
        removeSlide: h,
        removeAllSlides: f,
        update: c
    })
}

function N4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    const r = zi(),
        o = ii();
    e.keyboard = {
        enabled: !1
    }, t({
        keyboard: {
            enabled: !1,
            onlyInViewport: !0,
            pageUpDown: !0
        }
    });

    function a(u) {
        if (!e.enabled) return;
        const {
            rtlTranslate: d
        } = e;
        let h = u;
        h.originalEvent && (h = h.originalEvent);
        const f = h.keyCode || h.charCode,
            m = e.params.keyboard.pageUpDown,
            g = m && f === 33,
            A = m && f === 34,
            p = f === 37,
            v = f === 39,
            _ = f === 38,
            b = f === 40;
        if (!e.allowSlideNext && (e.isHorizontal() && v || e.isVertical() && b || A) || !e.allowSlidePrev && (e.isHorizontal() && p || e.isVertical() && _ || g)) return !1;
        if (!(h.shiftKey || h.altKey || h.ctrlKey || h.metaKey) && !(r.activeElement && r.activeElement.nodeName && (r.activeElement.nodeName.toLowerCase() === "input" || r.activeElement.nodeName.toLowerCase() === "textarea"))) {
            if (e.params.keyboard.onlyInViewport && (g || A || p || v || _ || b)) {
                let w = !1;
                if (va(e.el, `.${e.params.slideClass}, swiper-slide`).length > 0 && va(e.el, `.${e.params.slideActiveClass}`).length === 0) return;
                const E = e.el,
                    C = E.clientWidth,
                    S = E.clientHeight,
                    x = o.innerWidth,
                    y = o.innerHeight,
                    P = bf(E);
                d && (P.left -= E.scrollLeft);
                const T = [
                    [P.left, P.top],
                    [P.left + C, P.top],
                    [P.left, P.top + S],
                    [P.left + C, P.top + S]
                ];
                for (let R = 0; R < T.length; R += 1) {
                    const D = T[R];
                    if (D[0] >= 0 && D[0] <= x && D[1] >= 0 && D[1] <= y) {
                        if (D[0] === 0 && D[1] === 0) continue;
                        w = !0
                    }
                }
                if (!w) return
            }
            e.isHorizontal() ? ((g || A || p || v) && (h.preventDefault ? h.preventDefault() : h.returnValue = !1), ((A || v) && !d || (g || p) && d) && e.slideNext(), ((g || p) && !d || (A || v) && d) && e.slidePrev()) : ((g || A || _ || b) && (h.preventDefault ? h.preventDefault() : h.returnValue = !1), (A || b) && e.slideNext(), (g || _) && e.slidePrev()), s("keyPress", f)
        }
    }

    function l() {
        e.keyboard.enabled || (r.addEventListener("keydown", a), e.keyboard.enabled = !0)
    }

    function c() {
        e.keyboard.enabled && (r.removeEventListener("keydown", a), e.keyboard.enabled = !1)
    }
    i("init", () => {
        e.params.keyboard.enabled && l()
    }), i("destroy", () => {
        e.keyboard.enabled && c()
    }), Object.assign(e.keyboard, {
        enable: l,
        disable: c
    })
}

function O4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    const r = ii();
    t({
        mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
            noMousewheelClass: "swiper-no-mousewheel"
        }
    }), e.mousewheel = {
        enabled: !1
    };
    let o, a = ns(),
        l;
    const c = [];

    function u(_) {
        let C = 0,
            S = 0,
            x = 0,
            y = 0;
        return "detail" in _ && (S = _.detail), "wheelDelta" in _ && (S = -_.wheelDelta / 120), "wheelDeltaY" in _ && (S = -_.wheelDeltaY / 120), "wheelDeltaX" in _ && (C = -_.wheelDeltaX / 120), "axis" in _ && _.axis === _.HORIZONTAL_AXIS && (C = S, S = 0), x = C * 10, y = S * 10, "deltaY" in _ && (y = _.deltaY), "deltaX" in _ && (x = _.deltaX), _.shiftKey && !x && (x = y, y = 0), (x || y) && _.deltaMode && (_.deltaMode === 1 ? (x *= 40, y *= 40) : (x *= 800, y *= 800)), x && !C && (C = x < 1 ? -1 : 1), y && !S && (S = y < 1 ? -1 : 1), {
            spinX: C,
            spinY: S,
            pixelX: x,
            pixelY: y
        }
    }

    function d() {
        e.enabled && (e.mouseEntered = !0)
    }

    function h() {
        e.enabled && (e.mouseEntered = !1)
    }

    function f(_) {
        return e.params.mousewheel.thresholdDelta && _.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && ns() - a < e.params.mousewheel.thresholdTime ? !1 : _.delta >= 6 && ns() - a < 60 ? !0 : (_.direction < 0 ? (!e.isEnd || e.params.loop) && !e.animating && (e.slideNext(), s("scroll", _.raw)) : (!e.isBeginning || e.params.loop) && !e.animating && (e.slidePrev(), s("scroll", _.raw)), a = new r.Date().getTime(), !1)
    }

    function m(_) {
        const b = e.params.mousewheel;
        if (_.direction < 0) {
            if (e.isEnd && !e.params.loop && b.releaseOnEdges) return !0
        } else if (e.isBeginning && !e.params.loop && b.releaseOnEdges) return !0;
        return !1
    }

    function g(_) {
        let b = _,
            w = !0;
        if (!e.enabled || _.target.closest(`.${e.params.mousewheel.noMousewheelClass}`)) return;
        const E = e.params.mousewheel;
        e.params.cssMode && b.preventDefault();
        let C = e.el;
        e.params.mousewheel.eventsTarget !== "container" && (C = document.querySelector(e.params.mousewheel.eventsTarget));
        const S = C && C.contains(b.target);
        if (!e.mouseEntered && !S && !E.releaseOnEdges) return !0;
        b.originalEvent && (b = b.originalEvent);
        let x = 0;
        const y = e.rtlTranslate ? -1 : 1,
            P = u(b);
        if (E.forceToAxis)
            if (e.isHorizontal())
                if (Math.abs(P.pixelX) > Math.abs(P.pixelY)) x = -P.pixelX * y;
                else return !0;
            else if (Math.abs(P.pixelY) > Math.abs(P.pixelX)) x = -P.pixelY;
            else return !0;
        else x = Math.abs(P.pixelX) > Math.abs(P.pixelY) ? -P.pixelX * y : -P.pixelY;
        if (x === 0) return !0;
        E.invert && (x = -x);
        let T = e.getTranslate() + x * E.sensitivity;
        if (T >= e.minTranslate() && (T = e.minTranslate()), T <= e.maxTranslate() && (T = e.maxTranslate()), w = e.params.loop ? !0 : !(T === e.minTranslate() || T === e.maxTranslate()), w && e.params.nested && b.stopPropagation(), !e.params.freeMode || !e.params.freeMode.enabled) {
            const R = {
                time: ns(),
                delta: Math.abs(x),
                direction: Math.sign(x),
                raw: _
            };
            c.length >= 2 && c.shift();
            const D = c.length ? c[c.length - 1] : void 0;
            if (c.push(R), D ? (R.direction !== D.direction || R.delta > D.delta || R.time > D.time + 150) && f(R) : f(R), m(R)) return !0
        } else {
            const R = {
                time: ns(),
                delta: Math.abs(x),
                direction: Math.sign(x)
            },
                D = l && R.time < l.time + 500 && R.delta <= l.delta && R.direction === l.direction;
            if (!D) {
                l = void 0;
                let U = e.getTranslate() + x * E.sensitivity;
                const Q = e.isBeginning,
                    F = e.isEnd;
                if (U >= e.minTranslate() && (U = e.minTranslate()), U <= e.maxTranslate() && (U = e.maxTranslate()), e.setTransition(0), e.setTranslate(U), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!Q && e.isBeginning || !F && e.isEnd) && e.updateSlidesClasses(), e.params.loop && e.loopFix({
                    direction: R.direction < 0 ? "next" : "prev",
                    byMousewheel: !0
                }), e.params.freeMode.sticky) {
                    clearTimeout(o), o = void 0, c.length >= 15 && c.shift();
                    const L = c.length ? c[c.length - 1] : void 0,
                        W = c[0];
                    if (c.push(R), L && (R.delta > L.delta || R.direction !== L.direction)) c.splice(0);
                    else if (c.length >= 15 && R.time - W.time < 500 && W.delta - R.delta >= 1 && R.delta <= 6) {
                        const k = x > 0 ? .8 : .2;
                        l = R, c.splice(0), o = Ta(() => {
                            e.slideToClosest(e.params.speed, !0, void 0, k)
                        }, 0)
                    }
                    o || (o = Ta(() => {
                        l = R, c.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5)
                    }, 500))
                }
                if (D || s("scroll", b), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), E.releaseOnEdges && (U === e.minTranslate() || U === e.maxTranslate())) return !0
            }
        }
        return b.preventDefault ? b.preventDefault() : b.returnValue = !1, !1
    }

    function A(_) {
        let b = e.el;
        e.params.mousewheel.eventsTarget !== "container" && (b = document.querySelector(e.params.mousewheel.eventsTarget)), b[_]("mouseenter", d), b[_]("mouseleave", h), b[_]("wheel", g)
    }

    function p() {
        return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", g), !0) : e.mousewheel.enabled ? !1 : (A("addEventListener"), e.mousewheel.enabled = !0, !0)
    }

    function v() {
        return e.params.cssMode ? (e.wrapperEl.addEventListener(event, g), !0) : e.mousewheel.enabled ? (A("removeEventListener"), e.mousewheel.enabled = !1, !0) : !1
    }
    i("init", () => {
        !e.params.mousewheel.enabled && e.params.cssMode && v(), e.params.mousewheel.enabled && p()
    }), i("destroy", () => {
        e.params.cssMode && p(), e.mousewheel.enabled && v()
    }), Object.assign(e.mousewheel, {
        enable: p,
        disable: v
    })
}

function L0(n, e, t, i) {
    return n.params.createElements && Object.keys(i).forEach(s => {
        if (!t[s] && t.auto === !0) {
            let r = Qi(n.el, `.${i[s]}`)[0];
            r || (r = Vn("div", i[s]), r.className = i[s], n.el.append(r)), t[s] = r, e[s] = r
        }
    }), t
}

function U4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    t({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    }), e.navigation = {
        nextEl: null,
        prevEl: null
    };

    function r(m) {
        let g;
        return m && typeof m == "string" && e.isElement && (g = e.el.querySelector(m), g) ? g : (m && (typeof m == "string" && (g = [...document.querySelectorAll(m)]), e.params.uniqueNavElements && typeof m == "string" && g && g.length > 1 && e.el.querySelectorAll(m).length === 1 ? g = e.el.querySelector(m) : g && g.length === 1 && (g = g[0])), m && !g ? m : g)
    }

    function o(m, g) {
        const A = e.params.navigation;
        m = ct(m), m.forEach(p => {
            p && (p.classList[g ? "add" : "remove"](...A.disabledClass.split(" ")), p.tagName === "BUTTON" && (p.disabled = g), e.params.watchOverflow && e.enabled && p.classList[e.isLocked ? "add" : "remove"](A.lockClass))
        })
    }

    function a() {
        const {
            nextEl: m,
            prevEl: g
        } = e.navigation;
        if (e.params.loop) {
            o(g, !1), o(m, !1);
            return
        }
        o(g, e.isBeginning && !e.params.rewind), o(m, e.isEnd && !e.params.rewind)
    }

    function l(m) {
        m.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), s("navigationPrev"))
    }

    function c(m) {
        m.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), s("navigationNext"))
    }

    function u() {
        const m = e.params.navigation;
        if (e.params.navigation = L0(e, e.originalParams.navigation, e.params.navigation, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        }), !(m.nextEl || m.prevEl)) return;
        let g = r(m.nextEl),
            A = r(m.prevEl);
        Object.assign(e.navigation, {
            nextEl: g,
            prevEl: A
        }), g = ct(g), A = ct(A);
        const p = (v, _) => {
            v && v.addEventListener("click", _ === "next" ? c : l), !e.enabled && v && v.classList.add(...m.lockClass.split(" "))
        };
        g.forEach(v => p(v, "next")), A.forEach(v => p(v, "prev"))
    }

    function d() {
        let {
            nextEl: m,
            prevEl: g
        } = e.navigation;
        m = ct(m), g = ct(g);
        const A = (p, v) => {
            p.removeEventListener("click", v === "next" ? c : l), p.classList.remove(...e.params.navigation.disabledClass.split(" "))
        };
        m.forEach(p => A(p, "next")), g.forEach(p => A(p, "prev"))
    }
    i("init", () => {
        e.params.navigation.enabled === !1 ? f() : (u(), a())
    }), i("toEdge fromEdge lock unlock", () => {
        a()
    }), i("destroy", () => {
        d()
    }), i("enable disable", () => {
        let {
            nextEl: m,
            prevEl: g
        } = e.navigation;
        if (m = ct(m), g = ct(g), e.enabled) {
            a();
            return
        } [...m, ...g].filter(A => !!A).forEach(A => A.classList.add(e.params.navigation.lockClass))
    }), i("click", (m, g) => {
        let {
            nextEl: A,
            prevEl: p
        } = e.navigation;
        A = ct(A), p = ct(p);
        const v = g.target;
        if (e.params.navigation.hideOnClick && !p.includes(v) && !A.includes(v)) {
            if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === v || e.pagination.el.contains(v))) return;
            let _;
            A.length ? _ = A[0].classList.contains(e.params.navigation.hiddenClass) : p.length && (_ = p[0].classList.contains(e.params.navigation.hiddenClass)), s(_ === !0 ? "navigationShow" : "navigationHide"), [...A, ...p].filter(b => !!b).forEach(b => b.classList.toggle(e.params.navigation.hiddenClass))
        }
    });
    const h = () => {
        e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), u(), a()
    },
        f = () => {
            e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), d()
        };
    Object.assign(e.navigation, {
        enable: h,
        disable: f,
        update: a,
        init: u,
        destroy: d
    })
}

function hr(n) {
    return n === void 0 && (n = ""), `.${n.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
}

function Q4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    const r = "swiper-pagination";
    t({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: p => p,
            formatFractionTotal: p => p,
            bulletClass: `${r}-bullet`,
            bulletActiveClass: `${r}-bullet-active`,
            modifierClass: `${r}-`,
            currentClass: `${r}-current`,
            totalClass: `${r}-total`,
            hiddenClass: `${r}-hidden`,
            progressbarFillClass: `${r}-progressbar-fill`,
            progressbarOppositeClass: `${r}-progressbar-opposite`,
            clickableClass: `${r}-clickable`,
            lockClass: `${r}-lock`,
            horizontalClass: `${r}-horizontal`,
            verticalClass: `${r}-vertical`,
            paginationDisabledClass: `${r}-disabled`
        }
    }), e.pagination = {
        el: null,
        bullets: []
    };
    let o, a = 0;

    function l() {
        return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0
    }

    function c(p, v) {
        const {
            bulletActiveClass: _
        } = e.params.pagination;
        p && (p = p[`${v === "prev" ? "previous" : "next"}ElementSibling`], p && (p.classList.add(`${_}-${v}`), p = p[`${v === "prev" ? "previous" : "next"}ElementSibling`], p && p.classList.add(`${_}-${v}-${v}`)))
    }

    function u(p) {
        const v = p.target.closest(hr(e.params.pagination.bulletClass));
        if (!v) return;
        p.preventDefault();
        const _ = Qu(v) * e.params.slidesPerGroup;
        if (e.params.loop) {
            if (e.realIndex === _) return;
            e.slideToLoop(_)
        } else e.slideTo(_)
    }

    function d() {
        const p = e.rtl,
            v = e.params.pagination;
        if (l()) return;
        let _ = e.pagination.el;
        _ = ct(_);
        let b, w;
        const E = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
            C = e.params.loop ? Math.ceil(E / e.params.slidesPerGroup) : e.snapGrid.length;
        if (e.params.loop ? (w = e.previousRealIndex || 0, b = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (b = e.snapIndex, w = e.previousSnapIndex) : (w = e.previousIndex || 0, b = e.activeIndex || 0), v.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
            const S = e.pagination.bullets;
            let x, y, P;
            if (v.dynamicBullets && (o = lA(S[0], e.isHorizontal() ? "width" : "height", !0), _.forEach(T => {
                T.style[e.isHorizontal() ? "width" : "height"] = `${o * (v.dynamicMainBullets + 4)}px`
            }), v.dynamicMainBullets > 1 && w !== void 0 && (a += b - (w || 0), a > v.dynamicMainBullets - 1 ? a = v.dynamicMainBullets - 1 : a < 0 && (a = 0)), x = Math.max(b - a, 0), y = x + (Math.min(S.length, v.dynamicMainBullets) - 1), P = (y + x) / 2), S.forEach(T => {
                const R = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(D => `${v.bulletActiveClass}${D}`)].map(D => typeof D == "string" && D.includes(" ") ? D.split(" ") : D).flat();
                T.classList.remove(...R)
            }), _.length > 1) S.forEach(T => {
                const R = Qu(T);
                R === b ? T.classList.add(...v.bulletActiveClass.split(" ")) : e.isElement && T.setAttribute("part", "bullet"), v.dynamicBullets && (R >= x && R <= y && T.classList.add(...`${v.bulletActiveClass}-main`.split(" ")), R === x && c(T, "prev"), R === y && c(T, "next"))
            });
            else {
                const T = S[b];
                if (T && T.classList.add(...v.bulletActiveClass.split(" ")), e.isElement && S.forEach((R, D) => {
                    R.setAttribute("part", D === b ? "bullet-active" : "bullet")
                }), v.dynamicBullets) {
                    const R = S[x],
                        D = S[y];
                    for (let U = x; U <= y; U += 1) S[U] && S[U].classList.add(...`${v.bulletActiveClass}-main`.split(" "));
                    c(R, "prev"), c(D, "next")
                }
            }
            if (v.dynamicBullets) {
                const T = Math.min(S.length, v.dynamicMainBullets + 4),
                    R = (o * T - o) / 2 - P * o,
                    D = p ? "right" : "left";
                S.forEach(U => {
                    U.style[e.isHorizontal() ? D : "top"] = `${R}px`
                })
            }
        }
        _.forEach((S, x) => {
            if (v.type === "fraction" && (S.querySelectorAll(hr(v.currentClass)).forEach(y => {
                y.textContent = v.formatFractionCurrent(b + 1)
            }), S.querySelectorAll(hr(v.totalClass)).forEach(y => {
                y.textContent = v.formatFractionTotal(C)
            })), v.type === "progressbar") {
                let y;
                v.progressbarOpposite ? y = e.isHorizontal() ? "vertical" : "horizontal" : y = e.isHorizontal() ? "horizontal" : "vertical";
                const P = (b + 1) / C;
                let T = 1,
                    R = 1;
                y === "horizontal" ? T = P : R = P, S.querySelectorAll(hr(v.progressbarFillClass)).forEach(D => {
                    D.style.transform = `translate3d(0,0,0) scaleX(${T}) scaleY(${R})`, D.style.transitionDuration = `${e.params.speed}ms`
                })
            }
            v.type === "custom" && v.renderCustom ? (S.innerHTML = v.renderCustom(e, b + 1, C), x === 0 && s("paginationRender", S)) : (x === 0 && s("paginationRender", S), s("paginationUpdate", S)), e.params.watchOverflow && e.enabled && S.classList[e.isLocked ? "add" : "remove"](v.lockClass)
        })
    }

    function h() {
        const p = e.params.pagination;
        if (l()) return;
        const v = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length;
        let _ = e.pagination.el;
        _ = ct(_);
        let b = "";
        if (p.type === "bullets") {
            let w = e.params.loop ? Math.ceil(v / e.params.slidesPerGroup) : e.snapGrid.length;
            e.params.freeMode && e.params.freeMode.enabled && w > v && (w = v);
            for (let E = 0; E < w; E += 1) p.renderBullet ? b += p.renderBullet.call(e, E, p.bulletClass) : b += `<${p.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${p.bulletClass}"></${p.bulletElement}>`
        }
        p.type === "fraction" && (p.renderFraction ? b = p.renderFraction.call(e, p.currentClass, p.totalClass) : b = `<span class="${p.currentClass}"></span> / <span class="${p.totalClass}"></span>`), p.type === "progressbar" && (p.renderProgressbar ? b = p.renderProgressbar.call(e, p.progressbarFillClass) : b = `<span class="${p.progressbarFillClass}"></span>`), e.pagination.bullets = [], _.forEach(w => {
            p.type !== "custom" && (w.innerHTML = b || ""), p.type === "bullets" && e.pagination.bullets.push(...w.querySelectorAll(hr(p.bulletClass)))
        }), p.type !== "custom" && s("paginationRender", _[0])
    }

    function f() {
        e.params.pagination = L0(e, e.originalParams.pagination, e.params.pagination, {
            el: "swiper-pagination"
        });
        const p = e.params.pagination;
        if (!p.el) return;
        let v;
        typeof p.el == "string" && e.isElement && (v = e.el.querySelector(p.el)), !v && typeof p.el == "string" && (v = [...document.querySelectorAll(p.el)]), v || (v = p.el), !(!v || v.length === 0) && (e.params.uniqueNavElements && typeof p.el == "string" && Array.isArray(v) && v.length > 1 && (v = [...e.el.querySelectorAll(p.el)], v.length > 1 && (v = v.filter(_ => va(_, ".swiper")[0] === e.el)[0])), Array.isArray(v) && v.length === 1 && (v = v[0]), Object.assign(e.pagination, {
            el: v
        }), v = ct(v), v.forEach(_ => {
            p.type === "bullets" && p.clickable && _.classList.add(...(p.clickableClass || "").split(" ")), _.classList.add(p.modifierClass + p.type), _.classList.add(e.isHorizontal() ? p.horizontalClass : p.verticalClass), p.type === "bullets" && p.dynamicBullets && (_.classList.add(`${p.modifierClass}${p.type}-dynamic`), a = 0, p.dynamicMainBullets < 1 && (p.dynamicMainBullets = 1)), p.type === "progressbar" && p.progressbarOpposite && _.classList.add(p.progressbarOppositeClass), p.clickable && _.addEventListener("click", u), e.enabled || _.classList.add(p.lockClass)
        }))
    }

    function m() {
        const p = e.params.pagination;
        if (l()) return;
        let v = e.pagination.el;
        v && (v = ct(v), v.forEach(_ => {
            _.classList.remove(p.hiddenClass), _.classList.remove(p.modifierClass + p.type), _.classList.remove(e.isHorizontal() ? p.horizontalClass : p.verticalClass), p.clickable && (_.classList.remove(...(p.clickableClass || "").split(" ")), _.removeEventListener("click", u))
        })), e.pagination.bullets && e.pagination.bullets.forEach(_ => _.classList.remove(...p.bulletActiveClass.split(" ")))
    }
    i("changeDirection", () => {
        if (!e.pagination || !e.pagination.el) return;
        const p = e.params.pagination;
        let {
            el: v
        } = e.pagination;
        v = ct(v), v.forEach(_ => {
            _.classList.remove(p.horizontalClass, p.verticalClass), _.classList.add(e.isHorizontal() ? p.horizontalClass : p.verticalClass)
        })
    }), i("init", () => {
        e.params.pagination.enabled === !1 ? A() : (f(), h(), d())
    }), i("activeIndexChange", () => {
        typeof e.snapIndex > "u" && d()
    }), i("snapIndexChange", () => {
        d()
    }), i("snapGridLengthChange", () => {
        h(), d()
    }), i("destroy", () => {
        m()
    }), i("enable disable", () => {
        let {
            el: p
        } = e.pagination;
        p && (p = ct(p), p.forEach(v => v.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass)))
    }), i("lock unlock", () => {
        d()
    }), i("click", (p, v) => {
        const _ = v.target,
            b = ct(e.pagination.el);
        if (e.params.pagination.el && e.params.pagination.hideOnClick && b && b.length > 0 && !_.classList.contains(e.params.pagination.bulletClass)) {
            if (e.navigation && (e.navigation.nextEl && _ === e.navigation.nextEl || e.navigation.prevEl && _ === e.navigation.prevEl)) return;
            const w = b[0].classList.contains(e.params.pagination.hiddenClass);
            s(w === !0 ? "paginationShow" : "paginationHide"), b.forEach(E => E.classList.toggle(e.params.pagination.hiddenClass))
        }
    });
    const g = () => {
        e.el.classList.remove(e.params.pagination.paginationDisabledClass);
        let {
            el: p
        } = e.pagination;
        p && (p = ct(p), p.forEach(v => v.classList.remove(e.params.pagination.paginationDisabledClass))), f(), h(), d()
    },
        A = () => {
            e.el.classList.add(e.params.pagination.paginationDisabledClass);
            let {
                el: p
            } = e.pagination;
            p && (p = ct(p), p.forEach(v => v.classList.add(e.params.pagination.paginationDisabledClass))), m()
        };
    Object.assign(e.pagination, {
        enable: g,
        disable: A,
        render: h,
        update: d,
        init: f,
        destroy: m
    })
}

function z4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    const r = zi();
    let o = !1,
        a = null,
        l = null,
        c, u, d, h;
    t({
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: !1,
            draggable: !1,
            snapOnRelease: !0,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: "swiper-scrollbar-horizontal",
            verticalClass: "swiper-scrollbar-vertical"
        }
    }), e.scrollbar = {
        el: null,
        dragEl: null
    };

    function f() {
        if (!e.params.scrollbar.el || !e.scrollbar.el) return;
        const {
            scrollbar: T,
            rtlTranslate: R
        } = e, {
            dragEl: D,
            el: U
        } = T, Q = e.params.scrollbar, F = e.params.loop ? e.progressLoop : e.progress;
        let L = u,
            W = (d - u) * F;
        R ? (W = -W, W > 0 ? (L = u - W, W = 0) : -W + u > d && (L = d + W)) : W < 0 ? (L = u + W, W = 0) : W + u > d && (L = d - W), e.isHorizontal() ? (D.style.transform = `translate3d(${W}px, 0, 0)`, D.style.width = `${L}px`) : (D.style.transform = `translate3d(0px, ${W}px, 0)`, D.style.height = `${L}px`), Q.hide && (clearTimeout(a), U.style.opacity = 1, a = setTimeout(() => {
            U.style.opacity = 0, U.style.transitionDuration = "400ms"
        }, 1e3))
    }

    function m(T) {
        !e.params.scrollbar.el || !e.scrollbar.el || (e.scrollbar.dragEl.style.transitionDuration = `${T}ms`)
    }

    function g() {
        if (!e.params.scrollbar.el || !e.scrollbar.el) return;
        const {
            scrollbar: T
        } = e, {
            dragEl: R,
            el: D
        } = T;
        R.style.width = "", R.style.height = "", d = e.isHorizontal() ? D.offsetWidth : D.offsetHeight, h = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), e.params.scrollbar.dragSize === "auto" ? u = d * h : u = parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? R.style.width = `${u}px` : R.style.height = `${u}px`, h >= 1 ? D.style.display = "none" : D.style.display = "", e.params.scrollbar.hide && (D.style.opacity = 0), e.params.watchOverflow && e.enabled && T.el.classList[e.isLocked ? "add" : "remove"](e.params.scrollbar.lockClass)
    }

    function A(T) {
        return e.isHorizontal() ? T.clientX : T.clientY
    }

    function p(T) {
        const {
            scrollbar: R,
            rtlTranslate: D
        } = e, {
            el: U
        } = R;
        let Q;
        Q = (A(T) - bf(U)[e.isHorizontal() ? "left" : "top"] - (c !== null ? c : u / 2)) / (d - u), Q = Math.max(Math.min(Q, 1), 0), D && (Q = 1 - Q);
        const F = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * Q;
        e.updateProgress(F), e.setTranslate(F), e.updateActiveIndex(), e.updateSlidesClasses()
    }

    function v(T) {
        const R = e.params.scrollbar,
            {
                scrollbar: D,
                wrapperEl: U
            } = e,
            {
                el: Q,
                dragEl: F
            } = D;
        o = !0, c = T.target === F ? A(T) - T.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, T.preventDefault(), T.stopPropagation(), U.style.transitionDuration = "100ms", F.style.transitionDuration = "100ms", p(T), clearTimeout(l), Q.style.transitionDuration = "0ms", R.hide && (Q.style.opacity = 1), e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "none"), s("scrollbarDragStart", T)
    }

    function _(T) {
        const {
            scrollbar: R,
            wrapperEl: D
        } = e, {
            el: U,
            dragEl: Q
        } = R;
        o && (T.preventDefault && T.cancelable ? T.preventDefault() : T.returnValue = !1, p(T), D.style.transitionDuration = "0ms", U.style.transitionDuration = "0ms", Q.style.transitionDuration = "0ms", s("scrollbarDragMove", T))
    }

    function b(T) {
        const R = e.params.scrollbar,
            {
                scrollbar: D,
                wrapperEl: U
            } = e,
            {
                el: Q
            } = D;
        o && (o = !1, e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "", U.style.transitionDuration = ""), R.hide && (clearTimeout(l), l = Ta(() => {
            Q.style.opacity = 0, Q.style.transitionDuration = "400ms"
        }, 1e3)), s("scrollbarDragEnd", T), R.snapOnRelease && e.slideToClosest())
    }

    function w(T) {
        const {
            scrollbar: R,
            params: D
        } = e, U = R.el;
        if (!U) return;
        const Q = U,
            F = D.passiveListeners ? {
                passive: !1,
                capture: !1
            } : !1,
            L = D.passiveListeners ? {
                passive: !0,
                capture: !1
            } : !1;
        if (!Q) return;
        const W = T === "on" ? "addEventListener" : "removeEventListener";
        Q[W]("pointerdown", v, F), r[W]("pointermove", _, F), r[W]("pointerup", b, L)
    }

    function E() {
        !e.params.scrollbar.el || !e.scrollbar.el || w("on")
    }

    function C() {
        !e.params.scrollbar.el || !e.scrollbar.el || w("off")
    }

    function S() {
        const {
            scrollbar: T,
            el: R
        } = e;
        e.params.scrollbar = L0(e, e.originalParams.scrollbar, e.params.scrollbar, {
            el: "swiper-scrollbar"
        });
        const D = e.params.scrollbar;
        if (!D.el) return;
        let U;
        if (typeof D.el == "string" && e.isElement && (U = e.el.querySelector(D.el)), !U && typeof D.el == "string") {
            if (U = r.querySelectorAll(D.el), !U.length) return
        } else U || (U = D.el);
        e.params.uniqueNavElements && typeof D.el == "string" && U.length > 1 && R.querySelectorAll(D.el).length === 1 && (U = R.querySelector(D.el)), U.length > 0 && (U = U[0]), U.classList.add(e.isHorizontal() ? D.horizontalClass : D.verticalClass);
        let Q;
        U && (Q = U.querySelector(hr(e.params.scrollbar.dragClass)), Q || (Q = Vn("div", e.params.scrollbar.dragClass), U.append(Q))), Object.assign(T, {
            el: U,
            dragEl: Q
        }), D.draggable && E(), U && U.classList[e.enabled ? "remove" : "add"](...Gr(e.params.scrollbar.lockClass))
    }

    function x() {
        const T = e.params.scrollbar,
            R = e.scrollbar.el;
        R && R.classList.remove(...Gr(e.isHorizontal() ? T.horizontalClass : T.verticalClass)), C()
    }
    i("changeDirection", () => {
        if (!e.scrollbar || !e.scrollbar.el) return;
        const T = e.params.scrollbar;
        let {
            el: R
        } = e.scrollbar;
        R = ct(R), R.forEach(D => {
            D.classList.remove(T.horizontalClass, T.verticalClass), D.classList.add(e.isHorizontal() ? T.horizontalClass : T.verticalClass)
        })
    }), i("init", () => {
        e.params.scrollbar.enabled === !1 ? P() : (S(), g(), f())
    }), i("update resize observerUpdate lock unlock changeDirection", () => {
        g()
    }), i("setTranslate", () => {
        f()
    }), i("setTransition", (T, R) => {
        m(R)
    }), i("enable disable", () => {
        const {
            el: T
        } = e.scrollbar;
        T && T.classList[e.enabled ? "remove" : "add"](...Gr(e.params.scrollbar.lockClass))
    }), i("destroy", () => {
        x()
    });
    const y = () => {
        e.el.classList.remove(...Gr(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.remove(...Gr(e.params.scrollbar.scrollbarDisabledClass)), S(), g(), f()
    },
        P = () => {
            e.el.classList.add(...Gr(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.add(...Gr(e.params.scrollbar.scrollbarDisabledClass)), x()
        };
    Object.assign(e.scrollbar, {
        enable: y,
        disable: P,
        updateSize: g,
        setTranslate: f,
        init: S,
        destroy: x
    })
}

function G4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        parallax: {
            enabled: !1
        }
    });
    const s = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]",
        r = (l, c) => {
            const {
                rtl: u
            } = e, d = u ? -1 : 1, h = l.getAttribute("data-swiper-parallax") || "0";
            let f = l.getAttribute("data-swiper-parallax-x"),
                m = l.getAttribute("data-swiper-parallax-y");
            const g = l.getAttribute("data-swiper-parallax-scale"),
                A = l.getAttribute("data-swiper-parallax-opacity"),
                p = l.getAttribute("data-swiper-parallax-rotate");
            if (f || m ? (f = f || "0", m = m || "0") : e.isHorizontal() ? (f = h, m = "0") : (m = h, f = "0"), f.indexOf("%") >= 0 ? f = `${parseInt(f, 10) * c * d}%` : f = `${f * c * d}px`, m.indexOf("%") >= 0 ? m = `${parseInt(m, 10) * c}%` : m = `${m * c}px`, typeof A < "u" && A !== null) {
                const _ = A - (A - 1) * (1 - Math.abs(c));
                l.style.opacity = _
            }
            let v = `translate3d(${f}, ${m}, 0px)`;
            if (typeof g < "u" && g !== null) {
                const _ = g - (g - 1) * (1 - Math.abs(c));
                v += ` scale(${_})`
            }
            if (p && typeof p < "u" && p !== null) {
                const _ = p * c * -1;
                v += ` rotate(${_}deg)`
            }
            l.style.transform = v
        },
        o = () => {
            const {
                el: l,
                slides: c,
                progress: u,
                snapGrid: d,
                isElement: h
            } = e, f = Qi(l, s);
            e.isElement && f.push(...Qi(e.hostEl, s)), f.forEach(m => {
                r(m, u)
            }), c.forEach((m, g) => {
                let A = m.progress;
                e.params.slidesPerGroup > 1 && e.params.slidesPerView !== "auto" && (A += Math.ceil(g / 2) - u * (d.length - 1)), A = Math.min(Math.max(A, -1), 1), m.querySelectorAll(`${s}, [data-swiper-parallax-rotate]`).forEach(p => {
                    r(p, A)
                })
            })
        },
        a = function (l) {
            l === void 0 && (l = e.params.speed);
            const {
                el: c,
                hostEl: u
            } = e, d = [...c.querySelectorAll(s)];
            e.isElement && d.push(...u.querySelectorAll(s)), d.forEach(h => {
                let f = parseInt(h.getAttribute("data-swiper-parallax-duration"), 10) || l;
                l === 0 && (f = 0), h.style.transitionDuration = `${f}ms`
            })
        };
    i("beforeInit", () => {
        e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0)
    }), i("init", () => {
        e.params.parallax.enabled && o()
    }), i("setTranslate", () => {
        e.params.parallax.enabled && o()
    }), i("setTransition", (l, c) => {
        e.params.parallax.enabled && a(c)
    })
}

function H4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s
    } = n;
    const r = ii();
    t({
        zoom: {
            enabled: !1,
            limitToOriginalSize: !1,
            maxRatio: 3,
            minRatio: 1,
            toggle: !0,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed"
        }
    }), e.zoom = {
        enabled: !1
    };
    let o = 1,
        a = !1,
        l, c;
    const u = [],
        d = {
            originX: 0,
            originY: 0,
            slideEl: void 0,
            slideWidth: void 0,
            slideHeight: void 0,
            imageEl: void 0,
            imageWrapEl: void 0,
            maxRatio: 3
        },
        h = {
            isTouched: void 0,
            isMoved: void 0,
            currentX: void 0,
            currentY: void 0,
            minX: void 0,
            minY: void 0,
            maxX: void 0,
            maxY: void 0,
            width: void 0,
            height: void 0,
            startX: void 0,
            startY: void 0,
            touchesStart: {},
            touchesCurrent: {}
        },
        f = {
            x: void 0,
            y: void 0,
            prevPositionX: void 0,
            prevPositionY: void 0,
            prevTime: void 0
        };
    let m = 1;
    Object.defineProperty(e.zoom, "scale", {
        get() {
            return m
        },
        set($) {
            if (m !== $) {
                const X = d.imageEl,
                    le = d.slideEl;
                s("zoomChange", $, X, le)
            }
            m = $
        }
    });

    function g() {
        if (u.length < 2) return 1;
        const $ = u[0].pageX,
            X = u[0].pageY,
            le = u[1].pageX,
            K = u[1].pageY;
        return Math.sqrt((le - $) ** 2 + (K - X) ** 2)
    }

    function A() {
        const $ = e.params.zoom,
            X = d.imageWrapEl.getAttribute("data-swiper-zoom") || $.maxRatio;
        if ($.limitToOriginalSize && d.imageEl && d.imageEl.naturalWidth) {
            const le = d.imageEl.naturalWidth / d.imageEl.offsetWidth;
            return Math.min(le, X)
        }
        return X
    }

    function p() {
        if (u.length < 2) return {
            x: null,
            y: null
        };
        const $ = d.imageEl.getBoundingClientRect();
        return [(u[0].pageX + (u[1].pageX - u[0].pageX) / 2 - $.x - r.scrollX) / o, (u[0].pageY + (u[1].pageY - u[0].pageY) / 2 - $.y - r.scrollY) / o]
    }

    function v() {
        return e.isElement ? "swiper-slide" : `.${e.params.slideClass}`
    }

    function _($) {
        const X = v();
        return !!($.target.matches(X) || e.slides.filter(le => le.contains($.target)).length > 0)
    }

    function b($) {
        const X = `.${e.params.zoom.containerClass}`;
        return !!($.target.matches(X) || [...e.hostEl.querySelectorAll(X)].filter(le => le.contains($.target)).length > 0)
    }

    function w($) {
        if ($.pointerType === "mouse" && u.splice(0, u.length), !_($)) return;
        const X = e.params.zoom;
        if (l = !1, c = !1, u.push($), !(u.length < 2)) {
            if (l = !0, d.scaleStart = g(), !d.slideEl) {
                d.slideEl = $.target.closest(`.${e.params.slideClass}, swiper-slide`), d.slideEl || (d.slideEl = e.slides[e.activeIndex]);
                let le = d.slideEl.querySelector(`.${X.containerClass}`);
                if (le && (le = le.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = le, le ? d.imageWrapEl = va(d.imageEl, `.${X.containerClass}`)[0] : d.imageWrapEl = void 0, !d.imageWrapEl) {
                    d.imageEl = void 0;
                    return
                }
                d.maxRatio = A()
            }
            if (d.imageEl) {
                const [le, K] = p();
                d.originX = le, d.originY = K, d.imageEl.style.transitionDuration = "0ms"
            }
            a = !0
        }
    }

    function E($) {
        if (!_($)) return;
        const X = e.params.zoom,
            le = e.zoom,
            K = u.findIndex(te => te.pointerId === $.pointerId);
        K >= 0 && (u[K] = $), !(u.length < 2) && (c = !0, d.scaleMove = g(), d.imageEl && (le.scale = d.scaleMove / d.scaleStart * o, le.scale > d.maxRatio && (le.scale = d.maxRatio - 1 + (le.scale - d.maxRatio + 1) ** .5), le.scale < X.minRatio && (le.scale = X.minRatio + 1 - (X.minRatio - le.scale + 1) ** .5), d.imageEl.style.transform = `translate3d(0,0,0) scale(${le.scale})`))
    }

    function C($) {
        if (!_($) || $.pointerType === "mouse" && $.type === "pointerout") return;
        const X = e.params.zoom,
            le = e.zoom,
            K = u.findIndex(te => te.pointerId === $.pointerId);
        K >= 0 && u.splice(K, 1), !(!l || !c) && (l = !1, c = !1, d.imageEl && (le.scale = Math.max(Math.min(le.scale, d.maxRatio), X.minRatio), d.imageEl.style.transitionDuration = `${e.params.speed}ms`, d.imageEl.style.transform = `translate3d(0,0,0) scale(${le.scale})`, o = le.scale, a = !1, le.scale > 1 && d.slideEl ? d.slideEl.classList.add(`${X.zoomedSlideClass}`) : le.scale <= 1 && d.slideEl && d.slideEl.classList.remove(`${X.zoomedSlideClass}`), le.scale === 1 && (d.originX = 0, d.originY = 0, d.slideEl = void 0)))
    }
    let S;

    function x() {
        e.touchEventsData.preventTouchMoveFromPointerMove = !1
    }

    function y() {
        clearTimeout(S), e.touchEventsData.preventTouchMoveFromPointerMove = !0, S = setTimeout(() => {
            x()
        })
    }

    function P($) {
        const X = e.device;
        if (!d.imageEl || h.isTouched) return;
        X.android && $.cancelable && $.preventDefault(), h.isTouched = !0;
        const le = u.length > 0 ? u[0] : $;
        h.touchesStart.x = le.pageX, h.touchesStart.y = le.pageY
    }

    function T($) {
        if (!_($) || !b($)) return;
        const X = e.zoom;
        if (!d.imageEl || !h.isTouched || !d.slideEl) return;
        h.isMoved || (h.width = d.imageEl.offsetWidth || d.imageEl.clientWidth, h.height = d.imageEl.offsetHeight || d.imageEl.clientHeight, h.startX = aA(d.imageWrapEl, "x") || 0, h.startY = aA(d.imageWrapEl, "y") || 0, d.slideWidth = d.slideEl.offsetWidth, d.slideHeight = d.slideEl.offsetHeight, d.imageWrapEl.style.transitionDuration = "0ms");
        const le = h.width * X.scale,
            K = h.height * X.scale;
        if (le < d.slideWidth && K < d.slideHeight) {
            x();
            return
        }
        if (h.minX = Math.min(d.slideWidth / 2 - le / 2, 0), h.maxX = -h.minX, h.minY = Math.min(d.slideHeight / 2 - K / 2, 0), h.maxY = -h.minY, h.touchesCurrent.x = u.length > 0 ? u[0].pageX : $.pageX, h.touchesCurrent.y = u.length > 0 ? u[0].pageY : $.pageY, Math.max(Math.abs(h.touchesCurrent.x - h.touchesStart.x), Math.abs(h.touchesCurrent.y - h.touchesStart.y)) > 5 && (e.allowClick = !1), !h.isMoved && !a) {
            if (e.isHorizontal() && (Math.floor(h.minX) === Math.floor(h.startX) && h.touchesCurrent.x < h.touchesStart.x || Math.floor(h.maxX) === Math.floor(h.startX) && h.touchesCurrent.x > h.touchesStart.x)) {
                h.isTouched = !1, x();
                return
            }
            if (!e.isHorizontal() && (Math.floor(h.minY) === Math.floor(h.startY) && h.touchesCurrent.y < h.touchesStart.y || Math.floor(h.maxY) === Math.floor(h.startY) && h.touchesCurrent.y > h.touchesStart.y)) {
                h.isTouched = !1, x();
                return
            }
        }
        $.cancelable && $.preventDefault(), $.stopPropagation(), y(), h.isMoved = !0;
        const ue = (X.scale - o) / (d.maxRatio - e.params.zoom.minRatio),
            {
                originX: fe,
                originY: Me
            } = d;
        h.currentX = h.touchesCurrent.x - h.touchesStart.x + h.startX + ue * (h.width - fe * 2), h.currentY = h.touchesCurrent.y - h.touchesStart.y + h.startY + ue * (h.height - Me * 2), h.currentX < h.minX && (h.currentX = h.minX + 1 - (h.minX - h.currentX + 1) ** .8), h.currentX > h.maxX && (h.currentX = h.maxX - 1 + (h.currentX - h.maxX + 1) ** .8), h.currentY < h.minY && (h.currentY = h.minY + 1 - (h.minY - h.currentY + 1) ** .8), h.currentY > h.maxY && (h.currentY = h.maxY - 1 + (h.currentY - h.maxY + 1) ** .8), f.prevPositionX || (f.prevPositionX = h.touchesCurrent.x), f.prevPositionY || (f.prevPositionY = h.touchesCurrent.y), f.prevTime || (f.prevTime = Date.now()), f.x = (h.touchesCurrent.x - f.prevPositionX) / (Date.now() - f.prevTime) / 2, f.y = (h.touchesCurrent.y - f.prevPositionY) / (Date.now() - f.prevTime) / 2, Math.abs(h.touchesCurrent.x - f.prevPositionX) < 2 && (f.x = 0), Math.abs(h.touchesCurrent.y - f.prevPositionY) < 2 && (f.y = 0), f.prevPositionX = h.touchesCurrent.x, f.prevPositionY = h.touchesCurrent.y, f.prevTime = Date.now(), d.imageWrapEl.style.transform = `translate3d(${h.currentX}px, ${h.currentY}px,0)`
    }

    function R() {
        const $ = e.zoom;
        if (!d.imageEl) return;
        if (!h.isTouched || !h.isMoved) {
            h.isTouched = !1, h.isMoved = !1;
            return
        }
        h.isTouched = !1, h.isMoved = !1;
        let X = 300,
            le = 300;
        const K = f.x * X,
            te = h.currentX + K,
            ue = f.y * le,
            fe = h.currentY + ue;
        f.x !== 0 && (X = Math.abs((te - h.currentX) / f.x)), f.y !== 0 && (le = Math.abs((fe - h.currentY) / f.y));
        const Me = Math.max(X, le);
        h.currentX = te, h.currentY = fe;
        const Be = h.width * $.scale,
            Ce = h.height * $.scale;
        h.minX = Math.min(d.slideWidth / 2 - Be / 2, 0), h.maxX = -h.minX, h.minY = Math.min(d.slideHeight / 2 - Ce / 2, 0), h.maxY = -h.minY, h.currentX = Math.max(Math.min(h.currentX, h.maxX), h.minX), h.currentY = Math.max(Math.min(h.currentY, h.maxY), h.minY), d.imageWrapEl.style.transitionDuration = `${Me}ms`, d.imageWrapEl.style.transform = `translate3d(${h.currentX}px, ${h.currentY}px,0)`
    }

    function D() {
        const $ = e.zoom;
        d.slideEl && e.activeIndex !== e.slides.indexOf(d.slideEl) && (d.imageEl && (d.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), d.imageWrapEl && (d.imageWrapEl.style.transform = "translate3d(0,0,0)"), d.slideEl.classList.remove(`${e.params.zoom.zoomedSlideClass}`), $.scale = 1, o = 1, d.slideEl = void 0, d.imageEl = void 0, d.imageWrapEl = void 0, d.originX = 0, d.originY = 0)
    }

    function U($) {
        const X = e.zoom,
            le = e.params.zoom;
        if (!d.slideEl) {
            $ && $.target && (d.slideEl = $.target.closest(`.${e.params.slideClass}, swiper-slide`)), d.slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? d.slideEl = Qi(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : d.slideEl = e.slides[e.activeIndex]);
            let re = d.slideEl.querySelector(`.${le.containerClass}`);
            re && (re = re.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = re, re ? d.imageWrapEl = va(d.imageEl, `.${le.containerClass}`)[0] : d.imageWrapEl = void 0
        }
        if (!d.imageEl || !d.imageWrapEl) return;
        e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), d.slideEl.classList.add(`${le.zoomedSlideClass}`);
        let K, te, ue, fe, Me, Be, Ce, Z, ke, N, G, Y, se, M, I, H, V, j;
        typeof h.touchesStart.x > "u" && $ ? (K = $.pageX, te = $.pageY) : (K = h.touchesStart.x, te = h.touchesStart.y);
        const q = typeof $ == "number" ? $ : null;
        o === 1 && q && (K = void 0, te = void 0);
        const he = A();
        X.scale = q || he, o = q || he, $ && !(o === 1 && q) ? (V = d.slideEl.offsetWidth, j = d.slideEl.offsetHeight, ue = bf(d.slideEl).left + r.scrollX, fe = bf(d.slideEl).top + r.scrollY, Me = ue + V / 2 - K, Be = fe + j / 2 - te, ke = d.imageEl.offsetWidth || d.imageEl.clientWidth, N = d.imageEl.offsetHeight || d.imageEl.clientHeight, G = ke * X.scale, Y = N * X.scale, se = Math.min(V / 2 - G / 2, 0), M = Math.min(j / 2 - Y / 2, 0), I = -se, H = -M, Ce = Me * X.scale, Z = Be * X.scale, Ce < se && (Ce = se), Ce > I && (Ce = I), Z < M && (Z = M), Z > H && (Z = H)) : (Ce = 0, Z = 0), q && X.scale === 1 && (d.originX = 0, d.originY = 0), d.imageWrapEl.style.transitionDuration = "300ms", d.imageWrapEl.style.transform = `translate3d(${Ce}px, ${Z}px,0)`, d.imageEl.style.transitionDuration = "300ms", d.imageEl.style.transform = `translate3d(0,0,0) scale(${X.scale})`
    }

    function Q() {
        const $ = e.zoom,
            X = e.params.zoom;
        if (!d.slideEl) {
            e.params.virtual && e.params.virtual.enabled && e.virtual ? d.slideEl = Qi(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : d.slideEl = e.slides[e.activeIndex];
            let le = d.slideEl.querySelector(`.${X.containerClass}`);
            le && (le = le.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = le, le ? d.imageWrapEl = va(d.imageEl, `.${X.containerClass}`)[0] : d.imageWrapEl = void 0
        } !d.imageEl || !d.imageWrapEl || (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), $.scale = 1, o = 1, d.imageWrapEl.style.transitionDuration = "300ms", d.imageWrapEl.style.transform = "translate3d(0,0,0)", d.imageEl.style.transitionDuration = "300ms", d.imageEl.style.transform = "translate3d(0,0,0) scale(1)", d.slideEl.classList.remove(`${X.zoomedSlideClass}`), d.slideEl = void 0, d.originX = 0, d.originY = 0)
    }

    function F($) {
        const X = e.zoom;
        X.scale && X.scale !== 1 ? Q() : U($)
    }

    function L() {
        const $ = e.params.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1,
            X = e.params.passiveListeners ? {
                passive: !1,
                capture: !0
            } : !0;
        return {
            passiveListener: $,
            activeListenerWithCapture: X
        }
    }

    function W() {
        const $ = e.zoom;
        if ($.enabled) return;
        $.enabled = !0;
        const {
            passiveListener: X,
            activeListenerWithCapture: le
        } = L();
        e.wrapperEl.addEventListener("pointerdown", w, X), e.wrapperEl.addEventListener("pointermove", E, le), ["pointerup", "pointercancel", "pointerout"].forEach(K => {
            e.wrapperEl.addEventListener(K, C, X)
        }), e.wrapperEl.addEventListener("pointermove", T, le)
    }

    function k() {
        const $ = e.zoom;
        if (!$.enabled) return;
        $.enabled = !1;
        const {
            passiveListener: X,
            activeListenerWithCapture: le
        } = L();
        e.wrapperEl.removeEventListener("pointerdown", w, X), e.wrapperEl.removeEventListener("pointermove", E, le), ["pointerup", "pointercancel", "pointerout"].forEach(K => {
            e.wrapperEl.removeEventListener(K, C, X)
        }), e.wrapperEl.removeEventListener("pointermove", T, le)
    }
    i("init", () => {
        e.params.zoom.enabled && W()
    }), i("destroy", () => {
        k()
    }), i("touchStart", ($, X) => {
        e.zoom.enabled && P(X)
    }), i("touchEnd", ($, X) => {
        e.zoom.enabled && R()
    }), i("doubleTap", ($, X) => {
        !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && F(X)
    }), i("transitionEnd", () => {
        e.zoom.enabled && e.params.zoom.enabled && D()
    }), i("slideChange", () => {
        e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && D()
    }), Object.assign(e.zoom, {
        enable: W,
        disable: k,
        in: U,
        out: Q,
        toggle: F
    })
}

function V4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        controller: {
            control: void 0,
            inverse: !1,
            by: "slide"
        }
    }), e.controller = {
        control: void 0
    };

    function s(c, u) {
        const d = function () {
            let g, A, p;
            return (v, _) => {
                for (A = -1, g = v.length; g - A > 1;) p = g + A >> 1, v[p] <= _ ? A = p : g = p;
                return g
            }
        }();
        this.x = c, this.y = u, this.lastIndex = c.length - 1;
        let h, f;
        return this.interpolate = function (g) {
            return g ? (f = d(this.x, g), h = f - 1, (g - this.x[h]) * (this.y[f] - this.y[h]) / (this.x[f] - this.x[h]) + this.y[h]) : 0
        }, this
    }

    function r(c) {
        e.controller.spline = e.params.loop ? new s(e.slidesGrid, c.slidesGrid) : new s(e.snapGrid, c.snapGrid)
    }

    function o(c, u) {
        const d = e.controller.control;
        let h, f;
        const m = e.constructor;

        function g(A) {
            if (A.destroyed) return;
            const p = e.rtlTranslate ? -e.translate : e.translate;
            e.params.controller.by === "slide" && (r(A), f = -e.controller.spline.interpolate(-p)), (!f || e.params.controller.by === "container") && (h = (A.maxTranslate() - A.minTranslate()) / (e.maxTranslate() - e.minTranslate()), (Number.isNaN(h) || !Number.isFinite(h)) && (h = 1), f = (p - e.minTranslate()) * h + A.minTranslate()), e.params.controller.inverse && (f = A.maxTranslate() - f), A.updateProgress(f), A.setTranslate(f, e), A.updateActiveIndex(), A.updateSlidesClasses()
        }
        if (Array.isArray(d))
            for (let A = 0; A < d.length; A += 1) d[A] !== u && d[A] instanceof m && g(d[A]);
        else d instanceof m && u !== d && g(d)
    }

    function a(c, u) {
        const d = e.constructor,
            h = e.controller.control;
        let f;

        function m(g) {
            g.destroyed || (g.setTransition(c, e), c !== 0 && (g.transitionStart(), g.params.autoHeight && Ta(() => {
                g.updateAutoHeight()
            }), du(g.wrapperEl, () => {
                h && g.transitionEnd()
            })))
        }
        if (Array.isArray(h))
            for (f = 0; f < h.length; f += 1) h[f] !== u && h[f] instanceof d && m(h[f]);
        else h instanceof d && u !== h && m(h)
    }

    function l() {
        e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
    }
    i("beforeInit", () => {
        if (typeof window < "u" && (typeof e.params.controller.control == "string" || e.params.controller.control instanceof HTMLElement)) {
            const c = document.querySelector(e.params.controller.control);
            if (c && c.swiper) e.controller.control = c.swiper;
            else if (c) {
                const u = d => {
                    e.controller.control = d.detail[0], e.update(), c.removeEventListener("init", u)
                };
                c.addEventListener("init", u)
            }
            return
        }
        e.controller.control = e.params.controller.control
    }), i("update", () => {
        l()
    }), i("resize", () => {
        l()
    }), i("observerUpdate", () => {
        l()
    }), i("setTranslate", (c, u, d) => {
        !e.controller.control || e.controller.control.destroyed || e.controller.setTranslate(u, d)
    }), i("setTransition", (c, u, d) => {
        !e.controller.control || e.controller.control.destroyed || e.controller.setTransition(u, d)
    }), Object.assign(e.controller, {
        setTranslate: o,
        setTransition: a
    })
}

function W4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        a11y: {
            enabled: !0,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group",
            id: null
        }
    }), e.a11y = {
        clicked: !1
    };
    let s = null,
        r, o, a = new Date().getTime();

    function l(F) {
        const L = s;
        L.length !== 0 && (L.innerHTML = "", L.innerHTML = F)
    }

    function c(F) {
        F === void 0 && (F = 16);
        const L = () => Math.round(16 * Math.random()).toString(16);
        return "x".repeat(F).replace(/x/g, L)
    }

    function u(F) {
        F = ct(F), F.forEach(L => {
            L.setAttribute("tabIndex", "0")
        })
    }

    function d(F) {
        F = ct(F), F.forEach(L => {
            L.setAttribute("tabIndex", "-1")
        })
    }

    function h(F, L) {
        F = ct(F), F.forEach(W => {
            W.setAttribute("role", L)
        })
    }

    function f(F, L) {
        F = ct(F), F.forEach(W => {
            W.setAttribute("aria-roledescription", L)
        })
    }

    function m(F, L) {
        F = ct(F), F.forEach(W => {
            W.setAttribute("aria-controls", L)
        })
    }

    function g(F, L) {
        F = ct(F), F.forEach(W => {
            W.setAttribute("aria-label", L)
        })
    }

    function A(F, L) {
        F = ct(F), F.forEach(W => {
            W.setAttribute("id", L)
        })
    }

    function p(F, L) {
        F = ct(F), F.forEach(W => {
            W.setAttribute("aria-live", L)
        })
    }

    function v(F) {
        F = ct(F), F.forEach(L => {
            L.setAttribute("aria-disabled", !0)
        })
    }

    function _(F) {
        F = ct(F), F.forEach(L => {
            L.setAttribute("aria-disabled", !1)
        })
    }

    function b(F) {
        if (F.keyCode !== 13 && F.keyCode !== 32) return;
        const L = e.params.a11y,
            W = F.target;
        if (!(e.pagination && e.pagination.el && (W === e.pagination.el || e.pagination.el.contains(F.target)) && !F.target.matches(hr(e.params.pagination.bulletClass)))) {
            if (e.navigation && e.navigation.prevEl && e.navigation.nextEl) {
                const k = ct(e.navigation.prevEl);
                ct(e.navigation.nextEl).includes(W) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? l(L.lastSlideMessage) : l(L.nextSlideMessage)), k.includes(W) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? l(L.firstSlideMessage) : l(L.prevSlideMessage))
            }
            e.pagination && W.matches(hr(e.params.pagination.bulletClass)) && W.click()
        }
    }

    function w() {
        if (e.params.loop || e.params.rewind || !e.navigation) return;
        const {
            nextEl: F,
            prevEl: L
        } = e.navigation;
        L && (e.isBeginning ? (v(L), d(L)) : (_(L), u(L))), F && (e.isEnd ? (v(F), d(F)) : (_(F), u(F)))
    }

    function E() {
        return e.pagination && e.pagination.bullets && e.pagination.bullets.length
    }

    function C() {
        return E() && e.params.pagination.clickable
    }

    function S() {
        const F = e.params.a11y;
        E() && e.pagination.bullets.forEach(L => {
            e.params.pagination.clickable && (u(L), e.params.pagination.renderBullet || (h(L, "button"), g(L, F.paginationBulletMessage.replace(/\{\{index\}\}/, Qu(L) + 1)))), L.matches(hr(e.params.pagination.bulletActiveClass)) ? L.setAttribute("aria-current", "true") : L.removeAttribute("aria-current")
        })
    }
    const x = (F, L, W) => {
        u(F), F.tagName !== "BUTTON" && (h(F, "button"), F.addEventListener("keydown", b)), g(F, W), m(F, L)
    },
        y = F => {
            o && o !== F.target && !o.contains(F.target) && (r = !0), e.a11y.clicked = !0
        },
        P = () => {
            r = !1, requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    e.destroyed || (e.a11y.clicked = !1)
                })
            })
        },
        T = F => {
            a = new Date().getTime()
        },
        R = F => {
            if (e.a11y.clicked || new Date().getTime() - a < 100) return;
            const L = F.target.closest(`.${e.params.slideClass}, swiper-slide`);
            if (!L || !e.slides.includes(L)) return;
            o = L;
            const W = e.slides.indexOf(L) === e.activeIndex,
                k = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(L);
            W || k || F.sourceCapabilities && F.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, requestAnimationFrame(() => {
                r || (e.slideTo(e.slides.indexOf(L), 0), r = !1)
            }))
        },
        D = () => {
            const F = e.params.a11y;
            F.itemRoleDescriptionMessage && f(e.slides, F.itemRoleDescriptionMessage), F.slideRole && h(e.slides, F.slideRole);
            const L = e.slides.length;
            F.slideLabelMessage && e.slides.forEach((W, k) => {
                const $ = e.params.loop ? parseInt(W.getAttribute("data-swiper-slide-index"), 10) : k,
                    X = F.slideLabelMessage.replace(/\{\{index\}\}/, $ + 1).replace(/\{\{slidesLength\}\}/, L);
                g(W, X)
            })
        },
        U = () => {
            const F = e.params.a11y;
            e.el.append(s);
            const L = e.el;
            F.containerRoleDescriptionMessage && f(L, F.containerRoleDescriptionMessage), F.containerMessage && g(L, F.containerMessage);
            const W = e.wrapperEl,
                k = F.id || W.getAttribute("id") || `swiper-wrapper-${c(16)}`,
                $ = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite";
            A(W, k), p(W, $), D();
            let {
                nextEl: X,
                prevEl: le
            } = e.navigation ? e.navigation : {};
            X = ct(X), le = ct(le), X && X.forEach(te => x(te, k, F.nextSlideMessage)), le && le.forEach(te => x(te, k, F.prevSlideMessage)), C() && ct(e.pagination.el).forEach(ue => {
                ue.addEventListener("keydown", b)
            }), zi().addEventListener("visibilitychange", T), e.el.addEventListener("focus", R, !0), e.el.addEventListener("focus", R, !0), e.el.addEventListener("pointerdown", y, !0), e.el.addEventListener("pointerup", P, !0)
        };

    function Q() {
        s && s.remove();
        let {
            nextEl: F,
            prevEl: L
        } = e.navigation ? e.navigation : {};
        F = ct(F), L = ct(L), F && F.forEach(k => k.removeEventListener("keydown", b)), L && L.forEach(k => k.removeEventListener("keydown", b)), C() && ct(e.pagination.el).forEach($ => {
            $.removeEventListener("keydown", b)
        }), zi().removeEventListener("visibilitychange", T), e.el.removeEventListener("focus", R, !0), e.el.removeEventListener("pointerdown", y, !0), e.el.removeEventListener("pointerup", P, !0)
    }
    i("beforeInit", () => {
        s = Vn("span", e.params.a11y.notificationClass), s.setAttribute("aria-live", "assertive"), s.setAttribute("aria-atomic", "true")
    }), i("afterInit", () => {
        e.params.a11y.enabled && U()
    }), i("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
        e.params.a11y.enabled && D()
    }), i("fromEdge toEdge afterInit lock unlock", () => {
        e.params.a11y.enabled && w()
    }), i("paginationUpdate", () => {
        e.params.a11y.enabled && S()
    }), i("destroy", () => {
        e.params.a11y.enabled && Q()
    })
}

function q4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        history: {
            enabled: !1,
            root: "",
            replaceState: !1,
            key: "slides",
            keepQuery: !1
        }
    });
    let s = !1,
        r = {};
    const o = f => f.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
        a = f => {
            const m = ii();
            let g;
            f ? g = new URL(f) : g = m.location;
            const A = g.pathname.slice(1).split("/").filter(b => b !== ""),
                p = A.length,
                v = A[p - 2],
                _ = A[p - 1];
            return {
                key: v,
                value: _
            }
        },
        l = (f, m) => {
            const g = ii();
            if (!s || !e.params.history.enabled) return;
            let A;
            e.params.url ? A = new URL(e.params.url) : A = g.location;
            const p = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${m}"]`) : e.slides[m];
            let v = o(p.getAttribute("data-history"));
            if (e.params.history.root.length > 0) {
                let b = e.params.history.root;
                b[b.length - 1] === "/" && (b = b.slice(0, b.length - 1)), v = `${b}/${f ? `${f}/` : ""}${v}`
            } else A.pathname.includes(f) || (v = `${f ? `${f}/` : ""}${v}`);
            e.params.history.keepQuery && (v += A.search);
            const _ = g.history.state;
            _ && _.value === v || (e.params.history.replaceState ? g.history.replaceState({
                value: v
            }, null, v) : g.history.pushState({
                value: v
            }, null, v))
        },
        c = (f, m, g) => {
            if (m)
                for (let A = 0, p = e.slides.length; A < p; A += 1) {
                    const v = e.slides[A];
                    if (o(v.getAttribute("data-history")) === m) {
                        const b = e.getSlideIndex(v);
                        e.slideTo(b, f, g)
                    }
                } else e.slideTo(0, f, g)
        },
        u = () => {
            r = a(e.params.url), c(e.params.speed, r.value, !1)
        },
        d = () => {
            const f = ii();
            if (e.params.history) {
                if (!f.history || !f.history.pushState) {
                    e.params.history.enabled = !1, e.params.hashNavigation.enabled = !0;
                    return
                }
                if (s = !0, r = a(e.params.url), !r.key && !r.value) {
                    e.params.history.replaceState || f.addEventListener("popstate", u);
                    return
                }
                c(0, r.value, e.params.runCallbacksOnInit), e.params.history.replaceState || f.addEventListener("popstate", u)
            }
        },
        h = () => {
            const f = ii();
            e.params.history.replaceState || f.removeEventListener("popstate", u)
        };
    i("init", () => {
        e.params.history.enabled && d()
    }), i("destroy", () => {
        e.params.history.enabled && h()
    }), i("transitionEnd _freeModeNoMomentumRelease", () => {
        s && l(e.params.history.key, e.activeIndex)
    }), i("slideChange", () => {
        s && e.params.cssMode && l(e.params.history.key, e.activeIndex)
    })
}

function $4(n) {
    let {
        swiper: e,
        extendParams: t,
        emit: i,
        on: s
    } = n, r = !1;
    const o = zi(),
        a = ii();
    t({
        hashNavigation: {
            enabled: !1,
            replaceState: !1,
            watchState: !1,
            getSlideIndex(h, f) {
                if (e.virtual && e.params.virtual.enabled) {
                    const m = e.slides.filter(A => A.getAttribute("data-hash") === f)[0];
                    return m ? parseInt(m.getAttribute("data-swiper-slide-index"), 10) : 0
                }
                return e.getSlideIndex(Qi(e.slidesEl, `.${e.params.slideClass}[data-hash="${f}"], swiper-slide[data-hash="${f}"]`)[0])
            }
        }
    });
    const l = () => {
        i("hashChange");
        const h = o.location.hash.replace("#", ""),
            f = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex],
            m = f ? f.getAttribute("data-hash") : "";
        if (h !== m) {
            const g = e.params.hashNavigation.getSlideIndex(e, h);
            if (typeof g > "u" || Number.isNaN(g)) return;
            e.slideTo(g)
        }
    },
        c = () => {
            if (!r || !e.params.hashNavigation.enabled) return;
            const h = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex],
                f = h ? h.getAttribute("data-hash") || h.getAttribute("data-history") : "";
            e.params.hashNavigation.replaceState && a.history && a.history.replaceState ? (a.history.replaceState(null, null, `#${f}` || ""), i("hashSet")) : (o.location.hash = f || "", i("hashSet"))
        },
        u = () => {
            if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return;
            r = !0;
            const h = o.location.hash.replace("#", "");
            if (h) {
                const m = e.params.hashNavigation.getSlideIndex(e, h);
                e.slideTo(m || 0, 0, e.params.runCallbacksOnInit, !0)
            }
            e.params.hashNavigation.watchState && a.addEventListener("hashchange", l)
        },
        d = () => {
            e.params.hashNavigation.watchState && a.removeEventListener("hashchange", l)
        };
    s("init", () => {
        e.params.hashNavigation.enabled && u()
    }), s("destroy", () => {
        e.params.hashNavigation.enabled && d()
    }), s("transitionEnd _freeModeNoMomentumRelease", () => {
        r && c()
    }), s("slideChange", () => {
        r && e.params.cssMode && c()
    })
}

function j4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i,
        emit: s,
        params: r
    } = n;
    e.autoplay = {
        running: !1,
        paused: !1,
        timeLeft: 0
    }, t({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !1,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });
    let o, a, l = r && r.autoplay ? r.autoplay.delay : 3e3,
        c = r && r.autoplay ? r.autoplay.delay : 3e3,
        u, d = new Date().getTime(),
        h, f, m, g, A, p, v;

    function _(L) {
        !e || e.destroyed || !e.wrapperEl || L.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", _), !v && y())
    }
    const b = () => {
        if (e.destroyed || !e.autoplay.running) return;
        e.autoplay.paused ? h = !0 : h && (c = u, h = !1);
        const L = e.autoplay.paused ? u : d + c - new Date().getTime();
        e.autoplay.timeLeft = L, s("autoplayTimeLeft", L, L / l), a = requestAnimationFrame(() => {
            b()
        })
    },
        w = () => {
            let L;
            return e.virtual && e.params.virtual.enabled ? L = e.slides.filter(k => k.classList.contains("swiper-slide-active"))[0] : L = e.slides[e.activeIndex], L ? parseInt(L.getAttribute("data-swiper-autoplay"), 10) : void 0
        },
        E = L => {
            if (e.destroyed || !e.autoplay.running) return;
            cancelAnimationFrame(a), b();
            let W = typeof L > "u" ? e.params.autoplay.delay : L;
            l = e.params.autoplay.delay, c = e.params.autoplay.delay;
            const k = w();
            !Number.isNaN(k) && k > 0 && typeof L > "u" && (W = k, l = k, c = k), u = W;
            const $ = e.params.speed,
                X = () => {
                    !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev($, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, $, !0, !0), s("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext($, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, $, !0, !0), s("autoplay")), e.params.cssMode && (d = new Date().getTime(), requestAnimationFrame(() => {
                        E()
                    })))
                };
            return W > 0 ? (clearTimeout(o), o = setTimeout(() => {
                X()
            }, W)) : requestAnimationFrame(() => {
                X()
            }), W
        },
        C = () => {
            d = new Date().getTime(), e.autoplay.running = !0, E(), s("autoplayStart")
        },
        S = () => {
            e.autoplay.running = !1, clearTimeout(o), cancelAnimationFrame(a), s("autoplayStop")
        },
        x = (L, W) => {
            if (e.destroyed || !e.autoplay.running) return;
            clearTimeout(o), L || (p = !0);
            const k = () => {
                s("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", _) : y()
            };
            if (e.autoplay.paused = !0, W) {
                A && (u = e.params.autoplay.delay), A = !1, k();
                return
            }
            u = (u || e.params.autoplay.delay) - (new Date().getTime() - d), !(e.isEnd && u < 0 && !e.params.loop) && (u < 0 && (u = 0), k())
        },
        y = () => {
            e.isEnd && u < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (d = new Date().getTime(), p ? (p = !1, E(u)) : E(), e.autoplay.paused = !1, s("autoplayResume"))
        },
        P = () => {
            if (e.destroyed || !e.autoplay.running) return;
            const L = zi();
            L.visibilityState === "hidden" && (p = !0, x(!0)), L.visibilityState === "visible" && y()
        },
        T = L => {
            L.pointerType === "mouse" && (p = !0, v = !0, !(e.animating || e.autoplay.paused) && x(!0))
        },
        R = L => {
            L.pointerType === "mouse" && (v = !1, e.autoplay.paused && y())
        },
        D = () => {
            e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", T), e.el.addEventListener("pointerleave", R))
        },
        U = () => {
            e.el.removeEventListener("pointerenter", T), e.el.removeEventListener("pointerleave", R)
        },
        Q = () => {
            zi().addEventListener("visibilitychange", P)
        },
        F = () => {
            zi().removeEventListener("visibilitychange", P)
        };
    i("init", () => {
        e.params.autoplay.enabled && (D(), Q(), C())
    }), i("destroy", () => {
        U(), F(), e.autoplay.running && S()
    }), i("_freeModeStaticRelease", () => {
        (m || p) && y()
    }), i("_freeModeNoMomentumRelease", () => {
        e.params.autoplay.disableOnInteraction ? S() : x(!0, !0)
    }), i("beforeTransitionStart", (L, W, k) => {
        e.destroyed || !e.autoplay.running || (k || !e.params.autoplay.disableOnInteraction ? x(!0, !0) : S())
    }), i("sliderFirstMove", () => {
        if (!(e.destroyed || !e.autoplay.running)) {
            if (e.params.autoplay.disableOnInteraction) {
                S();
                return
            }
            f = !0, m = !1, p = !1, g = setTimeout(() => {
                p = !0, m = !0, x(!0)
            }, 200)
        }
    }), i("touchEnd", () => {
        if (!(e.destroyed || !e.autoplay.running || !f)) {
            if (clearTimeout(g), clearTimeout(o), e.params.autoplay.disableOnInteraction) {
                m = !1, f = !1;
                return
            }
            m && e.params.cssMode && y(), m = !1, f = !1
        }
    }), i("slideChange", () => {
        e.destroyed || !e.autoplay.running || (A = !0)
    }), Object.assign(e.autoplay, {
        start: C,
        stop: S,
        pause: x,
        resume: y
    })
}

function Y4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        thumbs: {
            swiper: null,
            multipleActiveThumbs: !0,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-thumbs"
        }
    });
    let s = !1,
        r = !1;
    e.thumbs = {
        swiper: null
    };

    function o() {
        const c = e.thumbs.swiper;
        if (!c || c.destroyed) return;
        const u = c.clickedIndex,
            d = c.clickedSlide;
        if (d && d.classList.contains(e.params.thumbs.slideThumbActiveClass) || typeof u > "u" || u === null) return;
        let h;
        c.params.loop ? h = parseInt(c.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : h = u, e.params.loop ? e.slideToLoop(h) : e.slideTo(h)
    }

    function a() {
        const {
            thumbs: c
        } = e.params;
        if (s) return !1;
        s = !0;
        const u = e.constructor;
        if (c.swiper instanceof u) e.thumbs.swiper = c.swiper, Object.assign(e.thumbs.swiper.originalParams, {
            watchSlidesProgress: !0,
            slideToClickedSlide: !1
        }), Object.assign(e.thumbs.swiper.params, {
            watchSlidesProgress: !0,
            slideToClickedSlide: !1
        }), e.thumbs.swiper.update();
        else if (Oc(c.swiper)) {
            const d = Object.assign({}, c.swiper);
            Object.assign(d, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), e.thumbs.swiper = new u(d), r = !0
        }
        return e.thumbs.swiper.el.classList.add(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", o), !0
    }

    function l(c) {
        const u = e.thumbs.swiper;
        if (!u || u.destroyed) return;
        const d = u.params.slidesPerView === "auto" ? u.slidesPerViewDynamic() : u.params.slidesPerView;
        let h = 1;
        const f = e.params.thumbs.slideThumbActiveClass;
        if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (h = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (h = 1), h = Math.floor(h), u.slides.forEach(A => A.classList.remove(f)), u.params.loop || u.params.virtual && u.params.virtual.enabled)
            for (let A = 0; A < h; A += 1) Qi(u.slidesEl, `[data-swiper-slide-index="${e.realIndex + A}"]`).forEach(p => {
                p.classList.add(f)
            });
        else
            for (let A = 0; A < h; A += 1) u.slides[e.realIndex + A] && u.slides[e.realIndex + A].classList.add(f);
        const m = e.params.thumbs.autoScrollOffset,
            g = m && !u.params.loop;
        if (e.realIndex !== u.realIndex || g) {
            const A = u.activeIndex;
            let p, v;
            if (u.params.loop) {
                const _ = u.slides.filter(b => b.getAttribute("data-swiper-slide-index") === `${e.realIndex}`)[0];
                p = u.slides.indexOf(_), v = e.activeIndex > e.previousIndex ? "next" : "prev"
            } else p = e.realIndex, v = p > e.previousIndex ? "next" : "prev";
            g && (p += v === "next" ? m : -1 * m), u.visibleSlidesIndexes && u.visibleSlidesIndexes.indexOf(p) < 0 && (u.params.centeredSlides ? p > A ? p = p - Math.floor(d / 2) + 1 : p = p + Math.floor(d / 2) - 1 : p > A && u.params.slidesPerGroup, u.slideTo(p, c ? 0 : void 0))
        }
    }
    i("beforeInit", () => {
        const {
            thumbs: c
        } = e.params;
        if (!(!c || !c.swiper))
            if (typeof c.swiper == "string" || c.swiper instanceof HTMLElement) {
                const u = zi(),
                    d = () => {
                        const f = typeof c.swiper == "string" ? u.querySelector(c.swiper) : c.swiper;
                        if (f && f.swiper) c.swiper = f.swiper, a(), l(!0);
                        else if (f) {
                            const m = g => {
                                c.swiper = g.detail[0], f.removeEventListener("init", m), a(), l(!0), c.swiper.update(), e.update()
                            };
                            f.addEventListener("init", m)
                        }
                        return f
                    },
                    h = () => {
                        if (e.destroyed) return;
                        d() || requestAnimationFrame(h)
                    };
                requestAnimationFrame(h)
            } else a(), l(!0)
    }), i("slideChange update resize observerUpdate", () => {
        l()
    }), i("setTransition", (c, u) => {
        const d = e.thumbs.swiper;
        !d || d.destroyed || d.setTransition(u)
    }), i("beforeDestroy", () => {
        const c = e.thumbs.swiper;
        !c || c.destroyed || r && c.destroy()
    }), Object.assign(e.thumbs, {
        init: a,
        update: l
    })
}

function X4(n) {
    let {
        swiper: e,
        extendParams: t,
        emit: i,
        once: s
    } = n;
    t({
        freeMode: {
            enabled: !1,
            momentum: !0,
            momentumRatio: 1,
            momentumBounce: !0,
            momentumBounceRatio: 1,
            momentumVelocityRatio: 1,
            sticky: !1,
            minimumVelocity: .02
        }
    });

    function r() {
        if (e.params.cssMode) return;
        const l = e.getTranslate();
        e.setTranslate(l), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({
            currentPos: e.rtl ? e.translate : -e.translate
        })
    }

    function o() {
        if (e.params.cssMode) return;
        const {
            touchEventsData: l,
            touches: c
        } = e;
        l.velocities.length === 0 && l.velocities.push({
            position: c[e.isHorizontal() ? "startX" : "startY"],
            time: l.touchStartTime
        }), l.velocities.push({
            position: c[e.isHorizontal() ? "currentX" : "currentY"],
            time: ns()
        })
    }

    function a(l) {
        let {
            currentPos: c
        } = l;
        if (e.params.cssMode) return;
        const {
            params: u,
            wrapperEl: d,
            rtlTranslate: h,
            snapGrid: f,
            touchEventsData: m
        } = e, A = ns() - m.touchStartTime;
        if (c < -e.minTranslate()) {
            e.slideTo(e.activeIndex);
            return
        }
        if (c > -e.maxTranslate()) {
            e.slides.length < f.length ? e.slideTo(f.length - 1) : e.slideTo(e.slides.length - 1);
            return
        }
        if (u.freeMode.momentum) {
            if (m.velocities.length > 1) {
                const S = m.velocities.pop(),
                    x = m.velocities.pop(),
                    y = S.position - x.position,
                    P = S.time - x.time;
                e.velocity = y / P, e.velocity /= 2, Math.abs(e.velocity) < u.freeMode.minimumVelocity && (e.velocity = 0), (P > 150 || ns() - S.time > 300) && (e.velocity = 0)
            } else e.velocity = 0;
            e.velocity *= u.freeMode.momentumVelocityRatio, m.velocities.length = 0;
            let p = 1e3 * u.freeMode.momentumRatio;
            const v = e.velocity * p;
            let _ = e.translate + v;
            h && (_ = -_);
            let b = !1,
                w;
            const E = Math.abs(e.velocity) * 20 * u.freeMode.momentumBounceRatio;
            let C;
            if (_ < e.maxTranslate()) u.freeMode.momentumBounce ? (_ + e.maxTranslate() < -E && (_ = e.maxTranslate() - E), w = e.maxTranslate(), b = !0, m.allowMomentumBounce = !0) : _ = e.maxTranslate(), u.loop && u.centeredSlides && (C = !0);
            else if (_ > e.minTranslate()) u.freeMode.momentumBounce ? (_ - e.minTranslate() > E && (_ = e.minTranslate() + E), w = e.minTranslate(), b = !0, m.allowMomentumBounce = !0) : _ = e.minTranslate(), u.loop && u.centeredSlides && (C = !0);
            else if (u.freeMode.sticky) {
                let S;
                for (let x = 0; x < f.length; x += 1)
                    if (f[x] > -_) {
                        S = x;
                        break
                    }
                Math.abs(f[S] - _) < Math.abs(f[S - 1] - _) || e.swipeDirection === "next" ? _ = f[S] : _ = f[S - 1], _ = -_
            }
            if (C && s("transitionEnd", () => {
                e.loopFix()
            }), e.velocity !== 0) {
                if (h ? p = Math.abs((-_ - e.translate) / e.velocity) : p = Math.abs((_ - e.translate) / e.velocity), u.freeMode.sticky) {
                    const S = Math.abs((h ? -_ : _) - e.translate),
                        x = e.slidesSizesGrid[e.activeIndex];
                    S < x ? p = u.speed : S < 2 * x ? p = u.speed * 1.5 : p = u.speed * 2.5
                }
            } else if (u.freeMode.sticky) {
                e.slideToClosest();
                return
            }
            u.freeMode.momentumBounce && b ? (e.updateProgress(w), e.setTransition(p), e.setTranslate(_), e.transitionStart(!0, e.swipeDirection), e.animating = !0, du(d, () => {
                !e || e.destroyed || !m.allowMomentumBounce || (i("momentumBounce"), e.setTransition(u.speed), setTimeout(() => {
                    e.setTranslate(w), du(d, () => {
                        !e || e.destroyed || e.transitionEnd()
                    })
                }, 0))
            })) : e.velocity ? (i("_freeModeNoMomentumRelease"), e.updateProgress(_), e.setTransition(p), e.setTranslate(_), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, du(d, () => {
                !e || e.destroyed || e.transitionEnd()
            }))) : e.updateProgress(_), e.updateActiveIndex(), e.updateSlidesClasses()
        } else if (u.freeMode.sticky) {
            e.slideToClosest();
            return
        } else u.freeMode && i("_freeModeNoMomentumRelease");
        (!u.freeMode.momentum || A >= u.longSwipesMs) && (i("_freeModeStaticRelease"), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses())
    }
    Object.assign(e, {
        freeMode: {
            onTouchStart: r,
            onTouchMove: o,
            onTouchEnd: a
        }
    })
}

function K4(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        grid: {
            rows: 1,
            fill: "column"
        }
    });
    let s, r, o, a;
    const l = () => {
        let g = e.params.spaceBetween;
        return typeof g == "string" && g.indexOf("%") >= 0 ? g = parseFloat(g.replace("%", "")) / 100 * e.size : typeof g == "string" && (g = parseFloat(g)), g
    },
        c = g => {
            const {
                slidesPerView: A
            } = e.params, {
                rows: p,
                fill: v
            } = e.params.grid, _ = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : g.length;
            o = Math.floor(_ / p), Math.floor(_ / p) === _ / p ? s = _ : s = Math.ceil(_ / p) * p, A !== "auto" && v === "row" && (s = Math.max(s, A * p)), r = s / p
        },
        u = () => {
            e.slides && e.slides.forEach(g => {
                g.swiperSlideGridSet && (g.style.height = "", g.style[e.getDirectionLabel("margin-top")] = "")
            })
        },
        d = (g, A, p) => {
            const {
                slidesPerGroup: v
            } = e.params, _ = l(), {
                rows: b,
                fill: w
            } = e.params.grid, E = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : p.length;
            let C, S, x;
            if (w === "row" && v > 1) {
                const y = Math.floor(g / (v * b)),
                    P = g - b * v * y,
                    T = y === 0 ? v : Math.min(Math.ceil((E - y * b * v) / b), v);
                x = Math.floor(P / T), S = P - x * T + y * v, C = S + x * s / b, A.style.order = C
            } else w === "column" ? (S = Math.floor(g / b), x = g - S * b, (S > o || S === o && x === b - 1) && (x += 1, x >= b && (x = 0, S += 1))) : (x = Math.floor(g / r), S = g - x * r);
            A.row = x, A.column = S, A.style.height = `calc((100% - ${(b - 1) * _}px) / ${b})`, A.style[e.getDirectionLabel("margin-top")] = x !== 0 ? _ && `${_}px` : "", A.swiperSlideGridSet = !0
        },
        h = (g, A) => {
            const {
                centeredSlides: p,
                roundLengths: v
            } = e.params, _ = l(), {
                rows: b
            } = e.params.grid;
            if (e.virtualSize = (g + _) * s, e.virtualSize = Math.ceil(e.virtualSize / b) - _, e.params.cssMode || (e.wrapperEl.style[e.getDirectionLabel("width")] = `${e.virtualSize + _}px`), p) {
                const w = [];
                for (let E = 0; E < A.length; E += 1) {
                    let C = A[E];
                    v && (C = Math.floor(C)), A[E] < e.virtualSize + A[0] && w.push(C)
                }
                A.splice(0, A.length), A.push(...w)
            }
        },
        f = () => {
            a = e.params.grid && e.params.grid.rows > 1
        },
        m = () => {
            const {
                params: g,
                el: A
            } = e, p = g.grid && g.grid.rows > 1;
            a && !p ? (A.classList.remove(`${g.containerModifierClass}grid`, `${g.containerModifierClass}grid-column`), o = 1, e.emitContainerClasses()) : !a && p && (A.classList.add(`${g.containerModifierClass}grid`), g.grid.fill === "column" && A.classList.add(`${g.containerModifierClass}grid-column`), e.emitContainerClasses()), a = p
        };
    i("init", f), i("update", m), e.grid = {
        initSlides: c,
        unsetSlides: u,
        updateSlide: d,
        updateWrapperSize: h
    }
}

function J4(n) {
    const e = this,
        {
            params: t,
            slidesEl: i
        } = e;
    t.loop && e.loopDestroy();
    const s = r => {
        if (typeof r == "string") {
            const o = document.createElement("div");
            o.innerHTML = r, i.append(o.children[0]), o.innerHTML = ""
        } else i.append(r)
    };
    if (typeof n == "object" && "length" in n)
        for (let r = 0; r < n.length; r += 1) n[r] && s(n[r]);
    else s(n);
    e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update()
}

function Z4(n) {
    const e = this,
        {
            params: t,
            activeIndex: i,
            slidesEl: s
        } = e;
    t.loop && e.loopDestroy();
    let r = i + 1;
    const o = a => {
        if (typeof a == "string") {
            const l = document.createElement("div");
            l.innerHTML = a, s.prepend(l.children[0]), l.innerHTML = ""
        } else s.prepend(a)
    };
    if (typeof n == "object" && "length" in n) {
        for (let a = 0; a < n.length; a += 1) n[a] && o(n[a]);
        r = i + n.length
    } else o(n);
    e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), e.slideTo(r, 0, !1)
}

function e9(n, e) {
    const t = this,
        {
            params: i,
            activeIndex: s,
            slidesEl: r
        } = t;
    let o = s;
    i.loop && (o -= t.loopedSlides, t.loopDestroy(), t.recalcSlides());
    const a = t.slides.length;
    if (n <= 0) {
        t.prependSlide(e);
        return
    }
    if (n >= a) {
        t.appendSlide(e);
        return
    }
    let l = o > n ? o + 1 : o;
    const c = [];
    for (let u = a - 1; u >= n; u -= 1) {
        const d = t.slides[u];
        d.remove(), c.unshift(d)
    }
    if (typeof e == "object" && "length" in e) {
        for (let u = 0; u < e.length; u += 1) e[u] && r.append(e[u]);
        l = o > n ? o + e.length : o
    } else r.append(e);
    for (let u = 0; u < c.length; u += 1) r.append(c[u]);
    t.recalcSlides(), i.loop && t.loopCreate(), (!i.observer || t.isElement) && t.update(), i.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1)
}

function t9(n) {
    const e = this,
        {
            params: t,
            activeIndex: i
        } = e;
    let s = i;
    t.loop && (s -= e.loopedSlides, e.loopDestroy());
    let r = s,
        o;
    if (typeof n == "object" && "length" in n) {
        for (let a = 0; a < n.length; a += 1) o = n[a], e.slides[o] && e.slides[o].remove(), o < r && (r -= 1);
        r = Math.max(r, 0)
    } else o = n, e.slides[o] && e.slides[o].remove(), o < r && (r -= 1), r = Math.max(r, 0);
    e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), t.loop ? e.slideTo(r + e.loopedSlides, 0, !1) : e.slideTo(r, 0, !1)
}

function i9() {
    const n = this,
        e = [];
    for (let t = 0; t < n.slides.length; t += 1) e.push(t);
    n.removeSlide(e)
}

function n9(n) {
    let {
        swiper: e
    } = n;
    Object.assign(e, {
        appendSlide: J4.bind(e),
        prependSlide: Z4.bind(e),
        addSlide: e9.bind(e),
        removeSlide: t9.bind(e),
        removeAllSlides: i9.bind(e)
    })
}

function oc(n) {
    const {
        effect: e,
        swiper: t,
        on: i,
        setTranslate: s,
        setTransition: r,
        overwriteParams: o,
        perspective: a,
        recreateShadows: l,
        getEffectParams: c
    } = n;
    i("beforeInit", () => {
        if (t.params.effect !== e) return;
        t.classNames.push(`${t.params.containerModifierClass}${e}`), a && a() && t.classNames.push(`${t.params.containerModifierClass}3d`);
        const d = o ? o() : {};
        Object.assign(t.params, d), Object.assign(t.originalParams, d)
    }), i("setTranslate", () => {
        t.params.effect === e && s()
    }), i("setTransition", (d, h) => {
        t.params.effect === e && r(h)
    }), i("transitionEnd", () => {
        if (t.params.effect === e && l) {
            if (!c || !c().slideShadows) return;
            t.slides.forEach(d => {
                d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(h => h.remove())
            }), l()
        }
    });
    let u;
    i("virtualUpdate", () => {
        t.params.effect === e && (t.slides.length || (u = !0), requestAnimationFrame(() => {
            u && t.slides && t.slides.length && (s(), u = !1)
        }))
    })
}

function Ju(n, e) {
    const t = Ra(e);
    return t !== e && (t.style.backfaceVisibility = "hidden", t.style["-webkit-backface-visibility"] = "hidden"), t
}

function Yf(n) {
    let {
        swiper: e,
        duration: t,
        transformElements: i,
        allSlides: s
    } = n;
    const {
        activeIndex: r
    } = e, o = a => a.parentElement ? a.parentElement : e.slides.filter(c => c.shadowRoot && c.shadowRoot === a.parentNode)[0];
    if (e.params.virtualTranslate && t !== 0) {
        let a = !1,
            l;
        s ? l = i : l = i.filter(c => {
            const u = c.classList.contains("swiper-slide-transform") ? o(c) : c;
            return e.getSlideIndex(u) === r
        }), l.forEach(c => {
            du(c, () => {
                if (a || !e || e.destroyed) return;
                a = !0, e.animating = !1;
                const u = new window.CustomEvent("transitionend", {
                    bubbles: !0,
                    cancelable: !0
                });
                e.wrapperEl.dispatchEvent(u)
            })
        })
    }
}

function s9(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        fadeEffect: {
            crossFade: !1
        }
    }), oc({
        effect: "fade",
        swiper: e,
        on: i,
        setTranslate: () => {
            const {
                slides: o
            } = e, a = e.params.fadeEffect;
            for (let l = 0; l < o.length; l += 1) {
                const c = e.slides[l];
                let d = -c.swiperSlideOffset;
                e.params.virtualTranslate || (d -= e.translate);
                let h = 0;
                e.isHorizontal() || (h = d, d = 0);
                const f = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(c.progress), 0) : 1 + Math.min(Math.max(c.progress, -1), 0),
                    m = Ju(a, c);
                m.style.opacity = f, m.style.transform = `translate3d(${d}px, ${h}px, 0px)`
            }
        },
        setTransition: o => {
            const a = e.slides.map(l => Ra(l));
            a.forEach(l => {
                l.style.transitionDuration = `${o}ms`
            }), Yf({
                swiper: e,
                duration: o,
                transformElements: a,
                allSlides: !0
            })
        },
        overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            spaceBetween: 0,
            virtualTranslate: !e.params.cssMode
        })
    })
}

function r9(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        cubeEffect: {
            slideShadows: !0,
            shadow: !0,
            shadowOffset: 20,
            shadowScale: .94
        }
    });
    const s = (l, c, u) => {
        let d = u ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"),
            h = u ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom");
        d || (d = Vn("div", `swiper-slide-shadow-cube swiper-slide-shadow-${u ? "left" : "top"}`.split(" ")), l.append(d)), h || (h = Vn("div", `swiper-slide-shadow-cube swiper-slide-shadow-${u ? "right" : "bottom"}`.split(" ")), l.append(h)), d && (d.style.opacity = Math.max(-c, 0)), h && (h.style.opacity = Math.max(c, 0))
    };
    oc({
        effect: "cube",
        swiper: e,
        on: i,
        setTranslate: () => {
            const {
                el: l,
                wrapperEl: c,
                slides: u,
                width: d,
                height: h,
                rtlTranslate: f,
                size: m,
                browser: g
            } = e, A = e.params.cubeEffect, p = e.isHorizontal(), v = e.virtual && e.params.virtual.enabled;
            let _ = 0,
                b;
            A.shadow && (p ? (b = e.wrapperEl.querySelector(".swiper-cube-shadow"), b || (b = Vn("div", "swiper-cube-shadow"), e.wrapperEl.append(b)), b.style.height = `${d}px`) : (b = l.querySelector(".swiper-cube-shadow"), b || (b = Vn("div", "swiper-cube-shadow"), l.append(b))));
            for (let E = 0; E < u.length; E += 1) {
                const C = u[E];
                let S = E;
                v && (S = parseInt(C.getAttribute("data-swiper-slide-index"), 10));
                let x = S * 90,
                    y = Math.floor(x / 360);
                f && (x = -x, y = Math.floor(-x / 360));
                const P = Math.max(Math.min(C.progress, 1), -1);
                let T = 0,
                    R = 0,
                    D = 0;
                S % 4 === 0 ? (T = -y * 4 * m, D = 0) : (S - 1) % 4 === 0 ? (T = 0, D = -y * 4 * m) : (S - 2) % 4 === 0 ? (T = m + y * 4 * m, D = m) : (S - 3) % 4 === 0 && (T = -m, D = 3 * m + m * 4 * y), f && (T = -T), p || (R = T, T = 0);
                const U = `rotateX(${p ? 0 : -x}deg) rotateY(${p ? x : 0}deg) translate3d(${T}px, ${R}px, ${D}px)`;
                P <= 1 && P > -1 && (_ = S * 90 + P * 90, f && (_ = -S * 90 - P * 90), e.browser && e.browser.need3dFix && Math.abs(_) / 90 % 2 === 1 && (_ += .001)), C.style.transform = U, A.slideShadows && s(C, P, p)
            }
            if (c.style.transformOrigin = `50% 50% -${m / 2}px`, c.style["-webkit-transform-origin"] = `50% 50% -${m / 2}px`, A.shadow)
                if (p) b.style.transform = `translate3d(0px, ${d / 2 + A.shadowOffset}px, ${-d / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${A.shadowScale})`;
                else {
                    const E = Math.abs(_) - Math.floor(Math.abs(_) / 90) * 90,
                        C = 1.5 - (Math.sin(E * 2 * Math.PI / 360) / 2 + Math.cos(E * 2 * Math.PI / 360) / 2),
                        S = A.shadowScale,
                        x = A.shadowScale / C,
                        y = A.shadowOffset;
                    b.style.transform = `scale3d(${S}, 1, ${x}) translate3d(0px, ${h / 2 + y}px, ${-h / 2 / x}px) rotateX(-89.99deg)`
                }
            const w = (g.isSafari || g.isWebView) && g.needPerspectiveFix ? -m / 2 : 0;
            c.style.transform = `translate3d(0px,0,${w}px) rotateX(${e.isHorizontal() ? 0 : _}deg) rotateY(${e.isHorizontal() ? -_ : 0}deg)`, c.style.setProperty("--swiper-cube-translate-z", `${w}px`)
        },
        setTransition: l => {
            const {
                el: c,
                slides: u
            } = e;
            if (u.forEach(d => {
                d.style.transitionDuration = `${l}ms`, d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(h => {
                    h.style.transitionDuration = `${l}ms`
                })
            }), e.params.cubeEffect.shadow && !e.isHorizontal()) {
                const d = c.querySelector(".swiper-cube-shadow");
                d && (d.style.transitionDuration = `${l}ms`)
            }
        },
        recreateShadows: () => {
            const l = e.isHorizontal();
            e.slides.forEach(c => {
                const u = Math.max(Math.min(c.progress, 1), -1);
                s(c, u, l)
            })
        },
        getEffectParams: () => e.params.cubeEffect,
        perspective: () => !0,
        overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            resistanceRatio: 0,
            spaceBetween: 0,
            centeredSlides: !1,
            virtualTranslate: !0
        })
    })
}

function Jl(n, e, t) {
    const i = `swiper-slide-shadow${t ? `-${t}` : ""}${n ? ` swiper-slide-shadow-${n}` : ""}`,
        s = Ra(e);
    let r = s.querySelector(`.${i.split(" ").join(".")}`);
    return r || (r = Vn("div", i.split(" ")), s.append(r)), r
}

function o9(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        flipEffect: {
            slideShadows: !0,
            limitRotation: !0
        }
    });
    const s = (l, c) => {
        let u = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"),
            d = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom");
        u || (u = Jl("flip", l, e.isHorizontal() ? "left" : "top")), d || (d = Jl("flip", l, e.isHorizontal() ? "right" : "bottom")), u && (u.style.opacity = Math.max(-c, 0)), d && (d.style.opacity = Math.max(c, 0))
    };
    oc({
        effect: "flip",
        swiper: e,
        on: i,
        setTranslate: () => {
            const {
                slides: l,
                rtlTranslate: c
            } = e, u = e.params.flipEffect;
            for (let d = 0; d < l.length; d += 1) {
                const h = l[d];
                let f = h.progress;
                e.params.flipEffect.limitRotation && (f = Math.max(Math.min(h.progress, 1), -1));
                const m = h.swiperSlideOffset;
                let A = -180 * f,
                    p = 0,
                    v = e.params.cssMode ? -m - e.translate : -m,
                    _ = 0;
                e.isHorizontal() ? c && (A = -A) : (_ = v, v = 0, p = -A, A = 0), e.browser && e.browser.need3dFix && (Math.abs(A) / 90 % 2 === 1 && (A += .001), Math.abs(p) / 90 % 2 === 1 && (p += .001)), h.style.zIndex = -Math.abs(Math.round(f)) + l.length, u.slideShadows && s(h, f);
                const b = `translate3d(${v}px, ${_}px, 0px) rotateX(${p}deg) rotateY(${A}deg)`,
                    w = Ju(u, h);
                w.style.transform = b
            }
        },
        setTransition: l => {
            const c = e.slides.map(u => Ra(u));
            c.forEach(u => {
                u.style.transitionDuration = `${l}ms`, u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(d => {
                    d.style.transitionDuration = `${l}ms`
                })
            }), Yf({
                swiper: e,
                duration: l,
                transformElements: c
            })
        },
        recreateShadows: () => {
            e.params.flipEffect, e.slides.forEach(l => {
                let c = l.progress;
                e.params.flipEffect.limitRotation && (c = Math.max(Math.min(l.progress, 1), -1)), s(l, c)
            })
        },
        getEffectParams: () => e.params.flipEffect,
        perspective: () => !0,
        overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            spaceBetween: 0,
            virtualTranslate: !e.params.cssMode
        })
    })
}

function a9(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: !0
        }
    }), oc({
        effect: "coverflow",
        swiper: e,
        on: i,
        setTranslate: () => {
            const {
                width: o,
                height: a,
                slides: l,
                slidesSizesGrid: c
            } = e, u = e.params.coverflowEffect, d = e.isHorizontal(), h = e.translate, f = d ? -h + o / 2 : -h + a / 2, m = d ? u.rotate : -u.rotate, g = u.depth;
            for (let A = 0, p = l.length; A < p; A += 1) {
                const v = l[A],
                    _ = c[A],
                    b = v.swiperSlideOffset,
                    w = (f - b - _ / 2) / _,
                    E = typeof u.modifier == "function" ? u.modifier(w) : w * u.modifier;
                let C = d ? m * E : 0,
                    S = d ? 0 : m * E,
                    x = -g * Math.abs(E),
                    y = u.stretch;
                typeof y == "string" && y.indexOf("%") !== -1 && (y = parseFloat(u.stretch) / 100 * _);
                let P = d ? 0 : y * E,
                    T = d ? y * E : 0,
                    R = 1 - (1 - u.scale) * Math.abs(E);
                Math.abs(T) < .001 && (T = 0), Math.abs(P) < .001 && (P = 0), Math.abs(x) < .001 && (x = 0), Math.abs(C) < .001 && (C = 0), Math.abs(S) < .001 && (S = 0), Math.abs(R) < .001 && (R = 0), e.browser && e.browser.need3dFix && (Math.abs(C) / 90 % 2 === 1 && (C += .001), Math.abs(S) / 90 % 2 === 1 && (S += .001));
                const D = `translate3d(${T}px,${P}px,${x}px)  rotateX(${S}deg) rotateY(${C}deg) scale(${R})`,
                    U = Ju(u, v);
                if (U.style.transform = D, v.style.zIndex = -Math.abs(Math.round(E)) + 1, u.slideShadows) {
                    let Q = d ? v.querySelector(".swiper-slide-shadow-left") : v.querySelector(".swiper-slide-shadow-top"),
                        F = d ? v.querySelector(".swiper-slide-shadow-right") : v.querySelector(".swiper-slide-shadow-bottom");
                    Q || (Q = Jl("coverflow", v, d ? "left" : "top")), F || (F = Jl("coverflow", v, d ? "right" : "bottom")), Q && (Q.style.opacity = E > 0 ? E : 0), F && (F.style.opacity = -E > 0 ? -E : 0)
                }
            }
        },
        setTransition: o => {
            e.slides.map(l => Ra(l)).forEach(l => {
                l.style.transitionDuration = `${o}ms`, l.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(c => {
                    c.style.transitionDuration = `${o}ms`
                })
            })
        },
        perspective: () => !0,
        overwriteParams: () => ({
            watchSlidesProgress: !0
        })
    })
}

function l9(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        creativeEffect: {
            limitProgress: 1,
            shadowPerProgress: !1,
            progressMultiplier: 1,
            perspective: !0,
            prev: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
            },
            next: {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                opacity: 1,
                scale: 1
            }
        }
    });
    const s = a => typeof a == "string" ? a : `${a}px`;
    oc({
        effect: "creative",
        swiper: e,
        on: i,
        setTranslate: () => {
            const {
                slides: a,
                wrapperEl: l,
                slidesSizesGrid: c
            } = e, u = e.params.creativeEffect, {
                progressMultiplier: d
            } = u, h = e.params.centeredSlides;
            if (h) {
                const f = c[0] / 2 - e.params.slidesOffsetBefore || 0;
                l.style.transform = `translateX(calc(50% - ${f}px))`
            }
            for (let f = 0; f < a.length; f += 1) {
                const m = a[f],
                    g = m.progress,
                    A = Math.min(Math.max(m.progress, -u.limitProgress), u.limitProgress);
                let p = A;
                h || (p = Math.min(Math.max(m.originalProgress, -u.limitProgress), u.limitProgress));
                const v = m.swiperSlideOffset,
                    _ = [e.params.cssMode ? -v - e.translate : -v, 0, 0],
                    b = [0, 0, 0];
                let w = !1;
                e.isHorizontal() || (_[1] = _[0], _[0] = 0);
                let E = {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    scale: 1,
                    opacity: 1
                };
                A < 0 ? (E = u.next, w = !0) : A > 0 && (E = u.prev, w = !0), _.forEach((R, D) => {
                    _[D] = `calc(${R}px + (${s(E.translate[D])} * ${Math.abs(A * d)}))`
                }), b.forEach((R, D) => {
                    let U = E.rotate[D] * Math.abs(A * d);
                    e.browser && e.browser.need3dFix && Math.abs(U) / 90 % 2 === 1 && (U += .001), b[D] = U
                }), m.style.zIndex = -Math.abs(Math.round(g)) + a.length;
                const C = _.join(", "),
                    S = `rotateX(${b[0]}deg) rotateY(${b[1]}deg) rotateZ(${b[2]}deg)`,
                    x = p < 0 ? `scale(${1 + (1 - E.scale) * p * d})` : `scale(${1 - (1 - E.scale) * p * d})`,
                    y = p < 0 ? 1 + (1 - E.opacity) * p * d : 1 - (1 - E.opacity) * p * d,
                    P = `translate3d(${C}) ${S} ${x}`;
                if (w && E.shadow || !w) {
                    let R = m.querySelector(".swiper-slide-shadow");
                    if (!R && E.shadow && (R = Jl("creative", m)), R) {
                        const D = u.shadowPerProgress ? A * (1 / u.limitProgress) : A;
                        R.style.opacity = Math.min(Math.max(Math.abs(D), 0), 1)
                    }
                }
                const T = Ju(u, m);
                T.style.transform = P, T.style.opacity = y, E.origin && (T.style.transformOrigin = E.origin)
            }
        },
        setTransition: a => {
            const l = e.slides.map(c => Ra(c));
            l.forEach(c => {
                c.style.transitionDuration = `${a}ms`, c.querySelectorAll(".swiper-slide-shadow").forEach(u => {
                    u.style.transitionDuration = `${a}ms`
                })
            }), Yf({
                swiper: e,
                duration: a,
                transformElements: l,
                allSlides: !0
            })
        },
        perspective: () => e.params.creativeEffect.perspective,
        overwriteParams: () => ({
            watchSlidesProgress: !0,
            virtualTranslate: !e.params.cssMode
        })
    })
}

function c9(n) {
    let {
        swiper: e,
        extendParams: t,
        on: i
    } = n;
    t({
        cardsEffect: {
            slideShadows: !0,
            rotate: !0,
            perSlideRotate: 2,
            perSlideOffset: 8
        }
    }), oc({
        effect: "cards",
        swiper: e,
        on: i,
        setTranslate: () => {
            const {
                slides: o,
                activeIndex: a,
                rtlTranslate: l
            } = e, c = e.params.cardsEffect, {
                startTranslate: u,
                isTouched: d
            } = e.touchEventsData, h = l ? -e.translate : e.translate;
            for (let f = 0; f < o.length; f += 1) {
                const m = o[f],
                    g = m.progress,
                    A = Math.min(Math.max(g, -4), 4);
                let p = m.swiperSlideOffset;
                e.params.centeredSlides && !e.params.cssMode && (e.wrapperEl.style.transform = `translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (p -= o[0].swiperSlideOffset);
                let v = e.params.cssMode ? -p - e.translate : -p,
                    _ = 0;
                const b = -100 * Math.abs(A);
                let w = 1,
                    E = -c.perSlideRotate * A,
                    C = c.perSlideOffset - Math.abs(A) * .75;
                const S = e.virtual && e.params.virtual.enabled ? e.virtual.from + f : f,
                    x = (S === a || S === a - 1) && A > 0 && A < 1 && (d || e.params.cssMode) && h < u,
                    y = (S === a || S === a + 1) && A < 0 && A > -1 && (d || e.params.cssMode) && h > u;
                if (x || y) {
                    const D = (1 - Math.abs((Math.abs(A) - .5) / .5)) ** .5;
                    E += -28 * A * D, w += -.5 * D, C += 96 * D, _ = `${-25 * D * Math.abs(A)}%`
                }
                if (A < 0 ? v = `calc(${v}px ${l ? "-" : "+"} (${C * Math.abs(A)}%))` : A > 0 ? v = `calc(${v}px ${l ? "-" : "+"} (-${C * Math.abs(A)}%))` : v = `${v}px`, !e.isHorizontal()) {
                    const D = _;
                    _ = v, v = D
                }
                const P = A < 0 ? `${1 + (1 - w) * A}` : `${1 - (1 - w) * A}`,
                    T = `
        translate3d(${v}, ${_}, ${b}px)
        rotateZ(${c.rotate ? l ? -E : E : 0}deg)
        scale(${P})
      `;
                if (c.slideShadows) {
                    let D = m.querySelector(".swiper-slide-shadow");
                    D || (D = Jl("cards", m)), D && (D.style.opacity = Math.min(Math.max((Math.abs(A) - .5) / .5, 0), 1))
                }
                m.style.zIndex = -Math.abs(Math.round(g)) + o.length;
                const R = Ju(c, m);
                R.style.transform = T
            }
        },
        setTransition: o => {
            const a = e.slides.map(l => Ra(l));
            a.forEach(l => {
                l.style.transitionDuration = `${o}ms`, l.querySelectorAll(".swiper-slide-shadow").forEach(c => {
                    c.style.transitionDuration = `${o}ms`
                })
            }), Yf({
                swiper: e,
                duration: o,
                transformElements: a
            })
        },
        perspective: () => !0,
        overwriteParams: () => ({
            watchSlidesProgress: !0,
            virtualTranslate: !e.params.cssMode
        })
    })
}
const u9 = [F4, N4, O4, U4, Q4, z4, G4, H4, V4, W4, q4, $4, j4, Y4, X4, K4, n9, s9, r9, o9, a9, l9, c9];
Nn.use(u9);
const Xf = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"];

function Zl(n) {
    return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object" && !n.__swiper__
}

function dA(n, e) {
    const t = ["__proto__", "constructor", "prototype"];
    Object.keys(e).filter(i => t.indexOf(i) < 0).forEach(i => {
        typeof n[i] > "u" ? n[i] = e[i] : Zl(e[i]) && Zl(n[i]) && Object.keys(e[i]).length > 0 ? e[i].__swiper__ ? n[i] = e[i] : dA(n[i], e[i]) : n[i] = e[i]
    })
}

function d9(n) {
    return n === void 0 && (n = {}), n.navigation && typeof n.navigation.nextEl > "u" && typeof n.navigation.prevEl > "u"
}

function h9(n) {
    return n === void 0 && (n = {}), n.pagination && typeof n.pagination.el > "u"
}

function f9(n) {
    return n === void 0 && (n = {}), n.scrollbar && typeof n.scrollbar.el > "u"
}

function Nh(n) {
    return n === void 0 && (n = ""), n.replace(/-[a-z]/g, e => e.toUpperCase().replace("-", ""))
}

function p9(n) {
    let {
        swiper: e,
        slides: t,
        passedParams: i,
        changedParams: s,
        nextEl: r,
        prevEl: o,
        scrollbarEl: a,
        paginationEl: l
    } = n;
    const c = s.filter(x => x !== "children" && x !== "direction" && x !== "wrapperClass"),
        {
            params: u,
            pagination: d,
            navigation: h,
            scrollbar: f,
            virtual: m,
            thumbs: g
        } = e;
    let A, p, v, _, b, w, E, C;
    s.includes("thumbs") && i.thumbs && i.thumbs.swiper && u.thumbs && !u.thumbs.swiper && (A = !0), s.includes("controller") && i.controller && i.controller.control && u.controller && !u.controller.control && (p = !0), s.includes("pagination") && i.pagination && (i.pagination.el || l) && (u.pagination || u.pagination === !1) && d && !d.el && (v = !0), s.includes("scrollbar") && i.scrollbar && (i.scrollbar.el || a) && (u.scrollbar || u.scrollbar === !1) && f && !f.el && (_ = !0), s.includes("navigation") && i.navigation && (i.navigation.prevEl || o) && (i.navigation.nextEl || r) && (u.navigation || u.navigation === !1) && h && !h.prevEl && !h.nextEl && (b = !0);
    const S = x => {
        e[x] && (e[x].destroy(), x === "navigation" ? (e.isElement && (e[x].prevEl.remove(), e[x].nextEl.remove()), u[x].prevEl = void 0, u[x].nextEl = void 0, e[x].prevEl = void 0, e[x].nextEl = void 0) : (e.isElement && e[x].el.remove(), u[x].el = void 0, e[x].el = void 0))
    };
    s.includes("loop") && e.isElement && (u.loop && !i.loop ? w = !0 : !u.loop && i.loop ? E = !0 : C = !0), c.forEach(x => {
        if (Zl(u[x]) && Zl(i[x])) Object.assign(u[x], i[x]), (x === "navigation" || x === "pagination" || x === "scrollbar") && "enabled" in i[x] && !i[x].enabled && S(x);
        else {
            const y = i[x];
            (y === !0 || y === !1) && (x === "navigation" || x === "pagination" || x === "scrollbar") ? y === !1 && S(x) : u[x] = i[x]
        }
    }), c.includes("controller") && !p && e.controller && e.controller.control && u.controller && u.controller.control && (e.controller.control = u.controller.control), s.includes("children") && t && m && u.virtual.enabled ? (m.slides = t, m.update(!0)) : s.includes("virtual") && m && u.virtual.enabled && (t && (m.slides = t), m.update(!0)), s.includes("children") && t && u.loop && (C = !0), A && g.init() && g.update(!0), p && (e.controller.control = u.controller.control), v && (e.isElement && (!l || typeof l == "string") && (l = document.createElement("div"), l.classList.add("swiper-pagination"), l.part.add("pagination"), e.el.appendChild(l)), l && (u.pagination.el = l), d.init(), d.render(), d.update()), _ && (e.isElement && (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-scrollbar"), a.part.add("scrollbar"), e.el.appendChild(a)), a && (u.scrollbar.el = a), f.init(), f.updateSize(), f.setTranslate()), b && (e.isElement && ((!r || typeof r == "string") && (r = document.createElement("div"), r.classList.add("swiper-button-next"), r.innerHTML = e.hostEl.constructor.nextButtonSvg, r.part.add("button-next"), e.el.appendChild(r)), (!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-button-prev"), o.innerHTML = e.hostEl.constructor.prevButtonSvg, o.part.add("button-prev"), e.el.appendChild(o))), r && (u.navigation.nextEl = r), o && (u.navigation.prevEl = o), h.init(), h.update()), s.includes("allowSlideNext") && (e.allowSlideNext = i.allowSlideNext), s.includes("allowSlidePrev") && (e.allowSlidePrev = i.allowSlidePrev), s.includes("direction") && e.changeDirection(i.direction, !1), (w || C) && e.loopDestroy(), (E || C) && e.loopCreate(), e.update()
}
const kx = n => {
    if (parseFloat(n) === Number(n)) return Number(n);
    if (n === "true" || n === "") return !0;
    if (n === "false") return !1;
    if (n === "null") return null;
    if (n !== "undefined") {
        if (typeof n == "string" && n.includes("{") && n.includes("}") && n.includes('"')) {
            let e;
            try {
                e = JSON.parse(n)
            } catch {
                e = n
            }
            return e
        }
        return n
    }
},
    Fx = ["a11y", "autoplay", "controller", "cards-effect", "coverflow-effect", "creative-effect", "cube-effect", "fade-effect", "flip-effect", "free-mode", "grid", "hash-navigation", "history", "keyboard", "mousewheel", "navigation", "pagination", "parallax", "scrollbar", "thumbs", "virtual", "zoom"];

function Nx(n, e, t) {
    const i = {},
        s = {};
    dA(i, uA);
    const r = [...Xf, "on"],
        o = r.map(l => l.replace(/_/, ""));
    r.forEach(l => {
        l = l.replace("_", ""), typeof n[l] < "u" && (s[l] = n[l])
    });
    const a = [...n.attributes];
    return typeof e == "string" && typeof t < "u" && a.push({
        name: e,
        value: Zl(t) ? {
            ...t
        } : t
    }), a.forEach(l => {
        const c = Fx.filter(u => l.name.indexOf(`${u}-`) === 0)[0];
        if (c) {
            const u = Nh(c),
                d = Nh(l.name.split(`${c}-`)[1]);
            typeof s[u] > "u" && (s[u] = {}), s[u] === !0 && (s[u] = {
                enabled: !0
            }), s[u][d] = kx(l.value)
        } else {
            const u = Nh(l.name);
            if (!o.includes(u)) return;
            const d = kx(l.value);
            s[u] && Fx.includes(l.name) && !Zl(d) ? (s[u].constructor !== Object && (s[u] = {}), s[u].enabled = !!d) : s[u] = d
        }
    }), dA(i, s), i.navigation ? i.navigation = {
        prevEl: ".swiper-button-prev",
        nextEl: ".swiper-button-next",
        ...i.navigation !== !0 ? i.navigation : {}
    } : i.navigation === !1 && delete i.navigation, i.scrollbar ? i.scrollbar = {
        el: ".swiper-scrollbar",
        ...i.scrollbar !== !0 ? i.scrollbar : {}
    } : i.scrollbar === !1 && delete i.scrollbar, i.pagination ? i.pagination = {
        el: ".swiper-pagination",
        ...i.pagination !== !0 ? i.pagination : {}
    } : i.pagination === !1 && delete i.pagination, {
        params: i,
        passedParams: s
    }
}
const m9 = ":host{--swiper-theme-color:#007aff}:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}.swiper{width:100%;height:100%;margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android ::slotted(swiper-slide),.swiper-ios ::slotted(swiper-slide),.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}::slotted(swiper-slide){flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}::slotted(.swiper-slide-invisible-blank){visibility:hidden}.swiper-autoheight,.swiper-autoheight ::slotted(swiper-slide){height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden ::slotted(swiper-slide){transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d ::slotted(swiper-slide){transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode ::slotted(swiper-slide){scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode ::slotted(swiper-slide){scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered ::slotted(swiper-slide){scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal ::slotted(swiper-slide):first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical ::slotted(swiper-slide):first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-virtual ::slotted(swiper-slide){-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:host{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next svg,.swiper-button-prev svg{width:100%;height:100%;object-fit:contain;transform-origin:center}.swiper-rtl .swiper-button-next svg,.swiper-rtl .swiper-button-prev svg{transform:rotate(180deg)}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius,50%);background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}::slotted(.swiper-slide-zoomed){cursor:move;touch-action:none}.swiper .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode ::slotted(swiper-slide){transition-timing-function:ease-out}.swiper-fade ::slotted(swiper-slide){pointer-events:none;transition-property:opacity}.swiper-fade ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-fade ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-fade ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-cube.swiper-rtl ::slotted(swiper-slide){transform-origin:100% 0}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-next),.swiper-cube ::slotted(.swiper-slide-prev){pointer-events:auto;visibility:visible}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-cube ::slotted(.swiper-slide-next)+::slotted(swiper-slide){pointer-events:auto;visibility:visible}.swiper-flip{overflow:visible}.swiper-flip ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-flip ::slotted(.swiper-slide-active),.swiper-flip ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-creative ::slotted(swiper-slide){-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards ::slotted(swiper-slide){transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}",
    g9 = "::slotted(.swiper-slide-shadow),::slotted(.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-top){position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}::slotted(.swiper-slide-shadow){background:rgba(0,0,0,.15)}::slotted(.swiper-slide-shadow-left){background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-right){background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-top){background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-bottom){background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear;width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-zoom-container){width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}::slotted(.swiper-zoom-container)>canvas,::slotted(.swiper-zoom-container)>img,::slotted(.swiper-zoom-container)>svg{max-width:100%;max-height:100%;object-fit:contain}";
class A9 { }
const CS = typeof window > "u" || typeof HTMLElement > "u" ? A9 : HTMLElement,
    Ox = `<svg width="11" height="20" viewBox="0 0 11 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z" fill="currentColor"/></svg>
    `,
    SS = (n, e) => {
        if (typeof CSSStyleSheet < "u" && n.adoptedStyleSheets) {
            const t = new CSSStyleSheet;
            t.replaceSync(e), n.adoptedStyleSheets = [t]
        } else {
            const t = document.createElement("style");
            t.rel = "stylesheet", t.textContent = e, n.appendChild(t)
        }
    };
class MS extends CS {
    constructor() {
        super(), this.attachShadow({
            mode: "open"
        })
    }
    static get nextButtonSvg() {
        return Ox
    }
    static get prevButtonSvg() {
        return Ox.replace("/></svg>", ' transform-origin="center" transform="rotate(180)"/></svg>')
    }
    cssStyles() {
        return [m9, ...this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : []].join(`
`)
    }
    cssLinks() {
        return this.injectStylesUrls || []
    }
    calcSlideSlots() {
        const e = this.slideSlots || 0,
            t = [...this.querySelectorAll("[slot^=slide-]")].map(i => parseInt(i.getAttribute("slot").split("slide-")[1], 10));
        if (this.slideSlots = t.length ? Math.max(...t) + 1 : 0, !!this.rendered) {
            if (this.slideSlots > e)
                for (let i = e; i < this.slideSlots; i += 1) {
                    const s = document.createElement("swiper-slide");
                    s.setAttribute("part", `slide slide-${i + 1}`);
                    const r = document.createElement("slot");
                    r.setAttribute("name", `slide-${i + 1}`), s.appendChild(r), this.shadowRoot.querySelector(".swiper-wrapper").appendChild(s)
                } else if (this.slideSlots < e) {
                    const i = this.swiper.slides;
                    for (let s = i.length - 1; s >= 0; s -= 1) s > this.slideSlots && i[s].remove()
                }
        }
    }
    render() {
        if (this.rendered) return;
        this.calcSlideSlots();
        let e = this.cssStyles();
        this.slideSlots > 0 && (e = e.replace(/::slotted\(([a-z-0-9.]*)\)/g, "$1")), e.length && SS(this.shadowRoot, e), this.cssLinks().forEach(i => {
            if (this.shadowRoot.querySelector(`link[href="${i}"]`)) return;
            const r = document.createElement("link");
            r.rel = "stylesheet", r.href = i, this.shadowRoot.appendChild(r)
        });
        const t = document.createElement("div");
        t.classList.add("swiper"), t.part = "container", t.innerHTML = `
      <slot name="container-start"></slot>
      <div class="swiper-wrapper" part="wrapper">
        <slot></slot>
        ${Array.from({ length: this.slideSlots }).map((i, s) => ` <
            swiper - slide part = "slide slide-${s}" >
            <
            slot name = "slide-${s}" > < /slot> <
            /swiper-slide>
        `).join("")}
      </div>
      <slot name="container-end"></slot>
      ${d9(this.passedParams) ? `
        <div part="button-prev" class="swiper-button-prev">${this.constructor.prevButtonSvg}</div>
        <div part="button-next" class="swiper-button-next">${this.constructor.nextButtonSvg}</div>
      `: ""}
      ${h9(this.passedParams) ? `
        <div part="pagination" class="swiper-pagination"></div>
      `: ""}
      ${f9(this.passedParams) ? `
        <div part="scrollbar" class="swiper-scrollbar"></div>
      `: ""}
    `, this.shadowRoot.appendChild(t), this.rendered = !0
    }
    initialize() {
        var e = this;
        if (this.initialized) return;
        this.initialized = !0;
        const {
            params: t,
            passedParams: i
        } = Nx(this);
        this.swiperParams = t, this.passedParams = i, delete this.swiperParams.init, this.render(), this.swiper = new Nn(this.shadowRoot.querySelector(".swiper"), {
            ...t.virtual ? {} : {
                observer: !0,
                observeSlideChildren: this.slideSlots > 0
            },
            ...t,
            touchEventsTarget: "container",
            onAny: function (s) {
                s === "observerUpdate" && e.calcSlideSlots();
                const r = t.eventsPrefix ? `${t.eventsPrefix}${s.toLowerCase()}` : s.toLowerCase();
                for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), l = 1; l < o; l++) a[l - 1] = arguments[l];
                const c = new CustomEvent(r, {
                    detail: a,
                    bubbles: s !== "hashChange",
                    cancelable: !0
                });
                e.dispatchEvent(c)
            }
        })
    }
    connectedCallback() {
        this.initialized && this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM || this.init === !1 || this.getAttribute("init") === "false" || this.initialize()
    }
    disconnectedCallback() {
        this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM || (this.swiper && this.swiper.destroy && this.swiper.destroy(), this.initialized = !1)
    }
    updateSwiperOnPropChange(e, t) {
        const {
            params: i,
            passedParams: s
        } = Nx(this, e, t);
        this.passedParams = s, this.swiperParams = i, !(this.swiper && this.swiper.params[e] === t) && p9({
            swiper: this.swiper,
            passedParams: this.passedParams,
            changedParams: [Nh(e)],
            ...e === "navigation" && s[e] ? {
                prevEl: ".swiper-button-prev",
                nextEl: ".swiper-button-next"
            } : {},
            ...e === "pagination" && s[e] ? {
                paginationEl: ".swiper-pagination"
            } : {},
            ...e === "scrollbar" && s[e] ? {
                scrollbarEl: ".swiper-scrollbar"
            } : {}
        })
    }
    attributeChangedCallback(e, t, i) {
        this.initialized && (t === "true" && i === null && (i = !1), this.updateSwiperOnPropChange(e, i))
    }
    static get observedAttributes() {
        return Xf.filter(t => t.includes("_")).map(t => t.replace(/[A-Z]/g, i => `-${i}`).replace("_", "").toLowerCase())
    }
}
Xf.forEach(n => {
    n !== "init" && (n = n.replace("_", ""), Object.defineProperty(MS.prototype, n, {
        configurable: !0,
        get() {
            return (this.passedParams || {})[n]
        },
        set(e) {
            this.passedParams || (this.passedParams = {}), this.passedParams[n] = e, this.initialized && this.updateSwiperOnPropChange(n, e)
        }
    }))
});
class _9 extends CS {
    constructor() {
        super(), this.attachShadow({
            mode: "open"
        })
    }
    render() {
        const e = this.lazy || this.getAttribute("lazy") === "" || this.getAttribute("lazy") === "true";
        if (SS(this.shadowRoot, g9), this.shadowRoot.appendChild(document.createElement("slot")), e) {
            const t = document.createElement("div");
            t.classList.add("swiper-lazy-preloader"), t.part.add("preloader"), this.shadowRoot.appendChild(t)
        }
    }
    initialize() {
        this.render()
    }
    connectedCallback() {
        this.initialize()
    }
}
const v9 = () => {
    typeof window > "u" || (window.customElements.get("swiper-container") || window.customElements.define("swiper-container", MS), window.customElements.get("swiper-slide") || window.customElements.define("swiper-slide", _9))
};
typeof window < "u" && (window.SwiperElementRegisterParams = n => {
    Xf.push(...n)
});
const b9 = {
    name: "AppModal"
},
    x9 = {
        class: "g-modal"
    };

function y9(n, e, t, i, s, r) {
    return Ge(), st("div", x9)
}
const E9 = ki(b9, [
    ["render", y9]
]),
    w9 = {
        name: "GlobalArrowDownRight"
    },
    C9 = {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    },
    S9 = ie("path", {
        d: "M7 7L17 17",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null, -1),
    M9 = ie("path", {
        d: "M17 7V17H7",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }, null, -1),
    T9 = [S9, M9];

function I9(n, e, t, i, s, r) {
    return Ge(), st("svg", C9, T9)
}
const B9 = ki(w9, [
    ["render", I9]
]),
    R9 = {
        name: "LayoutSection",
        props: {
            timelinesOptions: {
                type: Array,
                required: !0
            }
        },
        mounted() {
            this.timelinesOptions.forEach(({
                scrollTrigger: n,
                media: e,
                callback: t
            }) => {
                const i = {
                    scrollTrigger: {
                        trigger: this.$el,
                        overwrite: !0,
                        ...n
                    }
                };
                this.createTimeline(i, e, t)
            })
        },
        methods: {
            createTimeline(n, e, t) {
                let i, s;
                e ? bt.matchMedia().add(e, o => {
                    const {
                        isDestroy: a
                    } = o.conditions;
                    a || (i = bt.timeline(n), t(i, o))
                }) : (i = bt.timeline(n), t(i)), window.addEventListener("resize", () => {
                    clearTimeout(s), s = setTimeout(() => {
                        var r;
                        (r = i == null ? void 0 : i.scrollTrigger) == null || r.refresh()
                    }, 300)
                })
            }
        }
    },
    P9 = {
        class: "g-layout-section"
    };

function D9(n, e, t, i, s, r) {
    return Ge(), st("div", P9, [KM(n.$slots, "default", {
        ref: "slot"
    })])
}
const L9 = ki(R9, [
    ["render", D9]
]),
    Zu = hI(vH);
Zu.use(gI());
Zu.component("g-modal", E9);
Zu.component("g-arrow-down-right", B9);
Zu.component("g-layout-section", L9);
v9();
Zu.mount("#app");
"scrollRestoration" in history && (history.scrollRestoration = "manual");
document.documentElement.scrollTop = 0;
//# sourceMappingURL=index-DJ7BLl7N.js.map